diff --git a/src/cmd/api/boring_test.go b/src/cmd/api/boring_test.go
index f0e3575637..a4139169b8 100644
--- a/src/cmd/api/boring_test.go
+++ b/src/cmd/api/boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build !no_openssl
 
 package main
 
@@ -12,6 +12,6 @@ import (
 )
 
 func init() {
-	fmt.Printf("SKIP with boringcrypto enabled\n")
+	fmt.Printf("SKIP with !no_openssl enabled\n")
 	os.Exit(0)
 }
diff --git a/src/crypto/aes/cipher.go b/src/crypto/aes/cipher.go
index a9e6208696..1de76641aa 100644
--- a/src/crypto/aes/cipher.go
+++ b/src/crypto/aes/cipher.go
@@ -7,7 +7,7 @@ package aes
 import (
 	"crypto/cipher"
 	"crypto/internal/alias"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"strconv"
 )
 
@@ -38,7 +38,7 @@ func NewCipher(key []byte) (cipher.Block, error) {
 	case 16, 24, 32:
 		break
 	}
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.NewAESCipher(key)
 	}
 	return newCipher(key)
diff --git a/src/crypto/aes/cipher_asm.go b/src/crypto/aes/cipher_asm.go
index 90031c5e2c..e80e82c82b 100644
--- a/src/crypto/aes/cipher_asm.go
+++ b/src/crypto/aes/cipher_asm.go
@@ -9,7 +9,7 @@ package aes
 import (
 	"crypto/cipher"
 	"crypto/internal/alias"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"internal/cpu"
 	"internal/goarch"
 )
diff --git a/src/crypto/boring/boring.go b/src/crypto/boring/boring.go
index 097c37e343..47618fe3c6 100644
--- a/src/crypto/boring/boring.go
+++ b/src/crypto/boring/boring.go
@@ -13,9 +13,9 @@
 // is satisfied, so that applications can tag files that use this package.
 package boring
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // Enabled reports whether BoringCrypto handles supported crypto operations.
 func Enabled() bool {
-	return boring.Enabled
+	return boring.Enabled()
 }
diff --git a/src/crypto/boring/boring_test.go b/src/crypto/boring/boring_test.go
deleted file mode 100644
index 33e5f1b37e..0000000000
--- a/src/crypto/boring/boring_test.go
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//go:build boringcrypto
-
-package boring_test
-
-import (
-	"crypto/boring"
-	"runtime"
-	"testing"
-)
-
-func TestEnabled(t *testing.T) {
-	supportedPlatform := runtime.GOOS == "linux" && (runtime.GOARCH == "amd64" || runtime.GOARCH == "arm64")
-	if supportedPlatform && !boring.Enabled() {
-		t.Error("Enabled returned false on a supported platform")
-	} else if !supportedPlatform && boring.Enabled() {
-		t.Error("Enabled returned true on an unsupported platform")
-	}
-}
diff --git a/src/crypto/boring/notboring_test.go b/src/crypto/boring/notboring_test.go
deleted file mode 100644
index 0701628464..0000000000
--- a/src/crypto/boring/notboring_test.go
+++ /dev/null
@@ -1,13 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//go:build (goexperiment.boringcrypto && !boringcrypto) || (!goexperiment.boringcrypto && boringcrypto)
-
-package boring_test
-
-import "testing"
-
-func TestNotBoring(t *testing.T) {
-	t.Error("goexperiment.boringcrypto and boringcrypto should be equivalent build tags")
-}
diff --git a/src/crypto/ecdh/ecdh.go b/src/crypto/ecdh/ecdh.go
index b7c26f91e5..0e6680fd04 100644
--- a/src/crypto/ecdh/ecdh.go
+++ b/src/crypto/ecdh/ecdh.go
@@ -8,7 +8,7 @@ package ecdh
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/subtle"
 	"errors"
 	"io"
@@ -167,7 +167,7 @@ func (k *PrivateKey) PublicKey() *PublicKey {
 			// (We can't return it anyhow.)
 			kpub, err := k.boring.PublicKey()
 			if err != nil {
-				panic("boringcrypto: " + err.Error())
+				panic("!no_openssl: " + err.Error())
 			}
 			k.publicKey = &PublicKey{
 				curve:     k.curve,
diff --git a/src/crypto/ecdh/ecdh_test.go b/src/crypto/ecdh/ecdh_test.go
index af6bcd86f4..cc111c5564 100644
--- a/src/crypto/ecdh/ecdh_test.go
+++ b/src/crypto/ecdh/ecdh_test.go
@@ -9,7 +9,7 @@ import (
 	"crypto"
 	"crypto/cipher"
 	"crypto/ecdh"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"crypto/sha256"
 	"encoding/hex"
@@ -288,8 +288,8 @@ func TestNewPrivateKey(t *testing.T) {
 				t.Errorf("unexpectedly accepted %q", input)
 			} else if k != nil {
 				t.Error("PrivateKey was not nil on error")
-			} else if strings.Contains(err.Error(), "boringcrypto") {
-				t.Errorf("boringcrypto error leaked out: %v", err)
+			} else if strings.Contains(err.Error(), "!no_openssl") {
+				t.Errorf("!no_openssl error leaked out: %v", err)
 			}
 		}
 	})
@@ -349,8 +349,8 @@ func TestNewPublicKey(t *testing.T) {
 				t.Errorf("unexpectedly accepted %q", input)
 			} else if k != nil {
 				t.Error("PublicKey was not nil on error")
-			} else if strings.Contains(err.Error(), "boringcrypto") {
-				t.Errorf("boringcrypto error leaked out: %v", err)
+			} else if strings.Contains(err.Error(), "!no_openssl") {
+				t.Errorf("!no_openssl error leaked out: %v", err)
 			}
 		}
 	})
@@ -443,7 +443,7 @@ func main() {
 // implementations into the binary. This also guarantees that govulncheck can
 // avoid warning about a curve-specific vulnerability if that curve is not used.
 func TestLinker(t *testing.T) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		t.Skip("test doesn't make sense when building with external crypto backend")
 	}
 	if testing.Short() {
diff --git a/src/crypto/ecdh/nist.go b/src/crypto/ecdh/nist.go
index b366491544..a930d7e5e2 100644
--- a/src/crypto/ecdh/nist.go
+++ b/src/crypto/ecdh/nist.go
@@ -5,7 +5,7 @@
 package ecdh
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/nistec"
 	"crypto/internal/randutil"
 	"encoding/binary"
@@ -36,7 +36,7 @@ func (c *nistCurve[Point]) String() string {
 var errInvalidPrivateKey = errors.New("crypto/ecdh: invalid private key")
 
 func (c *nistCurve[Point]) GenerateKey(rand io.Reader) (*PrivateKey, error) {
-	if boring.Enabled && rand == boring.RandReader {
+	if boring.Enabled() && rand == boring.RandReader {
 		key, bytes, err := boring.GenerateKeyECDH(c.name)
 		if err != nil {
 			return nil, err
@@ -79,7 +79,7 @@ func (c *nistCurve[Point]) NewPrivateKey(key []byte) (*PrivateKey, error) {
 	if isZero(key) || !isLess(key, c.scalarOrder) {
 		return nil, errInvalidPrivateKey
 	}
-	if boring.Enabled {
+	if boring.Enabled() {
 		bk, err := boring.NewPrivateKeyECDH(c.name, key)
 		if err != nil {
 			return nil, err
@@ -173,7 +173,7 @@ func (c *nistCurve[Point]) NewPublicKey(key []byte) (*PublicKey, error) {
 		curve:     c,
 		publicKey: append([]byte{}, key...),
 	}
-	if boring.Enabled {
+	if boring.Enabled() {
 		bk, err := boring.NewPublicKeyECDH(c.name, k.publicKey)
 		if err != nil {
 			return nil, err
@@ -196,7 +196,7 @@ func (c *nistCurve[Point]) ecdh(local *PrivateKey, remote *PublicKey) ([]byte, e
 	// only be the result of a scalar multiplication if one of the inputs is the
 	// zero scalar or the point at infinity.
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.ECDH(local.boring, remote.boring)
 	}
 
diff --git a/src/crypto/ecdsa/boring.go b/src/crypto/ecdsa/boring.go
index 275c60b4de..58f0034b18 100644
--- a/src/crypto/ecdsa/boring.go
+++ b/src/crypto/ecdsa/boring.go
@@ -2,13 +2,13 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build !no_openssl
 
 package ecdsa
 
 import (
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/boring/bcache"
 	"math/big"
 )
diff --git a/src/crypto/ecdsa/ecdsa.go b/src/crypto/ecdsa/ecdsa.go
index 3ed15a888a..d5ab3d32e3 100644
--- a/src/crypto/ecdsa/ecdsa.go
+++ b/src/crypto/ecdsa/ecdsa.go
@@ -27,8 +27,8 @@ import (
 	"crypto/ecdh"
 	"crypto/elliptic"
 	"crypto/internal/bigmod"
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/nistec"
 	"crypto/internal/randutil"
 	"crypto/sha512"
@@ -158,7 +158,7 @@ func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOp
 func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error) {
 	randutil.MaybeReadByte(rand)
 
-	if boring.Enabled && rand == boring.RandReader {
+	if boring.Enabled() && rand == boring.RandReader {
 		x, y, d, err := boring.GenerateKeyECDSA(c.Params().Name)
 		if err != nil {
 			return nil, err
@@ -256,7 +256,7 @@ var errNoAsm = errors.New("no assembly implementation available")
 func SignASN1(rand io.Reader, priv *PrivateKey, hash []byte) ([]byte, error) {
 	randutil.MaybeReadByte(rand)
 
-	if boring.Enabled && rand == boring.RandReader {
+	if boring.Enabled() && rand == boring.RandReader {
 		b, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -466,7 +466,7 @@ func (zr) Read(dst []byte) (n int, err error) {
 // VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the
 // public key, pub. Its return value records whether the signature is valid.
 func VerifyASN1(pub *PublicKey, hash, sig []byte) bool {
-	if boring.Enabled {
+	if boring.Enabled() {
 		key, err := boringPublicKey(pub)
 		if err != nil {
 			return false
diff --git a/src/crypto/ecdsa/ecdsa_test.go b/src/crypto/ecdsa/ecdsa_test.go
index 61a4662036..80e484842b 100644
--- a/src/crypto/ecdsa/ecdsa_test.go
+++ b/src/crypto/ecdsa/ecdsa_test.go
@@ -10,7 +10,7 @@ import (
 	"compress/bzip2"
 	"crypto/elliptic"
 	"crypto/internal/backend/boringtest"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/bigmod"
 	"crypto/rand"
 	"crypto/sha1"
@@ -38,7 +38,7 @@ func testAllCurves(t *testing.T, f func(*testing.T, elliptic.Curve)) {
 	}
 	if testing.Short() {
 		tests = tests[:1]
-	} else if !boring.Enabled || boringtest.Supports(t, "CurveP224") {
+	} else if !boring.Enabled() || boringtest.Supports(t, "CurveP224") {
 		p224 := struct {
 			name  string
 			curve elliptic.Curve
@@ -46,7 +46,7 @@ func testAllCurves(t *testing.T, f func(*testing.T, elliptic.Curve)) {
 		tests = append(tests, p224)
 	}
 	for _, test := range tests {
-		if boring.Enabled && !boringtest.Supports(t, "Curve"+test.name) {
+		if boring.Enabled() && !boringtest.Supports(t, "Curve"+test.name) {
 			t.Skip("unsupported test in FIPS mode")
 		}
 		curve := test.curve
@@ -246,7 +246,7 @@ func TestVectors(t *testing.T) {
 
 			switch curve {
 			case "P-224":
-				if !boring.Enabled || boringtest.Supports(t, "CurveP224") {
+				if !boring.Enabled() || boringtest.Supports(t, "CurveP224") {
 					pub.Curve = elliptic.P224()
 				} else {
 					pub.Curve = nil
diff --git a/src/crypto/ecdsa/equal_test.go b/src/crypto/ecdsa/equal_test.go
index 4371e31b1a..5ef62abe37 100644
--- a/src/crypto/ecdsa/equal_test.go
+++ b/src/crypto/ecdsa/equal_test.go
@@ -10,7 +10,7 @@ import (
 	"crypto/elliptic"
 	"crypto/rand"
 	"crypto/x509"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/backend/boringtest"
 	"testing"
 )
@@ -71,7 +71,7 @@ func TestEqual(t *testing.T) {
 	if testing.Short() {
 		return
 	}
-	if !boring.Enabled || boringtest.Supports(t, "CurveP224") {
+	if !boring.Enabled() || boringtest.Supports(t, "CurveP224") {
 		t.Run("P224", func(t *testing.T) { testEqual(t, elliptic.P224()) })
 	}
 	t.Run("P384", func(t *testing.T) { testEqual(t, elliptic.P384()) })
diff --git a/src/crypto/ecdsa/notboring.go b/src/crypto/ecdsa/notboring.go
index 039bd82ed2..21a35b760c 100644
--- a/src/crypto/ecdsa/notboring.go
+++ b/src/crypto/ecdsa/notboring.go
@@ -2,15 +2,15 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto
+//go:build no_openssl
 
 package ecdsa
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 func boringPublicKey(*PublicKey) (*boring.PublicKeyECDSA, error) {
-	panic("boringcrypto: not available")
+	panic("!no_openssl: not available")
 }
 func boringPrivateKey(*PrivateKey) (*boring.PrivateKeyECDSA, error) {
-	panic("boringcrypto: not available")
+	panic("!no_openssl: not available")
 }
diff --git a/src/crypto/ed25519/ed25519_test.go b/src/crypto/ed25519/ed25519_test.go
index 8b5c2cc9af..ebbb1c0c07 100644
--- a/src/crypto/ed25519/ed25519_test.go
+++ b/src/crypto/ed25519/ed25519_test.go
@@ -9,7 +9,7 @@ import (
 	"bytes"
 	"compress/gzip"
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"crypto/sha512"
 	"encoding/hex"
@@ -322,7 +322,7 @@ func TestMalleability(t *testing.T) {
 
 func TestAllocations(t *testing.T) {
 	t.Skip("Allocations test broken with openssl linkage")
-	if boring.Enabled {
+	if boring.Enabled() {
 		t.Skip("skipping allocations test with BoringCrypto")
 	}
 	testenv.SkipIfOptimizationOff(t)
diff --git a/src/crypto/hmac/hmac.go b/src/crypto/hmac/hmac.go
index 46ec81b8c5..1b99c68577 100644
--- a/src/crypto/hmac/hmac.go
+++ b/src/crypto/hmac/hmac.go
@@ -22,7 +22,7 @@ timing side-channels:
 package hmac
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/subtle"
 	"hash"
 )
@@ -127,7 +127,7 @@ func (h *hmac) Reset() {
 // the returned Hash does not implement [encoding.BinaryMarshaler]
 // or [encoding.BinaryUnmarshaler].
 func New(h func() hash.Hash, key []byte) hash.Hash {
-	if boring.Enabled {
+	if boring.Enabled() {
 		hm := boring.NewHMAC(h, key)
 		if hm != nil {
 			return hm
diff --git a/src/crypto/hmac/hmac_test.go b/src/crypto/hmac/hmac_test.go
index 55415abf02..0edd7a6003 100644
--- a/src/crypto/hmac/hmac_test.go
+++ b/src/crypto/hmac/hmac_test.go
@@ -6,7 +6,7 @@ package hmac
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/md5"
 	"crypto/sha1"
 	"crypto/sha256"
@@ -584,8 +584,8 @@ func TestHMAC(t *testing.T) {
 }
 
 func TestNonUniqueHash(t *testing.T) {
-	if boring.Enabled {
-		t.Skip("hash.Hash provided by boringcrypto are not comparable")
+	if boring.Enabled() {
+		t.Skip("hash.Hash provided by !no_openssl are not comparable")
 	}
 	sha := sha256.New()
 	defer func() {
diff --git a/src/crypto/internal/boring/aes.go b/src/crypto/internal/boring/aes.go
deleted file mode 100644
index 8819f576f4..0000000000
--- a/src/crypto/internal/boring/aes.go
+++ /dev/null
@@ -1,385 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//go:build boringcrypto && linux && (amd64 || arm64) && !android && !msan
-
-package boring
-
-/*
-
-#include "goboringcrypto.h"
-
-// These wrappers allocate out_len on the C stack, and check that it matches the expected
-// value, to avoid having to pass a pointer from Go, which would escape to the heap.
-
-int EVP_AEAD_CTX_seal_wrapper(const GO_EVP_AEAD_CTX *ctx, uint8_t *out,
-							  size_t exp_out_len,
-							  const uint8_t *nonce, size_t nonce_len,
-							  const uint8_t *in, size_t in_len,
-							  const uint8_t *ad, size_t ad_len) {
-	size_t out_len;
-	int ok = _goboringcrypto_EVP_AEAD_CTX_seal(ctx, out, &out_len, exp_out_len,
-		nonce, nonce_len, in, in_len, ad, ad_len);
-	if (out_len != exp_out_len) {
-		return 0;
-	}
-	return ok;
-};
-
-int EVP_AEAD_CTX_open_wrapper(const GO_EVP_AEAD_CTX *ctx, uint8_t *out,
-							  size_t exp_out_len,
-							  const uint8_t *nonce, size_t nonce_len,
-							  const uint8_t *in, size_t in_len,
-							  const uint8_t *ad, size_t ad_len) {
-	size_t out_len;
-	int ok = _goboringcrypto_EVP_AEAD_CTX_open(ctx, out, &out_len, exp_out_len,
-		nonce, nonce_len, in, in_len, ad, ad_len);
-	if (out_len != exp_out_len) {
-		return 0;
-	}
-	return ok;
-};
-
-*/
-import "C"
-import (
-	"bytes"
-	"crypto/cipher"
-	"errors"
-	"runtime"
-	"strconv"
-	"unsafe"
-)
-
-type aesKeySizeError int
-
-func (k aesKeySizeError) Error() string {
-	return "crypto/aes: invalid key size " + strconv.Itoa(int(k))
-}
-
-const aesBlockSize = 16
-
-type aesCipher struct {
-	key []byte
-	enc C.GO_AES_KEY
-	dec C.GO_AES_KEY
-}
-
-type extraModes interface {
-	// Copied out of crypto/aes/modes.go.
-	NewCBCEncrypter(iv []byte) cipher.BlockMode
-	NewCBCDecrypter(iv []byte) cipher.BlockMode
-	NewCTR(iv []byte) cipher.Stream
-	NewGCM(nonceSize, tagSize int) (cipher.AEAD, error)
-}
-
-var _ extraModes = (*aesCipher)(nil)
-
-func NewAESCipher(key []byte) (cipher.Block, error) {
-	c := &aesCipher{key: bytes.Clone(key)}
-	// Note: 0 is success, contradicting the usual BoringCrypto convention.
-	if C._goboringcrypto_AES_set_decrypt_key((*C.uint8_t)(unsafe.Pointer(&c.key[0])), C.uint(8*len(c.key)), &c.dec) != 0 ||
-		C._goboringcrypto_AES_set_encrypt_key((*C.uint8_t)(unsafe.Pointer(&c.key[0])), C.uint(8*len(c.key)), &c.enc) != 0 {
-		return nil, aesKeySizeError(len(key))
-	}
-	return c, nil
-}
-
-func (c *aesCipher) BlockSize() int { return aesBlockSize }
-
-func (c *aesCipher) Encrypt(dst, src []byte) {
-	if inexactOverlap(dst, src) {
-		panic("crypto/cipher: invalid buffer overlap")
-	}
-	if len(src) < aesBlockSize {
-		panic("crypto/aes: input not full block")
-	}
-	if len(dst) < aesBlockSize {
-		panic("crypto/aes: output not full block")
-	}
-	C._goboringcrypto_AES_encrypt(
-		(*C.uint8_t)(unsafe.Pointer(&src[0])),
-		(*C.uint8_t)(unsafe.Pointer(&dst[0])),
-		&c.enc)
-}
-
-func (c *aesCipher) Decrypt(dst, src []byte) {
-	if inexactOverlap(dst, src) {
-		panic("crypto/cipher: invalid buffer overlap")
-	}
-	if len(src) < aesBlockSize {
-		panic("crypto/aes: input not full block")
-	}
-	if len(dst) < aesBlockSize {
-		panic("crypto/aes: output not full block")
-	}
-	C._goboringcrypto_AES_decrypt(
-		(*C.uint8_t)(unsafe.Pointer(&src[0])),
-		(*C.uint8_t)(unsafe.Pointer(&dst[0])),
-		&c.dec)
-}
-
-type aesCBC struct {
-	key  *C.GO_AES_KEY
-	mode C.int
-	iv   [aesBlockSize]byte
-}
-
-func (x *aesCBC) BlockSize() int { return aesBlockSize }
-
-func (x *aesCBC) CryptBlocks(dst, src []byte) {
-	if inexactOverlap(dst, src) {
-		panic("crypto/cipher: invalid buffer overlap")
-	}
-	if len(src)%aesBlockSize != 0 {
-		panic("crypto/cipher: input not full blocks")
-	}
-	if len(dst) < len(src) {
-		panic("crypto/cipher: output smaller than input")
-	}
-	if len(src) > 0 {
-		C._goboringcrypto_AES_cbc_encrypt(
-			(*C.uint8_t)(unsafe.Pointer(&src[0])),
-			(*C.uint8_t)(unsafe.Pointer(&dst[0])),
-			C.size_t(len(src)), x.key,
-			(*C.uint8_t)(unsafe.Pointer(&x.iv[0])), x.mode)
-	}
-}
-
-func (x *aesCBC) SetIV(iv []byte) {
-	if len(iv) != aesBlockSize {
-		panic("cipher: incorrect length IV")
-	}
-	copy(x.iv[:], iv)
-}
-
-func (c *aesCipher) NewCBCEncrypter(iv []byte) cipher.BlockMode {
-	x := &aesCBC{key: &c.enc, mode: C.GO_AES_ENCRYPT}
-	copy(x.iv[:], iv)
-	return x
-}
-
-func (c *aesCipher) NewCBCDecrypter(iv []byte) cipher.BlockMode {
-	x := &aesCBC{key: &c.dec, mode: C.GO_AES_DECRYPT}
-	copy(x.iv[:], iv)
-	return x
-}
-
-type aesCTR struct {
-	key        *C.GO_AES_KEY
-	iv         [aesBlockSize]byte
-	num        C.uint
-	ecount_buf [16]C.uint8_t
-}
-
-func (x *aesCTR) XORKeyStream(dst, src []byte) {
-	if inexactOverlap(dst, src) {
-		panic("crypto/cipher: invalid buffer overlap")
-	}
-	if len(dst) < len(src) {
-		panic("crypto/cipher: output smaller than input")
-	}
-	if len(src) == 0 {
-		return
-	}
-	C._goboringcrypto_AES_ctr128_encrypt(
-		(*C.uint8_t)(unsafe.Pointer(&src[0])),
-		(*C.uint8_t)(unsafe.Pointer(&dst[0])),
-		C.size_t(len(src)), x.key, (*C.uint8_t)(unsafe.Pointer(&x.iv[0])),
-		&x.ecount_buf[0], &x.num)
-}
-
-func (c *aesCipher) NewCTR(iv []byte) cipher.Stream {
-	x := &aesCTR{key: &c.enc}
-	copy(x.iv[:], iv)
-	return x
-}
-
-type aesGCM struct {
-	ctx  C.GO_EVP_AEAD_CTX
-	aead *C.GO_EVP_AEAD
-}
-
-const (
-	gcmBlockSize         = 16
-	gcmTagSize           = 16
-	gcmStandardNonceSize = 12
-)
-
-type aesNonceSizeError int
-
-func (n aesNonceSizeError) Error() string {
-	return "crypto/aes: invalid GCM nonce size " + strconv.Itoa(int(n))
-}
-
-type noGCM struct {
-	cipher.Block
-}
-
-func (c *aesCipher) NewGCM(nonceSize, tagSize int) (cipher.AEAD, error) {
-	if nonceSize != gcmStandardNonceSize && tagSize != gcmTagSize {
-		return nil, errors.New("crypto/aes: GCM tag and nonce sizes can't be non-standard at the same time")
-	}
-	// Fall back to standard library for GCM with non-standard nonce or tag size.
-	if nonceSize != gcmStandardNonceSize {
-		return cipher.NewGCMWithNonceSize(&noGCM{c}, nonceSize)
-	}
-	if tagSize != gcmTagSize {
-		return cipher.NewGCMWithTagSize(&noGCM{c}, tagSize)
-	}
-	return c.newGCM(false)
-}
-
-func NewGCMTLS(c cipher.Block) (cipher.AEAD, error) {
-	return c.(*aesCipher).newGCM(true)
-}
-
-func (c *aesCipher) newGCM(tls bool) (cipher.AEAD, error) {
-	var aead *C.GO_EVP_AEAD
-	switch len(c.key) * 8 {
-	case 128:
-		if tls {
-			aead = C._goboringcrypto_EVP_aead_aes_128_gcm_tls12()
-		} else {
-			aead = C._goboringcrypto_EVP_aead_aes_128_gcm()
-		}
-	case 256:
-		if tls {
-			aead = C._goboringcrypto_EVP_aead_aes_256_gcm_tls12()
-		} else {
-			aead = C._goboringcrypto_EVP_aead_aes_256_gcm()
-		}
-	default:
-		// Fall back to standard library for GCM with non-standard key size.
-		return cipher.NewGCMWithNonceSize(&noGCM{c}, gcmStandardNonceSize)
-	}
-
-	g := &aesGCM{aead: aead}
-	if C._goboringcrypto_EVP_AEAD_CTX_init(&g.ctx, aead, (*C.uint8_t)(unsafe.Pointer(&c.key[0])), C.size_t(len(c.key)), C.GO_EVP_AEAD_DEFAULT_TAG_LENGTH, nil) == 0 {
-		return nil, fail("EVP_AEAD_CTX_init")
-	}
-	// Note: Because of the finalizer, any time g.ctx is passed to cgo,
-	// that call must be followed by a call to runtime.KeepAlive(g),
-	// to make sure g is not collected (and finalized) before the cgo
-	// call returns.
-	runtime.SetFinalizer(g, (*aesGCM).finalize)
-	if g.NonceSize() != gcmStandardNonceSize {
-		panic("boringcrypto: internal confusion about nonce size")
-	}
-	if g.Overhead() != gcmTagSize {
-		panic("boringcrypto: internal confusion about tag size")
-	}
-
-	return g, nil
-}
-
-func (g *aesGCM) finalize() {
-	C._goboringcrypto_EVP_AEAD_CTX_cleanup(&g.ctx)
-}
-
-func (g *aesGCM) NonceSize() int {
-	return int(C._goboringcrypto_EVP_AEAD_nonce_length(g.aead))
-}
-
-func (g *aesGCM) Overhead() int {
-	return int(C._goboringcrypto_EVP_AEAD_max_overhead(g.aead))
-}
-
-// base returns the address of the underlying array in b,
-// being careful not to panic when b has zero length.
-func base(b []byte) *C.uint8_t {
-	if len(b) == 0 {
-		return nil
-	}
-	return (*C.uint8_t)(unsafe.Pointer(&b[0]))
-}
-
-func (g *aesGCM) Seal(dst, nonce, plaintext, additionalData []byte) []byte {
-	if len(nonce) != gcmStandardNonceSize {
-		panic("cipher: incorrect nonce length given to GCM")
-	}
-	if uint64(len(plaintext)) > ((1<<32)-2)*aesBlockSize || len(plaintext)+gcmTagSize < len(plaintext) {
-		panic("cipher: message too large for GCM")
-	}
-	if len(dst)+len(plaintext)+gcmTagSize < len(dst) {
-		panic("cipher: message too large for buffer")
-	}
-
-	// Make room in dst to append plaintext+overhead.
-	n := len(dst)
-	for cap(dst) < n+len(plaintext)+gcmTagSize {
-		dst = append(dst[:cap(dst)], 0)
-	}
-	dst = dst[:n+len(plaintext)+gcmTagSize]
-
-	// Check delayed until now to make sure len(dst) is accurate.
-	if inexactOverlap(dst[n:], plaintext) {
-		panic("cipher: invalid buffer overlap")
-	}
-
-	outLen := C.size_t(len(plaintext) + gcmTagSize)
-	ok := C.EVP_AEAD_CTX_seal_wrapper(
-		&g.ctx,
-		(*C.uint8_t)(unsafe.Pointer(&dst[n])), outLen,
-		base(nonce), C.size_t(len(nonce)),
-		base(plaintext), C.size_t(len(plaintext)),
-		base(additionalData), C.size_t(len(additionalData)))
-	runtime.KeepAlive(g)
-	if ok == 0 {
-		panic(fail("EVP_AEAD_CTX_seal"))
-	}
-	return dst[:n+int(outLen)]
-}
-
-var errOpen = errors.New("cipher: message authentication failed")
-
-func (g *aesGCM) Open(dst, nonce, ciphertext, additionalData []byte) ([]byte, error) {
-	if len(nonce) != gcmStandardNonceSize {
-		panic("cipher: incorrect nonce length given to GCM")
-	}
-	if len(ciphertext) < gcmTagSize {
-		return nil, errOpen
-	}
-	if uint64(len(ciphertext)) > ((1<<32)-2)*aesBlockSize+gcmTagSize {
-		return nil, errOpen
-	}
-
-	// Make room in dst to append ciphertext without tag.
-	n := len(dst)
-	for cap(dst) < n+len(ciphertext)-gcmTagSize {
-		dst = append(dst[:cap(dst)], 0)
-	}
-	dst = dst[:n+len(ciphertext)-gcmTagSize]
-
-	// Check delayed until now to make sure len(dst) is accurate.
-	if inexactOverlap(dst[n:], ciphertext) {
-		panic("cipher: invalid buffer overlap")
-	}
-
-	outLen := C.size_t(len(ciphertext) - gcmTagSize)
-	ok := C.EVP_AEAD_CTX_open_wrapper(
-		&g.ctx,
-		base(dst[n:]), outLen,
-		base(nonce), C.size_t(len(nonce)),
-		base(ciphertext), C.size_t(len(ciphertext)),
-		base(additionalData), C.size_t(len(additionalData)))
-	runtime.KeepAlive(g)
-	if ok == 0 {
-		return nil, errOpen
-	}
-	return dst[:n+int(outLen)], nil
-}
-
-func anyOverlap(x, y []byte) bool {
-	return len(x) > 0 && len(y) > 0 &&
-		uintptr(unsafe.Pointer(&x[0])) <= uintptr(unsafe.Pointer(&y[len(y)-1])) &&
-		uintptr(unsafe.Pointer(&y[0])) <= uintptr(unsafe.Pointer(&x[len(x)-1]))
-}
-
-func inexactOverlap(x, y []byte) bool {
-	if len(x) == 0 || len(y) == 0 || &x[0] == &y[0] {
-		return false
-	}
-	return anyOverlap(x, y)
-}
diff --git a/src/crypto/internal/boring/boring.go b/src/crypto/internal/boring/boring.go
deleted file mode 100644
index ded36a92f9..0000000000
--- a/src/crypto/internal/boring/boring.go
+++ /dev/null
@@ -1,126 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//go:build boringcrypto && linux && (amd64 || arm64) && !android && !msan
-
-package boring
-
-/*
-// goboringcrypto_linux_amd64.syso references pthread functions.
-#cgo LDFLAGS: "-pthread"
-
-#include "goboringcrypto.h"
-*/
-import "C"
-import (
-	"crypto/internal/boring/sig"
-	_ "crypto/internal/boring/syso"
-	"math/bits"
-	"unsafe"
-)
-
-const available = true
-
-func init() {
-	C._goboringcrypto_BORINGSSL_bcm_power_on_self_test()
-	if C._goboringcrypto_FIPS_mode() != 1 {
-		panic("boringcrypto: not in FIPS mode")
-	}
-	sig.BoringCrypto()
-}
-
-// Unreachable marks code that should be unreachable
-// when BoringCrypto is in use. It panics.
-func Unreachable() {
-	panic("boringcrypto: invalid code execution")
-}
-
-// provided by runtime to avoid os import.
-func runtime_arg0() string
-
-func hasSuffix(s, t string) bool {
-	return len(s) > len(t) && s[len(s)-len(t):] == t
-}
-
-// UnreachableExceptTests marks code that should be unreachable
-// when BoringCrypto is in use. It panics.
-func UnreachableExceptTests() {
-	name := runtime_arg0()
-	// If BoringCrypto ran on Windows we'd need to allow _test.exe and .test.exe as well.
-	if !hasSuffix(name, "_test") && !hasSuffix(name, ".test") {
-		println("boringcrypto: unexpected code execution in", name)
-		panic("boringcrypto: invalid code execution")
-	}
-}
-
-type fail string
-
-func (e fail) Error() string { return "boringcrypto: " + string(e) + " failed" }
-
-func wbase(b BigInt) *C.uint8_t {
-	if len(b) == 0 {
-		return nil
-	}
-	return (*C.uint8_t)(unsafe.Pointer(&b[0]))
-}
-
-const wordBytes = bits.UintSize / 8
-
-func bigToBN(x BigInt) *C.GO_BIGNUM {
-	return C._goboringcrypto_BN_le2bn(wbase(x), C.size_t(len(x)*wordBytes), nil)
-}
-
-func bytesToBN(x []byte) *C.GO_BIGNUM {
-	return C._goboringcrypto_BN_bin2bn((*C.uint8_t)(&x[0]), C.size_t(len(x)), nil)
-}
-
-func bnToBig(bn *C.GO_BIGNUM) BigInt {
-	x := make(BigInt, (C._goboringcrypto_BN_num_bytes(bn)+wordBytes-1)/wordBytes)
-	if C._goboringcrypto_BN_bn2le_padded(wbase(x), C.size_t(len(x)*wordBytes), bn) == 0 {
-		panic("boringcrypto: bignum conversion failed")
-	}
-	return x
-}
-
-func bigToBn(bnp **C.GO_BIGNUM, b BigInt) bool {
-	if *bnp != nil {
-		C._goboringcrypto_BN_free(*bnp)
-		*bnp = nil
-	}
-	if b == nil {
-		return true
-	}
-	bn := bigToBN(b)
-	if bn == nil {
-		return false
-	}
-	*bnp = bn
-	return true
-}
-
-// noescape hides a pointer from escape analysis.  noescape is
-// the identity function but escape analysis doesn't think the
-// output depends on the input.  noescape is inlined and currently
-// compiles down to zero instructions.
-// USE CAREFULLY!
-//
-//go:nosplit
-func noescape(p unsafe.Pointer) unsafe.Pointer {
-	x := uintptr(p)
-	return unsafe.Pointer(x ^ 0)
-}
-
-var zero byte
-
-// addr converts p to its base addr, including a noescape along the way.
-// If p is nil, addr returns a non-nil pointer, so that the result can always
-// be dereferenced.
-//
-//go:nosplit
-func addr(p []byte) *byte {
-	if len(p) == 0 {
-		return &zero
-	}
-	return (*byte)(noescape(unsafe.Pointer(&p[0])))
-}
diff --git a/src/crypto/internal/boring/boring_test.go b/src/crypto/internal/boring/boring_test.go
deleted file mode 100644
index 83bbbd3404..0000000000
--- a/src/crypto/internal/boring/boring_test.go
+++ /dev/null
@@ -1,34 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Most functionality in this package is tested by replacing existing code
-// and inheriting that code's tests.
-
-package boring
-
-import "testing"
-
-// Test that func init does not panic.
-func TestInit(t *testing.T) {}
-
-// Test that Unreachable panics.
-func TestUnreachable(t *testing.T) {
-	defer func() {
-		if Enabled {
-			if err := recover(); err == nil {
-				t.Fatal("expected Unreachable to panic")
-			}
-		} else {
-			if err := recover(); err != nil {
-				t.Fatalf("expected Unreachable to be a no-op")
-			}
-		}
-	}()
-	Unreachable()
-}
-
-// Test that UnreachableExceptTests does not panic (this is a test).
-func TestUnreachableExceptTests(t *testing.T) {
-	UnreachableExceptTests()
-}
diff --git a/src/crypto/internal/boring/doc.go b/src/crypto/internal/boring/doc.go
index 091e0d641e..ca24813149 100644
--- a/src/crypto/internal/boring/doc.go
+++ b/src/crypto/internal/boring/doc.go
@@ -7,13 +7,10 @@
 // If BoringCrypto is not available, the functions in this package all panic.
 package boring
 
-// Enabled reports whether BoringCrypto is available.
-// When enabled is false, all functions in this package panic.
-//
-// BoringCrypto is only available on linux/amd64 and linux/arm64 systems.
-const Enabled = available
+import "github.com/golang-fips/openssl/v2"
 
 // A BigInt is the raw words from a BigInt.
 // This definition allows us to avoid importing math/big.
 // Conversion between BigInt and *big.Int is in crypto/internal/boring/bbig.
-type BigInt []uint
+type BigInt = openssl.BigInt
+
diff --git a/src/crypto/internal/boring/ecdh.go b/src/crypto/internal/boring/ecdh.go
deleted file mode 100644
index 6a5d174c16..0000000000
--- a/src/crypto/internal/boring/ecdh.go
+++ /dev/null
@@ -1,224 +0,0 @@
-// Copyright 2022 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//go:build boringcrypto && linux && (amd64 || arm64) && !android && !msan
-
-package boring
-
-// #include "goboringcrypto.h"
-import "C"
-import (
-	"errors"
-	"runtime"
-	"unsafe"
-)
-
-type PublicKeyECDH struct {
-	curve string
-	key   *C.GO_EC_POINT
-	group *C.GO_EC_GROUP
-	bytes []byte
-}
-
-func (k *PublicKeyECDH) finalize() {
-	C._goboringcrypto_EC_POINT_free(k.key)
-}
-
-type PrivateKeyECDH struct {
-	curve string
-	key   *C.GO_EC_KEY
-}
-
-func (k *PrivateKeyECDH) finalize() {
-	C._goboringcrypto_EC_KEY_free(k.key)
-}
-
-func NewPublicKeyECDH(curve string, bytes []byte) (*PublicKeyECDH, error) {
-	if len(bytes) < 1 {
-		return nil, errors.New("NewPublicKeyECDH: missing key")
-	}
-
-	nid, err := curveNID(curve)
-	if err != nil {
-		return nil, err
-	}
-
-	group := C._goboringcrypto_EC_GROUP_new_by_curve_name(nid)
-	if group == nil {
-		return nil, fail("EC_GROUP_new_by_curve_name")
-	}
-	defer C._goboringcrypto_EC_GROUP_free(group)
-	key := C._goboringcrypto_EC_POINT_new(group)
-	if key == nil {
-		return nil, fail("EC_POINT_new")
-	}
-	ok := C._goboringcrypto_EC_POINT_oct2point(group, key, (*C.uint8_t)(unsafe.Pointer(&bytes[0])), C.size_t(len(bytes)), nil) != 0
-	if !ok {
-		C._goboringcrypto_EC_POINT_free(key)
-		return nil, errors.New("point not on curve")
-	}
-
-	k := &PublicKeyECDH{curve, key, group, append([]byte(nil), bytes...)}
-	// Note: Because of the finalizer, any time k.key is passed to cgo,
-	// that call must be followed by a call to runtime.KeepAlive(k),
-	// to make sure k is not collected (and finalized) before the cgo
-	// call returns.
-	runtime.SetFinalizer(k, (*PublicKeyECDH).finalize)
-	return k, nil
-}
-
-func (k *PublicKeyECDH) Bytes() []byte { return k.bytes }
-
-func NewPrivateKeyECDH(curve string, bytes []byte) (*PrivateKeyECDH, error) {
-	nid, err := curveNID(curve)
-	if err != nil {
-		return nil, err
-	}
-	key := C._goboringcrypto_EC_KEY_new_by_curve_name(nid)
-	if key == nil {
-		return nil, fail("EC_KEY_new_by_curve_name")
-	}
-	b := bytesToBN(bytes)
-	ok := b != nil && C._goboringcrypto_EC_KEY_set_private_key(key, b) != 0
-	if b != nil {
-		C._goboringcrypto_BN_free(b)
-	}
-	if !ok {
-		C._goboringcrypto_EC_KEY_free(key)
-		return nil, fail("EC_KEY_set_private_key")
-	}
-	k := &PrivateKeyECDH{curve, key}
-	// Note: Same as in NewPublicKeyECDH regarding finalizer and KeepAlive.
-	runtime.SetFinalizer(k, (*PrivateKeyECDH).finalize)
-	return k, nil
-}
-
-func (k *PrivateKeyECDH) PublicKey() (*PublicKeyECDH, error) {
-	defer runtime.KeepAlive(k)
-
-	group := C._goboringcrypto_EC_KEY_get0_group(k.key)
-	if group == nil {
-		return nil, fail("EC_KEY_get0_group")
-	}
-	kbig := C._goboringcrypto_EC_KEY_get0_private_key(k.key)
-	if kbig == nil {
-		return nil, fail("EC_KEY_get0_private_key")
-	}
-	pt := C._goboringcrypto_EC_POINT_new(group)
-	if pt == nil {
-		return nil, fail("EC_POINT_new")
-	}
-	if C._goboringcrypto_EC_POINT_mul(group, pt, kbig, nil, nil, nil) == 0 {
-		C._goboringcrypto_EC_POINT_free(pt)
-		return nil, fail("EC_POINT_mul")
-	}
-	bytes, err := pointBytesECDH(k.curve, group, pt)
-	if err != nil {
-		C._goboringcrypto_EC_POINT_free(pt)
-		return nil, err
-	}
-	pub := &PublicKeyECDH{k.curve, pt, group, bytes}
-	// Note: Same as in NewPublicKeyECDH regarding finalizer and KeepAlive.
-	runtime.SetFinalizer(pub, (*PublicKeyECDH).finalize)
-	return pub, nil
-}
-
-func pointBytesECDH(curve string, group *C.GO_EC_GROUP, pt *C.GO_EC_POINT) ([]byte, error) {
-	out := make([]byte, 1+2*curveSize(curve))
-	n := C._goboringcrypto_EC_POINT_point2oct(group, pt, C.GO_POINT_CONVERSION_UNCOMPRESSED, (*C.uint8_t)(unsafe.Pointer(&out[0])), C.size_t(len(out)), nil)
-	if int(n) != len(out) {
-		return nil, fail("EC_POINT_point2oct")
-	}
-	return out, nil
-}
-
-func ECDH(priv *PrivateKeyECDH, pub *PublicKeyECDH) ([]byte, error) {
-	group := C._goboringcrypto_EC_KEY_get0_group(priv.key)
-	if group == nil {
-		return nil, fail("EC_KEY_get0_group")
-	}
-	privBig := C._goboringcrypto_EC_KEY_get0_private_key(priv.key)
-	if privBig == nil {
-		return nil, fail("EC_KEY_get0_private_key")
-	}
-	pt := C._goboringcrypto_EC_POINT_new(group)
-	if pt == nil {
-		return nil, fail("EC_POINT_new")
-	}
-	defer C._goboringcrypto_EC_POINT_free(pt)
-	if C._goboringcrypto_EC_POINT_mul(group, pt, nil, pub.key, privBig, nil) == 0 {
-		return nil, fail("EC_POINT_mul")
-	}
-	out, err := xCoordBytesECDH(priv.curve, group, pt)
-	if err != nil {
-		return nil, err
-	}
-	return out, nil
-}
-
-func xCoordBytesECDH(curve string, group *C.GO_EC_GROUP, pt *C.GO_EC_POINT) ([]byte, error) {
-	big := C._goboringcrypto_BN_new()
-	defer C._goboringcrypto_BN_free(big)
-	if C._goboringcrypto_EC_POINT_get_affine_coordinates_GFp(group, pt, big, nil, nil) == 0 {
-		return nil, fail("EC_POINT_get_affine_coordinates_GFp")
-	}
-	return bigBytesECDH(curve, big)
-}
-
-func bigBytesECDH(curve string, big *C.GO_BIGNUM) ([]byte, error) {
-	out := make([]byte, curveSize(curve))
-	if C._goboringcrypto_BN_bn2bin_padded((*C.uint8_t)(&out[0]), C.size_t(len(out)), big) == 0 {
-		return nil, fail("BN_bn2bin_padded")
-	}
-	return out, nil
-}
-
-func curveSize(curve string) int {
-	switch curve {
-	default:
-		panic("crypto/internal/boring: unknown curve " + curve)
-	case "P-256":
-		return 256 / 8
-	case "P-384":
-		return 384 / 8
-	case "P-521":
-		return (521 + 7) / 8
-	}
-}
-
-func GenerateKeyECDH(curve string) (*PrivateKeyECDH, []byte, error) {
-	nid, err := curveNID(curve)
-	if err != nil {
-		return nil, nil, err
-	}
-	key := C._goboringcrypto_EC_KEY_new_by_curve_name(nid)
-	if key == nil {
-		return nil, nil, fail("EC_KEY_new_by_curve_name")
-	}
-	if C._goboringcrypto_EC_KEY_generate_key_fips(key) == 0 {
-		C._goboringcrypto_EC_KEY_free(key)
-		return nil, nil, fail("EC_KEY_generate_key_fips")
-	}
-
-	group := C._goboringcrypto_EC_KEY_get0_group(key)
-	if group == nil {
-		C._goboringcrypto_EC_KEY_free(key)
-		return nil, nil, fail("EC_KEY_get0_group")
-	}
-	b := C._goboringcrypto_EC_KEY_get0_private_key(key)
-	if b == nil {
-		C._goboringcrypto_EC_KEY_free(key)
-		return nil, nil, fail("EC_KEY_get0_private_key")
-	}
-	bytes, err := bigBytesECDH(curve, b)
-	if err != nil {
-		C._goboringcrypto_EC_KEY_free(key)
-		return nil, nil, err
-	}
-
-	k := &PrivateKeyECDH{curve, key}
-	// Note: Same as in NewPublicKeyECDH regarding finalizer and KeepAlive.
-	runtime.SetFinalizer(k, (*PrivateKeyECDH).finalize)
-	return k, bytes, nil
-}
diff --git a/src/crypto/internal/boring/ecdsa.go b/src/crypto/internal/boring/ecdsa.go
deleted file mode 100644
index 2adfdb2c9f..0000000000
--- a/src/crypto/internal/boring/ecdsa.go
+++ /dev/null
@@ -1,172 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//go:build boringcrypto && linux && (amd64 || arm64) && !android && !msan
-
-package boring
-
-// #include "goboringcrypto.h"
-import "C"
-import (
-	"errors"
-	"runtime"
-)
-
-type ecdsaSignature struct {
-	R, S BigInt
-}
-
-type PrivateKeyECDSA struct {
-	key *C.GO_EC_KEY
-}
-
-func (k *PrivateKeyECDSA) finalize() {
-	C._goboringcrypto_EC_KEY_free(k.key)
-}
-
-type PublicKeyECDSA struct {
-	key *C.GO_EC_KEY
-}
-
-func (k *PublicKeyECDSA) finalize() {
-	C._goboringcrypto_EC_KEY_free(k.key)
-}
-
-var errUnknownCurve = errors.New("boringcrypto: unknown elliptic curve")
-
-func curveNID(curve string) (C.int, error) {
-	switch curve {
-	case "P-224":
-		return C.GO_NID_secp224r1, nil
-	case "P-256":
-		return C.GO_NID_X9_62_prime256v1, nil
-	case "P-384":
-		return C.GO_NID_secp384r1, nil
-	case "P-521":
-		return C.GO_NID_secp521r1, nil
-	}
-	return 0, errUnknownCurve
-}
-
-func NewPublicKeyECDSA(curve string, X, Y BigInt) (*PublicKeyECDSA, error) {
-	key, err := newECKey(curve, X, Y)
-	if err != nil {
-		return nil, err
-	}
-	k := &PublicKeyECDSA{key}
-	// Note: Because of the finalizer, any time k.key is passed to cgo,
-	// that call must be followed by a call to runtime.KeepAlive(k),
-	// to make sure k is not collected (and finalized) before the cgo
-	// call returns.
-	runtime.SetFinalizer(k, (*PublicKeyECDSA).finalize)
-	return k, nil
-}
-
-func newECKey(curve string, X, Y BigInt) (*C.GO_EC_KEY, error) {
-	nid, err := curveNID(curve)
-	if err != nil {
-		return nil, err
-	}
-	key := C._goboringcrypto_EC_KEY_new_by_curve_name(nid)
-	if key == nil {
-		return nil, fail("EC_KEY_new_by_curve_name")
-	}
-	group := C._goboringcrypto_EC_KEY_get0_group(key)
-	pt := C._goboringcrypto_EC_POINT_new(group)
-	if pt == nil {
-		C._goboringcrypto_EC_KEY_free(key)
-		return nil, fail("EC_POINT_new")
-	}
-	bx := bigToBN(X)
-	by := bigToBN(Y)
-	ok := bx != nil && by != nil && C._goboringcrypto_EC_POINT_set_affine_coordinates_GFp(group, pt, bx, by, nil) != 0 &&
-		C._goboringcrypto_EC_KEY_set_public_key(key, pt) != 0
-	if bx != nil {
-		C._goboringcrypto_BN_free(bx)
-	}
-	if by != nil {
-		C._goboringcrypto_BN_free(by)
-	}
-	C._goboringcrypto_EC_POINT_free(pt)
-	if !ok {
-		C._goboringcrypto_EC_KEY_free(key)
-		return nil, fail("EC_POINT_set_affine_coordinates_GFp")
-	}
-	return key, nil
-}
-
-func NewPrivateKeyECDSA(curve string, X, Y BigInt, D BigInt) (*PrivateKeyECDSA, error) {
-	key, err := newECKey(curve, X, Y)
-	if err != nil {
-		return nil, err
-	}
-	bd := bigToBN(D)
-	ok := bd != nil && C._goboringcrypto_EC_KEY_set_private_key(key, bd) != 0
-	if bd != nil {
-		C._goboringcrypto_BN_free(bd)
-	}
-	if !ok {
-		C._goboringcrypto_EC_KEY_free(key)
-		return nil, fail("EC_KEY_set_private_key")
-	}
-	k := &PrivateKeyECDSA{key}
-	// Note: Because of the finalizer, any time k.key is passed to cgo,
-	// that call must be followed by a call to runtime.KeepAlive(k),
-	// to make sure k is not collected (and finalized) before the cgo
-	// call returns.
-	runtime.SetFinalizer(k, (*PrivateKeyECDSA).finalize)
-	return k, nil
-}
-
-func SignMarshalECDSA(priv *PrivateKeyECDSA, hash []byte) ([]byte, error) {
-	size := C._goboringcrypto_ECDSA_size(priv.key)
-	sig := make([]byte, size)
-	var sigLen C.uint
-	if C._goboringcrypto_ECDSA_sign(0, base(hash), C.size_t(len(hash)), base(sig), &sigLen, priv.key) == 0 {
-		return nil, fail("ECDSA_sign")
-	}
-	runtime.KeepAlive(priv)
-	return sig[:sigLen], nil
-}
-
-func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, sig []byte) bool {
-	ok := C._goboringcrypto_ECDSA_verify(0, base(hash), C.size_t(len(hash)), base(sig), C.size_t(len(sig)), pub.key) != 0
-	runtime.KeepAlive(pub)
-	return ok
-}
-
-func GenerateKeyECDSA(curve string) (X, Y, D BigInt, err error) {
-	nid, err := curveNID(curve)
-	if err != nil {
-		return nil, nil, nil, err
-	}
-	key := C._goboringcrypto_EC_KEY_new_by_curve_name(nid)
-	if key == nil {
-		return nil, nil, nil, fail("EC_KEY_new_by_curve_name")
-	}
-	defer C._goboringcrypto_EC_KEY_free(key)
-	if C._goboringcrypto_EC_KEY_generate_key_fips(key) == 0 {
-		return nil, nil, nil, fail("EC_KEY_generate_key_fips")
-	}
-	group := C._goboringcrypto_EC_KEY_get0_group(key)
-	pt := C._goboringcrypto_EC_KEY_get0_public_key(key)
-	bd := C._goboringcrypto_EC_KEY_get0_private_key(key)
-	if pt == nil || bd == nil {
-		return nil, nil, nil, fail("EC_KEY_get0_private_key")
-	}
-	bx := C._goboringcrypto_BN_new()
-	if bx == nil {
-		return nil, nil, nil, fail("BN_new")
-	}
-	defer C._goboringcrypto_BN_free(bx)
-	by := C._goboringcrypto_BN_new()
-	if by == nil {
-		return nil, nil, nil, fail("BN_new")
-	}
-	defer C._goboringcrypto_BN_free(by)
-	if C._goboringcrypto_EC_POINT_get_affine_coordinates_GFp(group, pt, bx, by, nil) == 0 {
-		return nil, nil, nil, fail("EC_POINT_get_affine_coordinates_GFp")
-	}
-	return bnToBig(bx), bnToBig(by), bnToBig(bd), nil
-}
diff --git a/src/crypto/internal/boring/fipstls/stub.s b/src/crypto/internal/boring/fipstls/stub.s
index f2e5a503ea..65918a480e 100644
--- a/src/crypto/internal/boring/fipstls/stub.s
+++ b/src/crypto/internal/boring/fipstls/stub.s
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build !no_openssl
 
 // runtime_arg0 is declared in tls.go without a body.
 // It's provided by package runtime,
diff --git a/src/crypto/internal/boring/fipstls/tls.go b/src/crypto/internal/boring/fipstls/tls.go
index 3bf1471fb0..d6c5ca736d 100644
--- a/src/crypto/internal/boring/fipstls/tls.go
+++ b/src/crypto/internal/boring/fipstls/tls.go
@@ -2,10 +2,10 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build !no_openssl
 
 // Package fipstls allows control over whether crypto/tls requires FIPS-approved settings.
-// This package only exists with GOEXPERIMENT=boringcrypto, but the effects are independent
+// This package only exists with GOEXPERIMENT=!no_openssl, but the effects are independent
 // of the use of BoringCrypto.
 package fipstls
 
diff --git a/src/crypto/internal/boring/hmac.go b/src/crypto/internal/boring/hmac.go
deleted file mode 100644
index ae926da695..0000000000
--- a/src/crypto/internal/boring/hmac.go
+++ /dev/null
@@ -1,153 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//go:build boringcrypto && linux && (amd64 || arm64) && !android && !msan
-
-package boring
-
-// #include "goboringcrypto.h"
-import "C"
-import (
-	"bytes"
-	"crypto"
-	"hash"
-	"runtime"
-	"unsafe"
-)
-
-// hashToMD converts a hash.Hash implementation from this package
-// to a BoringCrypto *C.GO_EVP_MD.
-func hashToMD(h hash.Hash) *C.GO_EVP_MD {
-	switch h.(type) {
-	case *sha1Hash:
-		return C._goboringcrypto_EVP_sha1()
-	case *sha224Hash:
-		return C._goboringcrypto_EVP_sha224()
-	case *sha256Hash:
-		return C._goboringcrypto_EVP_sha256()
-	case *sha384Hash:
-		return C._goboringcrypto_EVP_sha384()
-	case *sha512Hash:
-		return C._goboringcrypto_EVP_sha512()
-	}
-	return nil
-}
-
-// cryptoHashToMD converts a crypto.Hash
-// to a BoringCrypto *C.GO_EVP_MD.
-func cryptoHashToMD(ch crypto.Hash) *C.GO_EVP_MD {
-	switch ch {
-	case crypto.MD5:
-		return C._goboringcrypto_EVP_md5()
-	case crypto.MD5SHA1:
-		return C._goboringcrypto_EVP_md5_sha1()
-	case crypto.SHA1:
-		return C._goboringcrypto_EVP_sha1()
-	case crypto.SHA224:
-		return C._goboringcrypto_EVP_sha224()
-	case crypto.SHA256:
-		return C._goboringcrypto_EVP_sha256()
-	case crypto.SHA384:
-		return C._goboringcrypto_EVP_sha384()
-	case crypto.SHA512:
-		return C._goboringcrypto_EVP_sha512()
-	}
-	return nil
-}
-
-// NewHMAC returns a new HMAC using BoringCrypto.
-// The function h must return a hash implemented by
-// BoringCrypto (for example, h could be boring.NewSHA256).
-// If h is not recognized, NewHMAC returns nil.
-func NewHMAC(h func() hash.Hash, key []byte) hash.Hash {
-	ch := h()
-	md := hashToMD(ch)
-	if md == nil {
-		return nil
-	}
-
-	// Note: Could hash down long keys here using EVP_Digest.
-	hkey := bytes.Clone(key)
-	hmac := &boringHMAC{
-		md:        md,
-		size:      ch.Size(),
-		blockSize: ch.BlockSize(),
-		key:       hkey,
-	}
-	hmac.Reset()
-	return hmac
-}
-
-type boringHMAC struct {
-	md          *C.GO_EVP_MD
-	ctx         C.GO_HMAC_CTX
-	ctx2        C.GO_HMAC_CTX
-	size        int
-	blockSize   int
-	key         []byte
-	sum         []byte
-	needCleanup bool
-}
-
-func (h *boringHMAC) Reset() {
-	if h.needCleanup {
-		C._goboringcrypto_HMAC_CTX_cleanup(&h.ctx)
-	} else {
-		h.needCleanup = true
-		// Note: Because of the finalizer, any time h.ctx is passed to cgo,
-		// that call must be followed by a call to runtime.KeepAlive(h),
-		// to make sure h is not collected (and finalized) before the cgo
-		// call returns.
-		runtime.SetFinalizer(h, (*boringHMAC).finalize)
-	}
-	C._goboringcrypto_HMAC_CTX_init(&h.ctx)
-
-	if C._goboringcrypto_HMAC_Init(&h.ctx, unsafe.Pointer(base(h.key)), C.int(len(h.key)), h.md) == 0 {
-		panic("boringcrypto: HMAC_Init failed")
-	}
-	if int(C._goboringcrypto_HMAC_size(&h.ctx)) != h.size {
-		println("boringcrypto: HMAC size:", C._goboringcrypto_HMAC_size(&h.ctx), "!=", h.size)
-		panic("boringcrypto: HMAC size mismatch")
-	}
-	runtime.KeepAlive(h) // Next line will keep h alive too; just making doubly sure.
-	h.sum = nil
-}
-
-func (h *boringHMAC) finalize() {
-	C._goboringcrypto_HMAC_CTX_cleanup(&h.ctx)
-}
-
-func (h *boringHMAC) Write(p []byte) (int, error) {
-	if len(p) > 0 {
-		C._goboringcrypto_HMAC_Update(&h.ctx, (*C.uint8_t)(unsafe.Pointer(&p[0])), C.size_t(len(p)))
-	}
-	runtime.KeepAlive(h)
-	return len(p), nil
-}
-
-func (h *boringHMAC) Size() int {
-	return h.size
-}
-
-func (h *boringHMAC) BlockSize() int {
-	return h.blockSize
-}
-
-func (h *boringHMAC) Sum(in []byte) []byte {
-	if h.sum == nil {
-		size := h.Size()
-		h.sum = make([]byte, size)
-	}
-	// Make copy of context because Go hash.Hash mandates
-	// that Sum has no effect on the underlying stream.
-	// In particular it is OK to Sum, then Write more, then Sum again,
-	// and the second Sum acts as if the first didn't happen.
-	C._goboringcrypto_HMAC_CTX_init(&h.ctx2)
-	if C._goboringcrypto_HMAC_CTX_copy_ex(&h.ctx2, &h.ctx) == 0 {
-		panic("boringcrypto: HMAC_CTX_copy_ex failed")
-	}
-	C._goboringcrypto_HMAC_Final(&h.ctx2, (*C.uint8_t)(unsafe.Pointer(&h.sum[0])), nil)
-	C._goboringcrypto_HMAC_CTX_cleanup(&h.ctx2)
-	return append(in, h.sum...)
-}
diff --git a/src/crypto/internal/boring/notboring.go b/src/crypto/internal/boring/notboring.go
deleted file mode 100644
index 361dec9672..0000000000
--- a/src/crypto/internal/boring/notboring.go
+++ /dev/null
@@ -1,122 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//go:build !(boringcrypto && linux && (amd64 || arm64) && !android && !msan && cgo)
-
-package boring
-
-import (
-	"crypto"
-	"crypto/cipher"
-	"crypto/internal/boring/sig"
-	"hash"
-)
-
-const available = false
-
-// Unreachable marks code that should be unreachable
-// when BoringCrypto is in use. It is a no-op without BoringCrypto.
-func Unreachable() {
-	// Code that's unreachable when using BoringCrypto
-	// is exactly the code we want to detect for reporting
-	// standard Go crypto.
-	sig.StandardCrypto()
-}
-
-// UnreachableExceptTests marks code that should be unreachable
-// when BoringCrypto is in use. It is a no-op without BoringCrypto.
-func UnreachableExceptTests() {}
-
-type randReader int
-
-func (randReader) Read(b []byte) (int, error) { panic("boringcrypto: not available") }
-
-const RandReader = randReader(0)
-
-func NewSHA1() hash.Hash   { panic("boringcrypto: not available") }
-func NewSHA224() hash.Hash { panic("boringcrypto: not available") }
-func NewSHA256() hash.Hash { panic("boringcrypto: not available") }
-func NewSHA384() hash.Hash { panic("boringcrypto: not available") }
-func NewSHA512() hash.Hash { panic("boringcrypto: not available") }
-
-func SHA1([]byte) [20]byte   { panic("boringcrypto: not available") }
-func SHA224([]byte) [28]byte { panic("boringcrypto: not available") }
-func SHA256([]byte) [32]byte { panic("boringcrypto: not available") }
-func SHA384([]byte) [48]byte { panic("boringcrypto: not available") }
-func SHA512([]byte) [64]byte { panic("boringcrypto: not available") }
-
-func NewHMAC(h func() hash.Hash, key []byte) hash.Hash { panic("boringcrypto: not available") }
-
-func NewAESCipher(key []byte) (cipher.Block, error) { panic("boringcrypto: not available") }
-func NewGCMTLS(cipher.Block) (cipher.AEAD, error)   { panic("boringcrypto: not available") }
-
-type PublicKeyECDSA struct{ _ int }
-type PrivateKeyECDSA struct{ _ int }
-
-func GenerateKeyECDSA(curve string) (X, Y, D BigInt, err error) {
-	panic("boringcrypto: not available")
-}
-func NewPrivateKeyECDSA(curve string, X, Y, D BigInt) (*PrivateKeyECDSA, error) {
-	panic("boringcrypto: not available")
-}
-func NewPublicKeyECDSA(curve string, X, Y BigInt) (*PublicKeyECDSA, error) {
-	panic("boringcrypto: not available")
-}
-func SignMarshalECDSA(priv *PrivateKeyECDSA, hash []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, sig []byte) bool {
-	panic("boringcrypto: not available")
-}
-
-type PublicKeyRSA struct{ _ int }
-type PrivateKeyRSA struct{ _ int }
-
-func DecryptRSAOAEP(h, mgfHash hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func EncryptRSAOAEP(h, mgfHash hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
-	panic("boringcrypto: not available")
-}
-func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv BigInt) (*PrivateKeyRSA, error) {
-	panic("boringcrypto: not available")
-}
-func NewPublicKeyRSA(N, E BigInt) (*PublicKeyRSA, error) { panic("boringcrypto: not available") }
-func SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func VerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
-	panic("boringcrypto: not available")
-}
-func VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
-	panic("boringcrypto: not available")
-}
-
-type PublicKeyECDH struct{}
-type PrivateKeyECDH struct{}
-
-func ECDH(*PrivateKeyECDH, *PublicKeyECDH) ([]byte, error)      { panic("boringcrypto: not available") }
-func GenerateKeyECDH(string) (*PrivateKeyECDH, []byte, error)   { panic("boringcrypto: not available") }
-func NewPrivateKeyECDH(string, []byte) (*PrivateKeyECDH, error) { panic("boringcrypto: not available") }
-func NewPublicKeyECDH(string, []byte) (*PublicKeyECDH, error)   { panic("boringcrypto: not available") }
-func (*PublicKeyECDH) Bytes() []byte                            { panic("boringcrypto: not available") }
-func (*PrivateKeyECDH) PublicKey() (*PublicKeyECDH, error)      { panic("boringcrypto: not available") }
diff --git a/src/crypto/internal/boring/rand.go b/src/crypto/internal/boring/rand.go
deleted file mode 100644
index 556b98a112..0000000000
--- a/src/crypto/internal/boring/rand.go
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//go:build boringcrypto && linux && (amd64 || arm64) && !android && !msan
-
-package boring
-
-// #include "goboringcrypto.h"
-import "C"
-import "unsafe"
-
-type randReader int
-
-func (randReader) Read(b []byte) (int, error) {
-	// Note: RAND_bytes should never fail; the return value exists only for historical reasons.
-	// We check it even so.
-	if len(b) > 0 && C._goboringcrypto_RAND_bytes((*C.uint8_t)(unsafe.Pointer(&b[0])), C.size_t(len(b))) == 0 {
-		return 0, fail("RAND_bytes")
-	}
-	return len(b), nil
-}
-
-const RandReader = randReader(0)
diff --git a/src/crypto/internal/boring/rsa.go b/src/crypto/internal/boring/rsa.go
deleted file mode 100644
index e3baa44549..0000000000
--- a/src/crypto/internal/boring/rsa.go
+++ /dev/null
@@ -1,379 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//go:build boringcrypto && linux && (amd64 || arm64) && !android && !msan
-
-package boring
-
-// #include "goboringcrypto.h"
-import "C"
-import (
-	"crypto"
-	"crypto/subtle"
-	"errors"
-	"hash"
-	"runtime"
-	"strconv"
-	"unsafe"
-)
-
-func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
-	bad := func(e error) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
-		return nil, nil, nil, nil, nil, nil, nil, nil, e
-	}
-
-	key := C._goboringcrypto_RSA_new()
-	if key == nil {
-		return bad(fail("RSA_new"))
-	}
-	defer C._goboringcrypto_RSA_free(key)
-
-	if C._goboringcrypto_RSA_generate_key_fips(key, C.int(bits), nil) == 0 {
-		return bad(fail("RSA_generate_key_fips"))
-	}
-
-	var n, e, d, p, q, dp, dq, qinv *C.GO_BIGNUM
-	C._goboringcrypto_RSA_get0_key(key, &n, &e, &d)
-	C._goboringcrypto_RSA_get0_factors(key, &p, &q)
-	C._goboringcrypto_RSA_get0_crt_params(key, &dp, &dq, &qinv)
-	return bnToBig(n), bnToBig(e), bnToBig(d), bnToBig(p), bnToBig(q), bnToBig(dp), bnToBig(dq), bnToBig(qinv), nil
-}
-
-type PublicKeyRSA struct {
-	// _key MUST NOT be accessed directly. Instead, use the withKey method.
-	_key *C.GO_RSA
-}
-
-func NewPublicKeyRSA(N, E BigInt) (*PublicKeyRSA, error) {
-	key := C._goboringcrypto_RSA_new()
-	if key == nil {
-		return nil, fail("RSA_new")
-	}
-	if !bigToBn(&key.n, N) ||
-		!bigToBn(&key.e, E) {
-		return nil, fail("BN_bin2bn")
-	}
-	k := &PublicKeyRSA{_key: key}
-	runtime.SetFinalizer(k, (*PublicKeyRSA).finalize)
-	return k, nil
-}
-
-func (k *PublicKeyRSA) finalize() {
-	C._goboringcrypto_RSA_free(k._key)
-}
-
-func (k *PublicKeyRSA) withKey(f func(*C.GO_RSA) C.int) C.int {
-	// Because of the finalizer, any time _key is passed to cgo, that call must
-	// be followed by a call to runtime.KeepAlive, to make sure k is not
-	// collected (and finalized) before the cgo call returns.
-	defer runtime.KeepAlive(k)
-	return f(k._key)
-}
-
-type PrivateKeyRSA struct {
-	// _key MUST NOT be accessed directly. Instead, use the withKey method.
-	_key *C.GO_RSA
-}
-
-func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv BigInt) (*PrivateKeyRSA, error) {
-	key := C._goboringcrypto_RSA_new()
-	if key == nil {
-		return nil, fail("RSA_new")
-	}
-	if !bigToBn(&key.n, N) ||
-		!bigToBn(&key.e, E) ||
-		!bigToBn(&key.d, D) ||
-		!bigToBn(&key.p, P) ||
-		!bigToBn(&key.q, Q) ||
-		!bigToBn(&key.dmp1, Dp) ||
-		!bigToBn(&key.dmq1, Dq) ||
-		!bigToBn(&key.iqmp, Qinv) {
-		return nil, fail("BN_bin2bn")
-	}
-	k := &PrivateKeyRSA{_key: key}
-	runtime.SetFinalizer(k, (*PrivateKeyRSA).finalize)
-	return k, nil
-}
-
-func (k *PrivateKeyRSA) finalize() {
-	C._goboringcrypto_RSA_free(k._key)
-}
-
-func (k *PrivateKeyRSA) withKey(f func(*C.GO_RSA) C.int) C.int {
-	// Because of the finalizer, any time _key is passed to cgo, that call must
-	// be followed by a call to runtime.KeepAlive, to make sure k is not
-	// collected (and finalized) before the cgo call returns.
-	defer runtime.KeepAlive(k)
-	return f(k._key)
-}
-
-func setupRSA(withKey func(func(*C.GO_RSA) C.int) C.int,
-	padding C.int, h, mgfHash hash.Hash, label []byte, saltLen int, ch crypto.Hash,
-	init func(*C.GO_EVP_PKEY_CTX) C.int) (pkey *C.GO_EVP_PKEY, ctx *C.GO_EVP_PKEY_CTX, err error) {
-	defer func() {
-		if err != nil {
-			if pkey != nil {
-				C._goboringcrypto_EVP_PKEY_free(pkey)
-				pkey = nil
-			}
-			if ctx != nil {
-				C._goboringcrypto_EVP_PKEY_CTX_free(ctx)
-				ctx = nil
-			}
-		}
-	}()
-
-	pkey = C._goboringcrypto_EVP_PKEY_new()
-	if pkey == nil {
-		return nil, nil, fail("EVP_PKEY_new")
-	}
-	if withKey(func(key *C.GO_RSA) C.int {
-		return C._goboringcrypto_EVP_PKEY_set1_RSA(pkey, key)
-	}) == 0 {
-		return nil, nil, fail("EVP_PKEY_set1_RSA")
-	}
-	ctx = C._goboringcrypto_EVP_PKEY_CTX_new(pkey, nil)
-	if ctx == nil {
-		return nil, nil, fail("EVP_PKEY_CTX_new")
-	}
-	if init(ctx) == 0 {
-		return nil, nil, fail("EVP_PKEY_operation_init")
-	}
-	if C._goboringcrypto_EVP_PKEY_CTX_set_rsa_padding(ctx, padding) == 0 {
-		return nil, nil, fail("EVP_PKEY_CTX_set_rsa_padding")
-	}
-	if padding == C.GO_RSA_PKCS1_OAEP_PADDING {
-		md := hashToMD(h)
-		if md == nil {
-			return nil, nil, errors.New("crypto/rsa: unsupported hash function")
-		}
-		mgfMD := hashToMD(mgfHash)
-		if mgfMD == nil {
-			return nil, nil, errors.New("crypto/rsa: unsupported hash function")
-		}
-		if C._goboringcrypto_EVP_PKEY_CTX_set_rsa_oaep_md(ctx, md) == 0 {
-			return nil, nil, fail("EVP_PKEY_set_rsa_oaep_md")
-		}
-		if C._goboringcrypto_EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, mgfMD) == 0 {
-			return nil, nil, fail("EVP_PKEY_set_rsa_mgf1_md")
-		}
-		// ctx takes ownership of label, so malloc a copy for BoringCrypto to free.
-		clabel := (*C.uint8_t)(C._goboringcrypto_OPENSSL_malloc(C.size_t(len(label))))
-		if clabel == nil {
-			return nil, nil, fail("OPENSSL_malloc")
-		}
-		copy((*[1 << 30]byte)(unsafe.Pointer(clabel))[:len(label)], label)
-		if C._goboringcrypto_EVP_PKEY_CTX_set0_rsa_oaep_label(ctx, clabel, C.size_t(len(label))) == 0 {
-			return nil, nil, fail("EVP_PKEY_CTX_set0_rsa_oaep_label")
-		}
-	}
-	if padding == C.GO_RSA_PKCS1_PSS_PADDING {
-		if saltLen != 0 {
-			if C._goboringcrypto_EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, C.int(saltLen)) == 0 {
-				return nil, nil, fail("EVP_PKEY_set_rsa_pss_saltlen")
-			}
-		}
-		md := cryptoHashToMD(ch)
-		if md == nil {
-			return nil, nil, errors.New("crypto/rsa: unsupported hash function")
-		}
-		if C._goboringcrypto_EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, md) == 0 {
-			return nil, nil, fail("EVP_PKEY_set_rsa_mgf1_md")
-		}
-	}
-
-	return pkey, ctx, nil
-}
-
-func cryptRSA(withKey func(func(*C.GO_RSA) C.int) C.int,
-	padding C.int, h, mgfHash hash.Hash, label []byte, saltLen int, ch crypto.Hash,
-	init func(*C.GO_EVP_PKEY_CTX) C.int,
-	crypt func(*C.GO_EVP_PKEY_CTX, *C.uint8_t, *C.size_t, *C.uint8_t, C.size_t) C.int,
-	in []byte) ([]byte, error) {
-
-	pkey, ctx, err := setupRSA(withKey, padding, h, mgfHash, label, saltLen, ch, init)
-	if err != nil {
-		return nil, err
-	}
-	defer C._goboringcrypto_EVP_PKEY_free(pkey)
-	defer C._goboringcrypto_EVP_PKEY_CTX_free(ctx)
-
-	var outLen C.size_t
-	if crypt(ctx, nil, &outLen, base(in), C.size_t(len(in))) == 0 {
-		return nil, fail("EVP_PKEY_decrypt/encrypt")
-	}
-	out := make([]byte, outLen)
-	if crypt(ctx, base(out), &outLen, base(in), C.size_t(len(in))) == 0 {
-		return nil, fail("EVP_PKEY_decrypt/encrypt")
-	}
-	return out[:outLen], nil
-}
-
-func DecryptRSAOAEP(h, mgfHash hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
-	return cryptRSA(priv.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, mgfHash, label, 0, 0, decryptInit, decrypt, ciphertext)
-}
-
-func EncryptRSAOAEP(h, mgfHash hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
-	return cryptRSA(pub.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, mgfHash, label, 0, 0, encryptInit, encrypt, msg)
-}
-
-func DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
-	return cryptRSA(priv.withKey, C.GO_RSA_PKCS1_PADDING, nil, nil, nil, 0, 0, decryptInit, decrypt, ciphertext)
-}
-
-func EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
-	return cryptRSA(pub.withKey, C.GO_RSA_PKCS1_PADDING, nil, nil, nil, 0, 0, encryptInit, encrypt, msg)
-}
-
-func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
-	return cryptRSA(priv.withKey, C.GO_RSA_NO_PADDING, nil, nil, nil, 0, 0, decryptInit, decrypt, ciphertext)
-}
-
-func EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
-	return cryptRSA(pub.withKey, C.GO_RSA_NO_PADDING, nil, nil, nil, 0, 0, encryptInit, encrypt, msg)
-}
-
-// These dumb wrappers work around the fact that cgo functions cannot be used as values directly.
-
-func decryptInit(ctx *C.GO_EVP_PKEY_CTX) C.int {
-	return C._goboringcrypto_EVP_PKEY_decrypt_init(ctx)
-}
-
-func decrypt(ctx *C.GO_EVP_PKEY_CTX, out *C.uint8_t, outLen *C.size_t, in *C.uint8_t, inLen C.size_t) C.int {
-	return C._goboringcrypto_EVP_PKEY_decrypt(ctx, out, outLen, in, inLen)
-}
-
-func encryptInit(ctx *C.GO_EVP_PKEY_CTX) C.int {
-	return C._goboringcrypto_EVP_PKEY_encrypt_init(ctx)
-}
-
-func encrypt(ctx *C.GO_EVP_PKEY_CTX, out *C.uint8_t, outLen *C.size_t, in *C.uint8_t, inLen C.size_t) C.int {
-	return C._goboringcrypto_EVP_PKEY_encrypt(ctx, out, outLen, in, inLen)
-}
-
-var invalidSaltLenErr = errors.New("crypto/rsa: PSSOptions.SaltLength cannot be negative")
-
-func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
-	md := cryptoHashToMD(h)
-	if md == nil {
-		return nil, errors.New("crypto/rsa: unsupported hash function")
-	}
-
-	// A salt length of -2 is valid in BoringSSL, but not in crypto/rsa, so reject
-	// it, and lengths < -2, before we convert to the BoringSSL sentinel values.
-	if saltLen <= -2 {
-		return nil, invalidSaltLenErr
-	}
-
-	// BoringSSL uses sentinel salt length values like we do, but the values don't
-	// fully match what we use. We both use -1 for salt length equal to hash length,
-	// but BoringSSL uses -2 to mean maximal size where we use 0. In the latter
-	// case convert to the BoringSSL version.
-	if saltLen == 0 {
-		saltLen = -2
-	}
-
-	var out []byte
-	var outLen C.size_t
-	if priv.withKey(func(key *C.GO_RSA) C.int {
-		out = make([]byte, C._goboringcrypto_RSA_size(key))
-		return C._goboringcrypto_RSA_sign_pss_mgf1(key, &outLen, base(out), C.size_t(len(out)),
-			base(hashed), C.size_t(len(hashed)), md, nil, C.int(saltLen))
-	}) == 0 {
-		return nil, fail("RSA_sign_pss_mgf1")
-	}
-
-	return out[:outLen], nil
-}
-
-func VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
-	md := cryptoHashToMD(h)
-	if md == nil {
-		return errors.New("crypto/rsa: unsupported hash function")
-	}
-
-	// A salt length of -2 is valid in BoringSSL, but not in crypto/rsa, so reject
-	// it, and lengths < -2, before we convert to the BoringSSL sentinel values.
-	if saltLen <= -2 {
-		return invalidSaltLenErr
-	}
-
-	// BoringSSL uses sentinel salt length values like we do, but the values don't
-	// fully match what we use. We both use -1 for salt length equal to hash length,
-	// but BoringSSL uses -2 to mean maximal size where we use 0. In the latter
-	// case convert to the BoringSSL version.
-	if saltLen == 0 {
-		saltLen = -2
-	}
-
-	if pub.withKey(func(key *C.GO_RSA) C.int {
-		return C._goboringcrypto_RSA_verify_pss_mgf1(key, base(hashed), C.size_t(len(hashed)),
-			md, nil, C.int(saltLen), base(sig), C.size_t(len(sig)))
-	}) == 0 {
-		return fail("RSA_verify_pss_mgf1")
-	}
-	return nil
-}
-
-func SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
-	if h == 0 {
-		// No hashing.
-		var out []byte
-		var outLen C.size_t
-		if priv.withKey(func(key *C.GO_RSA) C.int {
-			out = make([]byte, C._goboringcrypto_RSA_size(key))
-			return C._goboringcrypto_RSA_sign_raw(key, &outLen, base(out), C.size_t(len(out)),
-				base(hashed), C.size_t(len(hashed)), C.GO_RSA_PKCS1_PADDING)
-		}) == 0 {
-			return nil, fail("RSA_sign_raw")
-		}
-		return out[:outLen], nil
-	}
-
-	md := cryptoHashToMD(h)
-	if md == nil {
-		return nil, errors.New("crypto/rsa: unsupported hash function: " + strconv.Itoa(int(h)))
-	}
-	nid := C._goboringcrypto_EVP_MD_type(md)
-	var out []byte
-	var outLen C.uint
-	if priv.withKey(func(key *C.GO_RSA) C.int {
-		out = make([]byte, C._goboringcrypto_RSA_size(key))
-		return C._goboringcrypto_RSA_sign(nid, base(hashed), C.uint(len(hashed)),
-			base(out), &outLen, key)
-	}) == 0 {
-		return nil, fail("RSA_sign")
-	}
-	return out[:outLen], nil
-}
-
-func VerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
-	if h == 0 {
-		var out []byte
-		var outLen C.size_t
-		if pub.withKey(func(key *C.GO_RSA) C.int {
-			out = make([]byte, C._goboringcrypto_RSA_size(key))
-			return C._goboringcrypto_RSA_verify_raw(key, &outLen, base(out),
-				C.size_t(len(out)), base(sig), C.size_t(len(sig)), C.GO_RSA_PKCS1_PADDING)
-		}) == 0 {
-			return fail("RSA_verify")
-		}
-		if subtle.ConstantTimeCompare(hashed, out[:outLen]) != 1 {
-			return fail("RSA_verify")
-		}
-		return nil
-	}
-	md := cryptoHashToMD(h)
-	if md == nil {
-		return errors.New("crypto/rsa: unsupported hash function")
-	}
-	nid := C._goboringcrypto_EVP_MD_type(md)
-	if pub.withKey(func(key *C.GO_RSA) C.int {
-		return C._goboringcrypto_RSA_verify(nid, base(hashed), C.size_t(len(hashed)),
-			base(sig), C.size_t(len(sig)), key)
-	}) == 0 {
-		return fail("RSA_verify")
-	}
-	return nil
-}
diff --git a/src/crypto/internal/boring/sha.go b/src/crypto/internal/boring/sha.go
deleted file mode 100644
index a49c119738..0000000000
--- a/src/crypto/internal/boring/sha.go
+++ /dev/null
@@ -1,599 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//go:build boringcrypto && linux && (amd64 || arm64) && !android && !msan
-
-package boring
-
-/*
-#include "goboringcrypto.h"
-
-int
-_goboringcrypto_gosha1(void *p, size_t n, void *out)
-{
-	GO_SHA_CTX ctx;
-	_goboringcrypto_SHA1_Init(&ctx);
-	return _goboringcrypto_SHA1_Update(&ctx, p, n) &&
-		_goboringcrypto_SHA1_Final(out, &ctx);
-}
-
-int
-_goboringcrypto_gosha224(void *p, size_t n, void *out)
-{
-	GO_SHA256_CTX ctx;
-	_goboringcrypto_SHA224_Init(&ctx);
-	return _goboringcrypto_SHA224_Update(&ctx, p, n) &&
-		_goboringcrypto_SHA224_Final(out, &ctx);
-}
-
-int
-_goboringcrypto_gosha256(void *p, size_t n, void *out)
-{
-	GO_SHA256_CTX ctx;
-	_goboringcrypto_SHA256_Init(&ctx);
-	return _goboringcrypto_SHA256_Update(&ctx, p, n) &&
-		_goboringcrypto_SHA256_Final(out, &ctx);
-}
-
-int
-_goboringcrypto_gosha384(void *p, size_t n, void *out)
-{
-	GO_SHA512_CTX ctx;
-	_goboringcrypto_SHA384_Init(&ctx);
-	return _goboringcrypto_SHA384_Update(&ctx, p, n) &&
-		_goboringcrypto_SHA384_Final(out, &ctx);
-}
-
-int
-_goboringcrypto_gosha512(void *p, size_t n, void *out)
-{
-	GO_SHA512_CTX ctx;
-	_goboringcrypto_SHA512_Init(&ctx);
-	return _goboringcrypto_SHA512_Update(&ctx, p, n) &&
-		_goboringcrypto_SHA512_Final(out, &ctx);
-}
-
-*/
-import "C"
-import (
-	"errors"
-	"hash"
-	"unsafe"
-)
-
-// NOTE: The cgo calls in this file are arranged to avoid marking the parameters as escaping.
-// To do that, we call noescape (including via addr).
-// We must also make sure that the data pointer arguments have the form unsafe.Pointer(&...)
-// so that cgo does not annotate them with cgoCheckPointer calls. If it did that, it might look
-// beyond the byte slice and find Go pointers in unprocessed parts of a larger allocation.
-// To do both of these simultaneously, the idiom is unsafe.Pointer(&*addr(p)),
-// where addr returns the base pointer of p, substituting a non-nil pointer for nil,
-// and applying a noescape along the way.
-// This is all to preserve compatibility with the allocation behavior of the non-boring implementations.
-
-func SHA1(p []byte) (sum [20]byte) {
-	if C._goboringcrypto_gosha1(unsafe.Pointer(&*addr(p)), C.size_t(len(p)), unsafe.Pointer(&*addr(sum[:]))) == 0 {
-		panic("boringcrypto: SHA1 failed")
-	}
-	return
-}
-
-func SHA224(p []byte) (sum [28]byte) {
-	if C._goboringcrypto_gosha224(unsafe.Pointer(&*addr(p)), C.size_t(len(p)), unsafe.Pointer(&*addr(sum[:]))) == 0 {
-		panic("boringcrypto: SHA224 failed")
-	}
-	return
-}
-
-func SHA256(p []byte) (sum [32]byte) {
-	if C._goboringcrypto_gosha256(unsafe.Pointer(&*addr(p)), C.size_t(len(p)), unsafe.Pointer(&*addr(sum[:]))) == 0 {
-		panic("boringcrypto: SHA256 failed")
-	}
-	return
-}
-
-func SHA384(p []byte) (sum [48]byte) {
-	if C._goboringcrypto_gosha384(unsafe.Pointer(&*addr(p)), C.size_t(len(p)), unsafe.Pointer(&*addr(sum[:]))) == 0 {
-		panic("boringcrypto: SHA384 failed")
-	}
-	return
-}
-
-func SHA512(p []byte) (sum [64]byte) {
-	if C._goboringcrypto_gosha512(unsafe.Pointer(&*addr(p)), C.size_t(len(p)), unsafe.Pointer(&*addr(sum[:]))) == 0 {
-		panic("boringcrypto: SHA512 failed")
-	}
-	return
-}
-
-// NewSHA1 returns a new SHA1 hash.
-func NewSHA1() hash.Hash {
-	h := new(sha1Hash)
-	h.Reset()
-	return h
-}
-
-type sha1Hash struct {
-	ctx C.GO_SHA_CTX
-	out [20]byte
-}
-
-type sha1Ctx struct {
-	h      [5]uint32
-	nl, nh uint32
-	x      [64]byte
-	nx     uint32
-}
-
-func (h *sha1Hash) noescapeCtx() *C.GO_SHA_CTX {
-	return (*C.GO_SHA_CTX)(noescape(unsafe.Pointer(&h.ctx)))
-}
-
-func (h *sha1Hash) Reset() {
-	C._goboringcrypto_SHA1_Init(h.noescapeCtx())
-}
-
-func (h *sha1Hash) Size() int             { return 20 }
-func (h *sha1Hash) BlockSize() int        { return 64 }
-func (h *sha1Hash) Sum(dst []byte) []byte { return h.sum(dst) }
-
-func (h *sha1Hash) Write(p []byte) (int, error) {
-	if len(p) > 0 && C._goboringcrypto_SHA1_Update(h.noescapeCtx(), unsafe.Pointer(&*addr(p)), C.size_t(len(p))) == 0 {
-		panic("boringcrypto: SHA1_Update failed")
-	}
-	return len(p), nil
-}
-
-func (h0 *sha1Hash) sum(dst []byte) []byte {
-	h := *h0 // make copy so future Write+Sum is valid
-	if C._goboringcrypto_SHA1_Final((*C.uint8_t)(noescape(unsafe.Pointer(&h.out[0]))), h.noescapeCtx()) == 0 {
-		panic("boringcrypto: SHA1_Final failed")
-	}
-	return append(dst, h.out[:]...)
-}
-
-const (
-	sha1Magic         = "sha\x01"
-	sha1MarshaledSize = len(sha1Magic) + 5*4 + 64 + 8
-)
-
-func (h *sha1Hash) MarshalBinary() ([]byte, error) {
-	d := (*sha1Ctx)(unsafe.Pointer(&h.ctx))
-	b := make([]byte, 0, sha1MarshaledSize)
-	b = append(b, sha1Magic...)
-	b = appendUint32(b, d.h[0])
-	b = appendUint32(b, d.h[1])
-	b = appendUint32(b, d.h[2])
-	b = appendUint32(b, d.h[3])
-	b = appendUint32(b, d.h[4])
-	b = append(b, d.x[:d.nx]...)
-	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
-	b = appendUint64(b, uint64(d.nl)>>3|uint64(d.nh)<<29)
-	return b, nil
-}
-
-func (h *sha1Hash) UnmarshalBinary(b []byte) error {
-	if len(b) < len(sha1Magic) || string(b[:len(sha1Magic)]) != sha1Magic {
-		return errors.New("crypto/sha1: invalid hash state identifier")
-	}
-	if len(b) != sha1MarshaledSize {
-		return errors.New("crypto/sha1: invalid hash state size")
-	}
-	d := (*sha1Ctx)(unsafe.Pointer(&h.ctx))
-	b = b[len(sha1Magic):]
-	b, d.h[0] = consumeUint32(b)
-	b, d.h[1] = consumeUint32(b)
-	b, d.h[2] = consumeUint32(b)
-	b, d.h[3] = consumeUint32(b)
-	b, d.h[4] = consumeUint32(b)
-	b = b[copy(d.x[:], b):]
-	b, n := consumeUint64(b)
-	d.nl = uint32(n << 3)
-	d.nh = uint32(n >> 29)
-	d.nx = uint32(n) % 64
-	return nil
-}
-
-// NewSHA224 returns a new SHA224 hash.
-func NewSHA224() hash.Hash {
-	h := new(sha224Hash)
-	h.Reset()
-	return h
-}
-
-type sha224Hash struct {
-	ctx C.GO_SHA256_CTX
-	out [224 / 8]byte
-}
-
-func (h *sha224Hash) noescapeCtx() *C.GO_SHA256_CTX {
-	return (*C.GO_SHA256_CTX)(noescape(unsafe.Pointer(&h.ctx)))
-}
-
-func (h *sha224Hash) Reset() {
-	C._goboringcrypto_SHA224_Init(h.noescapeCtx())
-}
-func (h *sha224Hash) Size() int             { return 224 / 8 }
-func (h *sha224Hash) BlockSize() int        { return 64 }
-func (h *sha224Hash) Sum(dst []byte) []byte { return h.sum(dst) }
-
-func (h *sha224Hash) Write(p []byte) (int, error) {
-	if len(p) > 0 && C._goboringcrypto_SHA224_Update(h.noescapeCtx(), unsafe.Pointer(&*addr(p)), C.size_t(len(p))) == 0 {
-		panic("boringcrypto: SHA224_Update failed")
-	}
-	return len(p), nil
-}
-
-func (h0 *sha224Hash) sum(dst []byte) []byte {
-	h := *h0 // make copy so future Write+Sum is valid
-	if C._goboringcrypto_SHA224_Final((*C.uint8_t)(noescape(unsafe.Pointer(&h.out[0]))), h.noescapeCtx()) == 0 {
-		panic("boringcrypto: SHA224_Final failed")
-	}
-	return append(dst, h.out[:]...)
-}
-
-// NewSHA256 returns a new SHA256 hash.
-func NewSHA256() hash.Hash {
-	h := new(sha256Hash)
-	h.Reset()
-	return h
-}
-
-type sha256Hash struct {
-	ctx C.GO_SHA256_CTX
-	out [256 / 8]byte
-}
-
-func (h *sha256Hash) noescapeCtx() *C.GO_SHA256_CTX {
-	return (*C.GO_SHA256_CTX)(noescape(unsafe.Pointer(&h.ctx)))
-}
-
-func (h *sha256Hash) Reset() {
-	C._goboringcrypto_SHA256_Init(h.noescapeCtx())
-}
-func (h *sha256Hash) Size() int             { return 256 / 8 }
-func (h *sha256Hash) BlockSize() int        { return 64 }
-func (h *sha256Hash) Sum(dst []byte) []byte { return h.sum(dst) }
-
-func (h *sha256Hash) Write(p []byte) (int, error) {
-	if len(p) > 0 && C._goboringcrypto_SHA256_Update(h.noescapeCtx(), unsafe.Pointer(&*addr(p)), C.size_t(len(p))) == 0 {
-		panic("boringcrypto: SHA256_Update failed")
-	}
-	return len(p), nil
-}
-
-func (h0 *sha256Hash) sum(dst []byte) []byte {
-	h := *h0 // make copy so future Write+Sum is valid
-	if C._goboringcrypto_SHA256_Final((*C.uint8_t)(noescape(unsafe.Pointer(&h.out[0]))), h.noescapeCtx()) == 0 {
-		panic("boringcrypto: SHA256_Final failed")
-	}
-	return append(dst, h.out[:]...)
-}
-
-const (
-	magic224         = "sha\x02"
-	magic256         = "sha\x03"
-	marshaledSize256 = len(magic256) + 8*4 + 64 + 8
-)
-
-type sha256Ctx struct {
-	h      [8]uint32
-	nl, nh uint32
-	x      [64]byte
-	nx     uint32
-}
-
-func (h *sha224Hash) MarshalBinary() ([]byte, error) {
-	d := (*sha256Ctx)(unsafe.Pointer(&h.ctx))
-	b := make([]byte, 0, marshaledSize256)
-	b = append(b, magic224...)
-	b = appendUint32(b, d.h[0])
-	b = appendUint32(b, d.h[1])
-	b = appendUint32(b, d.h[2])
-	b = appendUint32(b, d.h[3])
-	b = appendUint32(b, d.h[4])
-	b = appendUint32(b, d.h[5])
-	b = appendUint32(b, d.h[6])
-	b = appendUint32(b, d.h[7])
-	b = append(b, d.x[:d.nx]...)
-	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
-	b = appendUint64(b, uint64(d.nl)>>3|uint64(d.nh)<<29)
-	return b, nil
-}
-
-func (h *sha256Hash) MarshalBinary() ([]byte, error) {
-	d := (*sha256Ctx)(unsafe.Pointer(&h.ctx))
-	b := make([]byte, 0, marshaledSize256)
-	b = append(b, magic256...)
-	b = appendUint32(b, d.h[0])
-	b = appendUint32(b, d.h[1])
-	b = appendUint32(b, d.h[2])
-	b = appendUint32(b, d.h[3])
-	b = appendUint32(b, d.h[4])
-	b = appendUint32(b, d.h[5])
-	b = appendUint32(b, d.h[6])
-	b = appendUint32(b, d.h[7])
-	b = append(b, d.x[:d.nx]...)
-	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
-	b = appendUint64(b, uint64(d.nl)>>3|uint64(d.nh)<<29)
-	return b, nil
-}
-
-func (h *sha224Hash) UnmarshalBinary(b []byte) error {
-	if len(b) < len(magic224) || string(b[:len(magic224)]) != magic224 {
-		return errors.New("crypto/sha256: invalid hash state identifier")
-	}
-	if len(b) != marshaledSize256 {
-		return errors.New("crypto/sha256: invalid hash state size")
-	}
-	d := (*sha256Ctx)(unsafe.Pointer(&h.ctx))
-	b = b[len(magic224):]
-	b, d.h[0] = consumeUint32(b)
-	b, d.h[1] = consumeUint32(b)
-	b, d.h[2] = consumeUint32(b)
-	b, d.h[3] = consumeUint32(b)
-	b, d.h[4] = consumeUint32(b)
-	b, d.h[5] = consumeUint32(b)
-	b, d.h[6] = consumeUint32(b)
-	b, d.h[7] = consumeUint32(b)
-	b = b[copy(d.x[:], b):]
-	b, n := consumeUint64(b)
-	d.nl = uint32(n << 3)
-	d.nh = uint32(n >> 29)
-	d.nx = uint32(n) % 64
-	return nil
-}
-
-func (h *sha256Hash) UnmarshalBinary(b []byte) error {
-	if len(b) < len(magic256) || string(b[:len(magic256)]) != magic256 {
-		return errors.New("crypto/sha256: invalid hash state identifier")
-	}
-	if len(b) != marshaledSize256 {
-		return errors.New("crypto/sha256: invalid hash state size")
-	}
-	d := (*sha256Ctx)(unsafe.Pointer(&h.ctx))
-	b = b[len(magic256):]
-	b, d.h[0] = consumeUint32(b)
-	b, d.h[1] = consumeUint32(b)
-	b, d.h[2] = consumeUint32(b)
-	b, d.h[3] = consumeUint32(b)
-	b, d.h[4] = consumeUint32(b)
-	b, d.h[5] = consumeUint32(b)
-	b, d.h[6] = consumeUint32(b)
-	b, d.h[7] = consumeUint32(b)
-	b = b[copy(d.x[:], b):]
-	b, n := consumeUint64(b)
-	d.nl = uint32(n << 3)
-	d.nh = uint32(n >> 29)
-	d.nx = uint32(n) % 64
-	return nil
-}
-
-// NewSHA384 returns a new SHA384 hash.
-func NewSHA384() hash.Hash {
-	h := new(sha384Hash)
-	h.Reset()
-	return h
-}
-
-type sha384Hash struct {
-	ctx C.GO_SHA512_CTX
-	out [384 / 8]byte
-}
-
-func (h *sha384Hash) noescapeCtx() *C.GO_SHA512_CTX {
-	return (*C.GO_SHA512_CTX)(noescape(unsafe.Pointer(&h.ctx)))
-}
-
-func (h *sha384Hash) Reset() {
-	C._goboringcrypto_SHA384_Init(h.noescapeCtx())
-}
-func (h *sha384Hash) Size() int             { return 384 / 8 }
-func (h *sha384Hash) BlockSize() int        { return 128 }
-func (h *sha384Hash) Sum(dst []byte) []byte { return h.sum(dst) }
-
-func (h *sha384Hash) Write(p []byte) (int, error) {
-	if len(p) > 0 && C._goboringcrypto_SHA384_Update(h.noescapeCtx(), unsafe.Pointer(&*addr(p)), C.size_t(len(p))) == 0 {
-		panic("boringcrypto: SHA384_Update failed")
-	}
-	return len(p), nil
-}
-
-func (h0 *sha384Hash) sum(dst []byte) []byte {
-	h := *h0 // make copy so future Write+Sum is valid
-	if C._goboringcrypto_SHA384_Final((*C.uint8_t)(noescape(unsafe.Pointer(&h.out[0]))), h.noescapeCtx()) == 0 {
-		panic("boringcrypto: SHA384_Final failed")
-	}
-	return append(dst, h.out[:]...)
-}
-
-// NewSHA512 returns a new SHA512 hash.
-func NewSHA512() hash.Hash {
-	h := new(sha512Hash)
-	h.Reset()
-	return h
-}
-
-type sha512Hash struct {
-	ctx C.GO_SHA512_CTX
-	out [512 / 8]byte
-}
-
-func (h *sha512Hash) noescapeCtx() *C.GO_SHA512_CTX {
-	return (*C.GO_SHA512_CTX)(noescape(unsafe.Pointer(&h.ctx)))
-}
-
-func (h *sha512Hash) Reset() {
-	C._goboringcrypto_SHA512_Init(h.noescapeCtx())
-}
-func (h *sha512Hash) Size() int             { return 512 / 8 }
-func (h *sha512Hash) BlockSize() int        { return 128 }
-func (h *sha512Hash) Sum(dst []byte) []byte { return h.sum(dst) }
-
-func (h *sha512Hash) Write(p []byte) (int, error) {
-	if len(p) > 0 && C._goboringcrypto_SHA512_Update(h.noescapeCtx(), unsafe.Pointer(&*addr(p)), C.size_t(len(p))) == 0 {
-		panic("boringcrypto: SHA512_Update failed")
-	}
-	return len(p), nil
-}
-
-func (h0 *sha512Hash) sum(dst []byte) []byte {
-	h := *h0 // make copy so future Write+Sum is valid
-	if C._goboringcrypto_SHA512_Final((*C.uint8_t)(noescape(unsafe.Pointer(&h.out[0]))), h.noescapeCtx()) == 0 {
-		panic("boringcrypto: SHA512_Final failed")
-	}
-	return append(dst, h.out[:]...)
-}
-
-type sha512Ctx struct {
-	h      [8]uint64
-	nl, nh uint64
-	x      [128]byte
-	nx     uint32
-}
-
-const (
-	magic384         = "sha\x04"
-	magic512_224     = "sha\x05"
-	magic512_256     = "sha\x06"
-	magic512         = "sha\x07"
-	marshaledSize512 = len(magic512) + 8*8 + 128 + 8
-)
-
-func (h *sha384Hash) MarshalBinary() ([]byte, error) {
-	d := (*sha512Ctx)(unsafe.Pointer(&h.ctx))
-	b := make([]byte, 0, marshaledSize512)
-	b = append(b, magic384...)
-	b = appendUint64(b, d.h[0])
-	b = appendUint64(b, d.h[1])
-	b = appendUint64(b, d.h[2])
-	b = appendUint64(b, d.h[3])
-	b = appendUint64(b, d.h[4])
-	b = appendUint64(b, d.h[5])
-	b = appendUint64(b, d.h[6])
-	b = appendUint64(b, d.h[7])
-	b = append(b, d.x[:d.nx]...)
-	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
-	b = appendUint64(b, d.nl>>3|d.nh<<61)
-	return b, nil
-}
-
-func (h *sha512Hash) MarshalBinary() ([]byte, error) {
-	d := (*sha512Ctx)(unsafe.Pointer(&h.ctx))
-	b := make([]byte, 0, marshaledSize512)
-	b = append(b, magic512...)
-	b = appendUint64(b, d.h[0])
-	b = appendUint64(b, d.h[1])
-	b = appendUint64(b, d.h[2])
-	b = appendUint64(b, d.h[3])
-	b = appendUint64(b, d.h[4])
-	b = appendUint64(b, d.h[5])
-	b = appendUint64(b, d.h[6])
-	b = appendUint64(b, d.h[7])
-	b = append(b, d.x[:d.nx]...)
-	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
-	b = appendUint64(b, d.nl>>3|d.nh<<61)
-	return b, nil
-}
-
-func (h *sha384Hash) UnmarshalBinary(b []byte) error {
-	if len(b) < len(magic512) {
-		return errors.New("crypto/sha512: invalid hash state identifier")
-	}
-	if string(b[:len(magic384)]) != magic384 {
-		return errors.New("crypto/sha512: invalid hash state identifier")
-	}
-	if len(b) != marshaledSize512 {
-		return errors.New("crypto/sha512: invalid hash state size")
-	}
-	d := (*sha512Ctx)(unsafe.Pointer(&h.ctx))
-	b = b[len(magic512):]
-	b, d.h[0] = consumeUint64(b)
-	b, d.h[1] = consumeUint64(b)
-	b, d.h[2] = consumeUint64(b)
-	b, d.h[3] = consumeUint64(b)
-	b, d.h[4] = consumeUint64(b)
-	b, d.h[5] = consumeUint64(b)
-	b, d.h[6] = consumeUint64(b)
-	b, d.h[7] = consumeUint64(b)
-	b = b[copy(d.x[:], b):]
-	b, n := consumeUint64(b)
-	d.nl = n << 3
-	d.nh = n >> 61
-	d.nx = uint32(n) % 128
-	return nil
-}
-
-func (h *sha512Hash) UnmarshalBinary(b []byte) error {
-	if len(b) < len(magic512) {
-		return errors.New("crypto/sha512: invalid hash state identifier")
-	}
-	if string(b[:len(magic512)]) != magic512 {
-		return errors.New("crypto/sha512: invalid hash state identifier")
-	}
-	if len(b) != marshaledSize512 {
-		return errors.New("crypto/sha512: invalid hash state size")
-	}
-	d := (*sha512Ctx)(unsafe.Pointer(&h.ctx))
-	b = b[len(magic512):]
-	b, d.h[0] = consumeUint64(b)
-	b, d.h[1] = consumeUint64(b)
-	b, d.h[2] = consumeUint64(b)
-	b, d.h[3] = consumeUint64(b)
-	b, d.h[4] = consumeUint64(b)
-	b, d.h[5] = consumeUint64(b)
-	b, d.h[6] = consumeUint64(b)
-	b, d.h[7] = consumeUint64(b)
-	b = b[copy(d.x[:], b):]
-	b, n := consumeUint64(b)
-	d.nl = n << 3
-	d.nh = n >> 61
-	d.nx = uint32(n) % 128
-	return nil
-}
-
-func appendUint64(b []byte, x uint64) []byte {
-	var a [8]byte
-	putUint64(a[:], x)
-	return append(b, a[:]...)
-}
-
-func appendUint32(b []byte, x uint32) []byte {
-	var a [4]byte
-	putUint32(a[:], x)
-	return append(b, a[:]...)
-}
-
-func consumeUint64(b []byte) ([]byte, uint64) {
-	_ = b[7]
-	x := uint64(b[7]) | uint64(b[6])<<8 | uint64(b[5])<<16 | uint64(b[4])<<24 |
-		uint64(b[3])<<32 | uint64(b[2])<<40 | uint64(b[1])<<48 | uint64(b[0])<<56
-	return b[8:], x
-}
-
-func consumeUint32(b []byte) ([]byte, uint32) {
-	_ = b[3]
-	x := uint32(b[3]) | uint32(b[2])<<8 | uint32(b[1])<<16 | uint32(b[0])<<24
-	return b[4:], x
-}
-
-func putUint64(x []byte, s uint64) {
-	_ = x[7]
-	x[0] = byte(s >> 56)
-	x[1] = byte(s >> 48)
-	x[2] = byte(s >> 40)
-	x[3] = byte(s >> 32)
-	x[4] = byte(s >> 24)
-	x[5] = byte(s >> 16)
-	x[6] = byte(s >> 8)
-	x[7] = byte(s)
-}
-
-func putUint32(x []byte, s uint32) {
-	_ = x[3]
-	x[0] = byte(s >> 24)
-	x[1] = byte(s >> 16)
-	x[2] = byte(s >> 8)
-	x[3] = byte(s)
-}
diff --git a/src/crypto/rand/rand_unix.go b/src/crypto/rand/rand_unix.go
index 40fce36314..c30be35635 100644
--- a/src/crypto/rand/rand_unix.go
+++ b/src/crypto/rand/rand_unix.go
@@ -10,7 +10,7 @@
 package rand
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"errors"
 	"io"
 	"os"
@@ -23,7 +23,7 @@ import (
 const urandomDevice = "/dev/urandom"
 
 func init() {
-	if boring.Enabled {
+	if boring.Enabled() {
 		Reader = boring.RandReader
 		return
 	}
diff --git a/src/crypto/rsa/boring.go b/src/crypto/rsa/boring.go
index b9f9d3154f..85c2a45848 100644
--- a/src/crypto/rsa/boring.go
+++ b/src/crypto/rsa/boring.go
@@ -2,13 +2,13 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build !no_openssl
 
 package rsa
 
 import (
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/boring/bcache"
 	"math/big"
 )
diff --git a/src/crypto/rsa/boring_test.go b/src/crypto/rsa/boring_test.go
index 2234d079f0..4e7fd9de4a 100644
--- a/src/crypto/rsa/boring_test.go
+++ b/src/crypto/rsa/boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build !no_openssl
 
 // Note: Can run these tests against the non-BoringCrypto
 // version of the code by using "CGO_ENABLED=0 go test".
diff --git a/src/crypto/rsa/notboring.go b/src/crypto/rsa/notboring.go
index 2abc043640..a83be6dfdb 100644
--- a/src/crypto/rsa/notboring.go
+++ b/src/crypto/rsa/notboring.go
@@ -2,15 +2,15 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto
+//go:build no_openssl
 
 package rsa
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 func boringPublicKey(*PublicKey) (*boring.PublicKeyRSA, error) {
-	panic("boringcrypto: not available")
+	panic("!no_openssl: not available")
 }
 func boringPrivateKey(*PrivateKey) (*boring.PrivateKeyRSA, error) {
-	panic("boringcrypto: not available")
+	panic("!no_openssl: not available")
 }
diff --git a/src/crypto/rsa/pkcs1v15.go b/src/crypto/rsa/pkcs1v15.go
index 2705036fdd..9f38c3558b 100644
--- a/src/crypto/rsa/pkcs1v15.go
+++ b/src/crypto/rsa/pkcs1v15.go
@@ -6,7 +6,7 @@ package rsa
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/randutil"
 	"crypto/subtle"
 	"errors"
@@ -49,7 +49,7 @@ func EncryptPKCS1v15(random io.Reader, pub *PublicKey, msg []byte) ([]byte, erro
 		return nil, ErrMessageTooLong
 	}
 
-	if boring.Enabled && random == boring.RandReader {
+	if boring.Enabled() && random == boring.RandReader {
 		bkey, err := boringPublicKey(pub)
 		if err != nil {
 			return nil, err
@@ -69,7 +69,7 @@ func EncryptPKCS1v15(random io.Reader, pub *PublicKey, msg []byte) ([]byte, erro
 	em[len(em)-len(msg)-1] = 0
 	copy(mm, msg)
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		var bkey *boring.PublicKeyRSA
 		bkey, err = boringPublicKey(pub)
 		if err != nil {
@@ -94,7 +94,7 @@ func DecryptPKCS1v15(random io.Reader, priv *PrivateKey, ciphertext []byte) ([]b
 		return nil, err
 	}
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -188,7 +188,7 @@ func decryptPKCS1v15(priv *PrivateKey, ciphertext []byte) (valid int, em []byte,
 		return
 	}
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		var bkey *boring.PrivateKeyRSA
 		bkey, err = boringPrivateKey(priv)
 		if err != nil {
@@ -296,7 +296,7 @@ func SignPKCS1v15(random io.Reader, priv *PrivateKey, hash crypto.Hash, hashed [
 		return nil, ErrMessageTooLong
 	}
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -322,7 +322,7 @@ func SignPKCS1v15(random io.Reader, priv *PrivateKey, hash crypto.Hash, hashed [
 // returning a nil error. If hash is zero then hashed is used directly. This
 // isn't advisable except for interoperability.
 func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error {
-	if boring.Enabled {
+	if boring.Enabled() {
 		bkey, err := boringPublicKey(pub)
 		if err != nil {
 			return err
diff --git a/src/crypto/rsa/pkcs1v15_test.go b/src/crypto/rsa/pkcs1v15_test.go
index 39a4fc184a..0853178e3a 100644
--- a/src/crypto/rsa/pkcs1v15_test.go
+++ b/src/crypto/rsa/pkcs1v15_test.go
@@ -7,7 +7,7 @@ package rsa_test
 import (
 	"bytes"
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/backend/boringtest"
 	"crypto/rand"
 	. "crypto/rsa"
@@ -56,7 +56,7 @@ var decryptPKCS1v15Tests = []DecryptPKCS1v15Test{
 }
 
 func TestDecryptPKCS1v15(t *testing.T) {
-	if boring.Enabled && !boringtest.Supports(t, "PKCSv1.5") {
+	if boring.Enabled() && !boringtest.Supports(t, "PKCSv1.5") {
 		t.Skip("skipping PKCS#1 v1.5 encryption test with BoringCrypto")
 	}
 
@@ -84,7 +84,7 @@ func TestDecryptPKCS1v15(t *testing.T) {
 }
 
 func TestEncryptPKCS1v15(t *testing.T) {
-	if boring.Enabled && !boringtest.Supports(t, "PKCSv1.5") {
+	if boring.Enabled() && !boringtest.Supports(t, "PKCSv1.5") {
 		t.Skip("skipping PKCS#1 v1.5 encryption test with BoringCrypto")
 	}
 
@@ -149,7 +149,7 @@ var decryptPKCS1v15SessionKeyTests = []DecryptPKCS1v15Test{
 }
 
 func TestEncryptPKCS1v15SessionKey(t *testing.T) {
-	if boring.Enabled && !boringtest.Supports(t, "PKCSv1.5") {
+	if boring.Enabled() && !boringtest.Supports(t, "PKCSv1.5") {
 		t.Skip("skipping PKCS#1 v1.5 encryption test with BoringCrypto")
 	}
 
@@ -167,7 +167,7 @@ func TestEncryptPKCS1v15SessionKey(t *testing.T) {
 }
 
 func TestEncryptPKCS1v15DecrypterSessionKey(t *testing.T) {
-	if boring.Enabled && !boringtest.Supports(t, "PKCSv1.5") {
+	if boring.Enabled() && !boringtest.Supports(t, "PKCSv1.5") {
 		t.Skip("skipping PKCS#1 v1.5 encryption test with BoringCrypto")
 	}
 
@@ -277,7 +277,7 @@ func TestUnpaddedSignature(t *testing.T) {
 }
 
 func TestShortSessionKey(t *testing.T) {
-	if boring.Enabled && !boringtest.Supports(t, "PKCSv1.5") {
+	if boring.Enabled() && !boringtest.Supports(t, "PKCSv1.5") {
 		t.Skip("skipping PKCS#1 v1.5 encryption test with BoringCrypto")
 	}
 
diff --git a/src/crypto/rsa/pss.go b/src/crypto/rsa/pss.go
index b63b6eb01d..a09a4926f7 100644
--- a/src/crypto/rsa/pss.go
+++ b/src/crypto/rsa/pss.go
@@ -9,7 +9,7 @@ package rsa
 import (
 	"bytes"
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"errors"
 	"hash"
 	"io"
@@ -214,7 +214,7 @@ func signPSSWithSalt(priv *PrivateKey, hash crypto.Hash, hashed, salt []byte) ([
 		return nil, err
 	}
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -296,7 +296,7 @@ func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, digest []byte,
 	// well-specified number of random bytes is included in the signature, in a
 	// well-specified way.
 
-	if boring.Enabled && rand == boring.RandReader {
+	if boring.Enabled() && rand == boring.RandReader {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -339,7 +339,7 @@ func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, digest []byte,
 // argument may be nil, in which case sensible defaults are used. opts.Hash is
 // ignored.
 func VerifyPSS(pub *PublicKey, hash crypto.Hash, digest []byte, sig []byte, opts *PSSOptions) error {
-	if boring.Enabled {
+	if boring.Enabled() {
 		bkey, err := boringPublicKey(pub)
 		if err != nil {
 			return err
diff --git a/src/crypto/rsa/pss_test.go b/src/crypto/rsa/pss_test.go
index 1226149321..befd1612b5 100644
--- a/src/crypto/rsa/pss_test.go
+++ b/src/crypto/rsa/pss_test.go
@@ -79,7 +79,7 @@ func TestEMSAPSS(t *testing.T) {
 // TestPSSGolden tests all the test vectors in pss-vect.txt from
 // ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1-vec.zip
 func TestPSSGolden(t *testing.T) {
-	if boring.Enabled && !boringtest.Supports(t, "SHA1") {
+	if boring.Enabled() && !boringtest.Supports(t, "SHA1") {
 		t.Skip("skipping PSS test with BoringCrypto: SHA-1 not allowed")
 	}
 	inFile, err := os.Open("testdata/pss-vect.txt.bz2")
@@ -173,7 +173,7 @@ func TestPSSGolden(t *testing.T) {
 // TestPSSOpenSSL ensures that we can verify a PSS signature from OpenSSL with
 // the default options. OpenSSL sets the salt length to be maximal.
 func TestPSSOpenSSL(t *testing.T) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		t.Skip("skipping PSS test with BoringCrypto: too short key")
 	}
 
@@ -209,7 +209,7 @@ func TestPSSNilOpts(t *testing.T) {
 }
 
 func TestPSSSigning(t *testing.T) {
-	if boring.Enabled && !boringtest.Supports(t, "SHA1") {
+	if boring.Enabled() && !boringtest.Supports(t, "SHA1") {
 		t.Skip("skipping PSS test with BoringCrypto: too short key")
 	}
 
diff --git a/src/crypto/rsa/rsa.go b/src/crypto/rsa/rsa.go
index 9342930dc1..dad2a3c01a 100644
--- a/src/crypto/rsa/rsa.go
+++ b/src/crypto/rsa/rsa.go
@@ -28,8 +28,8 @@ package rsa
 import (
 	"crypto"
 	"crypto/internal/bigmod"
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/randutil"
 	"crypto/rand"
 	"crypto/subtle"
@@ -298,7 +298,7 @@ func GenerateKey(random io.Reader, bits int) (*PrivateKey, error) {
 func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*PrivateKey, error) {
 	randutil.MaybeReadByte(random)
 
-	if boring.Enabled && random == boring.RandReader && nprimes == 2 &&
+	if boring.Enabled() && random == boring.RandReader && nprimes == 2 &&
 		(bits == 2048 || bits == 3072 || bits == 4096) {
 		bN, bE, bD, bP, bQ, bDp, bDq, bQinv, err := boring.GenerateKeyRSA(bits)
 		if err != nil {
@@ -529,7 +529,7 @@ func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, l
 		return nil, ErrMessageTooLong
 	}
 
-	if boring.Enabled && random == boring.RandReader {
+	if boring.Enabled() && random == boring.RandReader {
 		bkey, err := boringPublicKey(pub)
 		if err != nil {
 			return nil, err
@@ -558,7 +558,7 @@ func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, l
 	mgf1XOR(db, hash, seed)
 	mgf1XOR(seed, hash, db)
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		var bkey *boring.PublicKeyRSA
 		bkey, err = boringPublicKey(pub)
 		if err != nil {
@@ -719,7 +719,7 @@ func decryptOAEP(hash, mgfHash hash.Hash, random io.Reader, priv *PrivateKey, ci
 		return nil, ErrDecryption
 	}
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
diff --git a/src/crypto/rsa/rsa_test.go b/src/crypto/rsa/rsa_test.go
index 437e0c219d..e6b5e266a8 100644
--- a/src/crypto/rsa/rsa_test.go
+++ b/src/crypto/rsa/rsa_test.go
@@ -8,7 +8,7 @@ import (
 	"bufio"
 	"bytes"
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	. "crypto/rsa"
 	"crypto/sha1"
@@ -34,7 +34,7 @@ func TestKeyGeneration(t *testing.T) {
 		if bits := priv.N.BitLen(); bits != size {
 			t.Errorf("key too short (%d vs %d)", bits, size)
 		}
-		if boring.Enabled && size < 1024 {
+		if boring.Enabled() && size < 1024 {
 			t.Logf("skipping short key with BoringCrypto: %d", size)
 			continue
 		}
@@ -120,12 +120,12 @@ func testKeyBasics(t *testing.T, priv *PrivateKey) {
 		t.Errorf("private exponent too large")
 	}
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		// Cannot call encrypt/decrypt with raw RSA. PKCSv1.5
 		// not supported in some configurations.  Test with
 		// OAEP if possible (i.e., key size is equal to or
 		// longer than 2048 bits).
-		if bits := priv.N.BitLen(); boring.Enabled && bits < 2048 {
+		if bits := priv.N.BitLen(); boring.Enabled() && bits < 2048 {
 			t.Logf("skipping short key with BoringCrypto: %d", bits)
 			return
 		}
@@ -167,7 +167,7 @@ func testKeyBasics(t *testing.T, priv *PrivateKey) {
 }
 
 func TestAllocations(t *testing.T) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		t.Skip("skipping allocations test with BoringCrypto")
 	}
 	testenv.SkipIfOptimizationOff(t)
@@ -213,7 +213,7 @@ func TestEverything(t *testing.T) {
 			if bits := priv.N.BitLen(); bits != size {
 				t.Errorf("key too short (%d vs %d)", bits, size)
 			}
-			if boring.Enabled && size < 2048 {
+			if boring.Enabled() && size < 2048 {
 				t.Skip("skipping short key with BoringCrypto")
 			}
 			testEverything(t, priv)
@@ -677,7 +677,7 @@ func TestEncryptOAEP(t *testing.T) {
 	n := new(big.Int)
 	for i, test := range testEncryptOAEPData {
 		n.SetString(test.modulus, 16)
-		if boring.Enabled {
+		if boring.Enabled() {
 			t.Log("skipping test in FIPS mode due to short keys and unpadded RSA operations not allowed with FIPS")
 			continue
 		}
@@ -704,7 +704,7 @@ func TestDecryptOAEP(t *testing.T) {
 	d := new(big.Int)
 	for i, test := range testEncryptOAEPData {
 		n.SetString(test.modulus, 16)
-		if boring.Enabled && !boringtest.Supports(t, "RSA1024") && n.BitLen() < 2048 {
+		if boring.Enabled() && !boringtest.Supports(t, "RSA1024") && n.BitLen() < 2048 {
 			t.Logf("skipping encryption tests with BoringCrypto: too short key: %d", n.BitLen())
 			continue
 		}
@@ -751,7 +751,7 @@ func Test2DecryptOAEP(t *testing.T) {
 	sha1 := crypto.SHA1
 	sha256 := crypto.SHA256
 
-	if boring.Enabled && n.BitLen() < 2048 {
+	if boring.Enabled() && n.BitLen() < 2048 {
 		t.Skipf("skipping encryption tests with BoringCrypto: too short key: %d", n.BitLen())
 	}
 
@@ -770,7 +770,7 @@ func TestEncryptDecryptOAEP(t *testing.T) {
 	d := new(big.Int)
 	for i, test := range testEncryptOAEPData {
 		n.SetString(test.modulus, 16)
-		if boring.Enabled && !boringtest.Supports(t, "RSA1024") && n.BitLen() < 2048 {
+		if boring.Enabled() && !boringtest.Supports(t, "RSA1024") && n.BitLen() < 2048 {
 			t.Logf("skipping encryption tests with BoringCrypto: too short key: %d", n.BitLen())
 			continue
 		}
diff --git a/src/crypto/sha1/sha1.go b/src/crypto/sha1/sha1.go
index ac10fa1557..f561d09089 100644
--- a/src/crypto/sha1/sha1.go
+++ b/src/crypto/sha1/sha1.go
@@ -10,7 +10,7 @@ package sha1
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"encoding/binary"
 	"errors"
 	"hash"
@@ -108,7 +108,7 @@ func (d *digest) Reset() {
 // implements [encoding.BinaryMarshaler] and [encoding.BinaryUnmarshaler] to
 // marshal and unmarshal the internal state of the hash.
 func New() hash.Hash {
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.NewSHA1()
 	}
 	d := new(digest)
@@ -255,7 +255,7 @@ func (d *digest) constSum() [Size]byte {
 
 // Sum returns the SHA-1 checksum of the data.
 func Sum(data []byte) [Size]byte {
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.SHA1(data)
 	}
 	var d digest
diff --git a/src/crypto/sha1/sha1_test.go b/src/crypto/sha1/sha1_test.go
index 85ed126091..71f4b46663 100644
--- a/src/crypto/sha1/sha1_test.go
+++ b/src/crypto/sha1/sha1_test.go
@@ -8,7 +8,7 @@ package sha1
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"encoding"
 	"fmt"
@@ -78,7 +78,7 @@ func TestGolden(t *testing.T) {
 				io.WriteString(c, g.in[len(g.in)/2:])
 				sum = c.Sum(nil)
 			case 3:
-				if boring.Enabled {
+				if boring.Enabled() {
 					continue
 				}
 				io.WriteString(c, g.in[0:len(g.in)/2])
@@ -145,7 +145,7 @@ func TestBlockSize(t *testing.T) {
 
 // Tests that blockGeneric (pure Go) and block (in assembly for some architectures) match.
 func TestBlockGeneric(t *testing.T) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		t.Skip("BoringCrypto doesn't expose digest")
 	}
 	for i := 1; i < 30; i++ { // arbitrary factor
@@ -218,7 +218,7 @@ func TestLargeHashes(t *testing.T) {
 }
 
 func TestAllocations(t *testing.T) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		t.Skip("BoringCrypto doesn't allocate the same way as stdlib")
 	}
 	in := []byte("hello, world!")
diff --git a/src/crypto/sha256/sha256.go b/src/crypto/sha256/sha256.go
index 0cc7fca0a6..1bfbf904b1 100644
--- a/src/crypto/sha256/sha256.go
+++ b/src/crypto/sha256/sha256.go
@@ -8,7 +8,7 @@ package sha256
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"encoding/binary"
 	"errors"
 	"hash"
@@ -148,7 +148,7 @@ func (d *digest) Reset() {
 // [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal
 // state of the hash.
 func New() hash.Hash {
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.NewSHA256()
 	}
 	d := new(digest)
@@ -158,7 +158,7 @@ func New() hash.Hash {
 
 // New224 returns a new hash.Hash computing the SHA224 checksum.
 func New224() hash.Hash {
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.NewSHA224()
 	}
 	d := new(digest)
@@ -251,7 +251,7 @@ func (d *digest) checkSum() [Size]byte {
 
 // Sum256 returns the SHA256 checksum of the data.
 func Sum256(data []byte) [Size]byte {
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.SHA256(data)
 	}
 	var d digest
@@ -262,7 +262,7 @@ func Sum256(data []byte) [Size]byte {
 
 // Sum224 returns the SHA224 checksum of the data.
 func Sum224(data []byte) [Size224]byte {
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.SHA224(data)
 	}
 	var d digest
diff --git a/src/crypto/sha256/sha256_test.go b/src/crypto/sha256/sha256_test.go
index 7304678346..a073d31119 100644
--- a/src/crypto/sha256/sha256_test.go
+++ b/src/crypto/sha256/sha256_test.go
@@ -8,7 +8,7 @@ package sha256
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"encoding"
 	"fmt"
@@ -217,7 +217,7 @@ func TestBlockSize(t *testing.T) {
 
 // Tests that blockGeneric (pure Go) and block (in assembly for some architectures) match.
 func TestBlockGeneric(t *testing.T) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		t.Skip("BoringCrypto doesn't expose digest")
 	}
 	gen, asm := New().(*digest), New().(*digest)
@@ -294,7 +294,7 @@ func TestLargeHashes(t *testing.T) {
 }
 
 func TestAllocations(t *testing.T) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		t.Skip("BoringCrypto doesn't allocate the same way as stdlib")
 	}
 	in := []byte("hello, world!")
diff --git a/src/crypto/sha512/sha512.go b/src/crypto/sha512/sha512.go
index 9ae1b3aae2..e56eedb201 100644
--- a/src/crypto/sha512/sha512.go
+++ b/src/crypto/sha512/sha512.go
@@ -12,7 +12,7 @@ package sha512
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"encoding/binary"
 	"errors"
 	"hash"
@@ -206,7 +206,7 @@ func consumeUint64(b []byte) ([]byte, uint64) {
 
 // New returns a new hash.Hash computing the SHA-512 checksum.
 func New() hash.Hash {
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.NewSHA512()
 	}
 	d := &digest{function: crypto.SHA512}
@@ -230,7 +230,7 @@ func New512_256() hash.Hash {
 
 // New384 returns a new hash.Hash computing the SHA-384 checksum.
 func New384() hash.Hash {
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.NewSHA384()
 	}
 	d := &digest{function: crypto.SHA384}
@@ -341,7 +341,7 @@ func (d *digest) checkSum() [Size]byte {
 
 // Sum512 returns the SHA512 checksum of the data.
 func Sum512(data []byte) [Size]byte {
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.SHA512(data)
 	}
 	d := digest{function: crypto.SHA512}
@@ -352,7 +352,7 @@ func Sum512(data []byte) [Size]byte {
 
 // Sum384 returns the SHA384 checksum of the data.
 func Sum384(data []byte) [Size384]byte {
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.SHA384(data)
 	}
 	d := digest{function: crypto.SHA384}
diff --git a/src/crypto/sha512/sha512_test.go b/src/crypto/sha512/sha512_test.go
index 921cdbb7bb..a35165bcbf 100644
--- a/src/crypto/sha512/sha512_test.go
+++ b/src/crypto/sha512/sha512_test.go
@@ -8,7 +8,7 @@ package sha512
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"encoding"
 	"encoding/hex"
@@ -823,7 +823,7 @@ func TestBlockSize(t *testing.T) {
 
 // Tests that blockGeneric (pure Go) and block (in assembly for some architectures) match.
 func TestBlockGeneric(t *testing.T) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		t.Skip("BoringCrypto doesn't expose digest")
 	}
 	gen, asm := New().(*digest), New().(*digest)
@@ -893,7 +893,7 @@ func TestLargeHashes(t *testing.T) {
 }
 
 func TestAllocations(t *testing.T) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		t.Skip("BoringCrypto doesn't allocate the same way as stdlib")
 	}
 	in := []byte("hello, world!")
diff --git a/src/crypto/tls/boring.go b/src/crypto/tls/boring.go
index 401be7064c..66252067f2 100644
--- a/src/crypto/tls/boring.go
+++ b/src/crypto/tls/boring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build !no_openssl
 
 package tls
 
@@ -12,7 +12,7 @@ import (
 )
 
 func init() {
-	if boring.Enabled && !boring.ExecutingTest() {
+	if boring.Enabled() && !boring.ExecutingTest() {
 		fipstls.Force()
 	}
 }
diff --git a/src/crypto/tls/boring_test.go b/src/crypto/tls/boring_test.go
index 4e68e705fd..43a3d1b71a 100644
--- a/src/crypto/tls/boring_test.go
+++ b/src/crypto/tls/boring_test.go
@@ -2,14 +2,14 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build !no_openssl
 
 package tls
 
 import (
 	"crypto/ecdsa"
 	"crypto/elliptic"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/backend/boringtest"
 	"crypto/internal/boring/fipstls"
 	"crypto/rand"
@@ -46,7 +46,7 @@ func TestBoringServerProtocolVersion(t *testing.T) {
 	test("VersionTLS10", VersionTLS10, "")
 	test("VersionTLS11", VersionTLS11, "")
 	test("VersionTLS12", VersionTLS12, "")
-	if boring.Enabled && !boring.SupportsHKDF() {
+	if boring.Enabled() && !boring.SupportsHKDF() {
 		test("VersionTLS13", VersionTLS13, "client offered only unsupported versions")
 	} else {
 		test("VersionTLS13", VersionTLS13, "")
@@ -236,7 +236,7 @@ func TestBoringServerSignatureAndHash(t *testing.T) {
 
 			clientConfig := testConfig.Clone()
 
-			if boring.Enabled {
+			if boring.Enabled() {
 				serverConfig.Rand = boring.RandReader
 				clientConfig.Rand = boring.RandReader
 			}
@@ -367,7 +367,7 @@ func TestBoringCertAlgs(t *testing.T) {
 		serverConfig.Certificates = []Certificate{{Certificate: list, PrivateKey: key}}
 		serverConfig.BuildNameToCertificate()
 
-		if boring.Enabled {
+		if boring.Enabled() {
 			serverConfig.Rand = boring.RandReader
 			clientConfig.Rand = boring.RandReader
 		}
@@ -398,13 +398,13 @@ func TestBoringCertAlgs(t *testing.T) {
 		serverConfig := testConfig.Clone()
 		serverConfig.ClientCAs = pool
 		serverConfig.ClientAuth = RequireAndVerifyClientCert
-		if boring.Enabled {
+		if boring.Enabled() {
 			serverConfig.Certificates[0].Certificate = [][]byte{testRSA2048Certificate}
 			serverConfig.Certificates[0].PrivateKey = testRSA2048PrivateKey
 			serverConfig.BuildNameToCertificate()
 		}
 
-		if boring.Enabled {
+		if boring.Enabled() {
 			serverConfig.Rand = boring.RandReader
 			clientConfig.Rand = boring.RandReader
 		}
@@ -430,8 +430,8 @@ func TestBoringCertAlgs(t *testing.T) {
 	// exhaustive test with computed answers.
 	r1pool := x509.NewCertPool()
 	r1pool.AddCert(R1.cert)
-	testServerCert(t, "basic", r1pool, L2_I.key, [][]byte{L2_I.der, I_R1.der}, !(L2_I.notBoring && boring.Enabled))
-	testClientCert(t, "basic (client cert)", r1pool, L2_I.key, [][]byte{L2_I.der, I_R1.der}, !(L2_I.notBoring && boring.Enabled))
+	testServerCert(t, "basic", r1pool, L2_I.key, [][]byte{L2_I.der, I_R1.der}, !(L2_I.notBoring && boring.Enabled()))
+	testClientCert(t, "basic (client cert)", r1pool, L2_I.key, [][]byte{L2_I.der, I_R1.der}, !(L2_I.notBoring && boring.Enabled()))
 	fipstls.Force()
 	testServerCert(t, "basic (fips)", r1pool, L2_I.key, [][]byte{L2_I.der, I_R1.der}, false)
 	testClientCert(t, "basic (fips, client cert)", r1pool, L2_I.key, [][]byte{L2_I.der, I_R1.der}, false)
@@ -452,7 +452,7 @@ func TestBoringCertAlgs(t *testing.T) {
 			leaf = L2_I
 		}
 		for i := 0; i < 64; i++ {
-			reachable := map[string]bool{leaf.parentOrg: !(leaf.notBoring && boring.Enabled)}
+			reachable := map[string]bool{leaf.parentOrg: !(leaf.notBoring && boring.Enabled())}
 			reachableFIPS := map[string]bool{leaf.parentOrg: leaf.fipsOK}
 			list := [][]byte{leaf.der}
 			listName := leaf.name
@@ -460,7 +460,7 @@ func TestBoringCertAlgs(t *testing.T) {
 				if cond != 0 {
 					list = append(list, c.der)
 					listName += "," + c.name
-					if reachable[c.org] && !(c.notBoring && boring.Enabled) {
+					if reachable[c.org] && !(c.notBoring && boring.Enabled()) {
 						reachable[c.parentOrg] = true
 					}
 					if reachableFIPS[c.org] && c.fipsOK {
@@ -484,7 +484,7 @@ func TestBoringCertAlgs(t *testing.T) {
 					if cond != 0 {
 						rootName += "," + c.name
 						pool.AddCert(c.cert)
-						if reachable[c.org] && !(c.notBoring && boring.Enabled) {
+						if reachable[c.org] && !(c.notBoring && boring.Enabled()) {
 							shouldVerify = true
 						}
 						if reachableFIPS[c.org] && c.fipsOK {
diff --git a/src/crypto/tls/cipher_suites.go b/src/crypto/tls/cipher_suites.go
index d352a8cfa8..a8920d151b 100644
--- a/src/crypto/tls/cipher_suites.go
+++ b/src/crypto/tls/cipher_suites.go
@@ -10,7 +10,7 @@ import (
 	"crypto/cipher"
 	"crypto/des"
 	"crypto/hmac"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rc4"
 	"crypto/sha1"
 	"crypto/sha256"
@@ -446,7 +446,7 @@ func macSHA1(key []byte) hash.Hash {
 	h := sha1.New
 	// The BoringCrypto SHA1 does not have a constant-time
 	// checksum function, so don't try to use it.
-	if !boring.Enabled {
+	if !boring.Enabled() {
 		h = newConstantTimeHash(h)
 	}
 	return hmac.New(h, key)
@@ -538,7 +538,7 @@ func aeadAESGCM(key, noncePrefix []byte) aead {
 		panic(err)
 	}
 	var aead cipher.AEAD
-	if boring.Enabled {
+	if boring.Enabled() {
 		aead, err = boring.NewGCMTLS(aes)
 	} else {
 		boring.Unreachable()
diff --git a/src/crypto/tls/common.go b/src/crypto/tls/common.go
index c0087ef5df..251a05cb75 100644
--- a/src/crypto/tls/common.go
+++ b/src/crypto/tls/common.go
@@ -12,7 +12,7 @@ import (
 	"crypto/ecdsa"
 	"crypto/ed25519"
 	"crypto/elliptic"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"crypto/rsa"
 	"crypto/sha512"
@@ -1041,7 +1041,7 @@ var tls10server = godebug.New("tls10server")
 func (c *Config) supportedVersions(isClient bool) []uint16 {
 	versions := make([]uint16, 0, len(supportedVersions))
 	for _, v := range supportedVersions {
-		if boring.Enabled && !boring.SupportsHKDF() && v > VersionTLS12 {
+		if boring.Enabled() && !boring.SupportsHKDF() && v > VersionTLS12 {
 			continue
 		}
 		if needFIPS() && (v < fipsMinVersion(c) || v > fipsMaxVersion(c)) {
diff --git a/src/crypto/tls/key_schedule.go b/src/crypto/tls/key_schedule.go
index e7a360fdd4..9ea9eed2fb 100644
--- a/src/crypto/tls/key_schedule.go
+++ b/src/crypto/tls/key_schedule.go
@@ -7,7 +7,7 @@ package tls
 import (
 	"crypto/ecdh"
 	"crypto/hmac"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"errors"
 	"fmt"
 	"hash"
@@ -60,7 +60,7 @@ func (c *cipherSuiteTLS13) expandLabel(secret []byte, label string, context []by
 		panic(fmt.Errorf("failed to construct HKDF label: %s", err))
 	}
 	out := make([]byte, length)
-	if boring.Enabled {
+	if boring.Enabled() {
 		reader, err := boring.ExpandHKDF(c.hash.New, secret, hkdfLabelBytes)
 		if err != nil {
 			panic("tls: HKDF-Expand-Label invocation failed unexpectedly")
@@ -91,7 +91,7 @@ func (c *cipherSuiteTLS13) extract(newSecret, currentSecret []byte) []byte {
 	if newSecret == nil {
 		newSecret = make([]byte, c.hash.Size())
 	}
-	if boring.Enabled {
+	if boring.Enabled() {
 		ikm, err := boring.ExtractHKDF(c.hash.New, newSecret, currentSecret)
 		if err != nil {
 			panic("tls: HKDF-Extract invocation failed unexpectedly")
diff --git a/src/crypto/tls/notboring.go b/src/crypto/tls/notboring.go
index 7d85b39c59..fe2719485b 100644
--- a/src/crypto/tls/notboring.go
+++ b/src/crypto/tls/notboring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto
+//go:build no_openssl
 
 package tls
 
diff --git a/src/crypto/x509/boring.go b/src/crypto/x509/boring.go
index 095b58c315..ac06591ea8 100644
--- a/src/crypto/x509/boring.go
+++ b/src/crypto/x509/boring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build !no_openssl
 
 package x509
 
diff --git a/src/crypto/x509/boring_test.go b/src/crypto/x509/boring_test.go
index 102acda578..07b3c7095e 100644
--- a/src/crypto/x509/boring_test.go
+++ b/src/crypto/x509/boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build !no_openssl
 
 package x509
 
diff --git a/src/crypto/x509/notboring.go b/src/crypto/x509/notboring.go
index c83a7272c9..0c7dea2f1f 100644
--- a/src/crypto/x509/notboring.go
+++ b/src/crypto/x509/notboring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto
+//go:build no_openssl
 
 package x509
 
diff --git a/src/crypto/x509/x509_test.go b/src/crypto/x509/x509_test.go
index 3c592e1136..a594823783 100644
--- a/src/crypto/x509/x509_test.go
+++ b/src/crypto/x509/x509_test.go
@@ -12,7 +12,7 @@ import (
 	"crypto/ecdsa"
 	"crypto/ed25519"
 	"crypto/elliptic"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/backend/boringtest"
 	"crypto/rand"
 	"crypto/rsa"
@@ -656,7 +656,7 @@ func TestCreateSelfSignedCertificate(t *testing.T) {
 	extraExtensionData := []byte("extra extension")
 
 	for _, test := range tests {
-		if boring.Enabled && test.sigAlgo.isRSAPSS() {
+		if boring.Enabled() && test.sigAlgo.isRSAPSS() {
 			key, _ := test.priv.(*rsa.PrivateKey)
 			if key.PublicKey.N.BitLen() < 2048 {
 				t.Logf("skipping short key with BoringCrypto: %d", key.PublicKey.N.BitLen())
@@ -3720,7 +3720,7 @@ func TestRevocationListCheckSignatureFrom(t *testing.T) {
 	var testCurve elliptic.Curve
 	// If OpenSSL supports P224, use the default upstream behavior,
 	// otherwise test with P384
-	if !boring.Enabled || boringtest.Supports(t, "CurveP224") {
+	if !boring.Enabled() || boringtest.Supports(t, "CurveP224") {
 		testCurve = elliptic.P224()
 	} else {
 		testCurve = elliptic.P384()
diff --git a/src/go.mod b/src/go.mod
index 737d78da5d..a1610087fe 100644
--- a/src/go.mod
+++ b/src/go.mod
@@ -3,6 +3,7 @@ module std
 go 1.22
 
 require (
+	github.com/golang-fips/openssl/v2 v2.0.3
 	golang.org/x/crypto v0.16.1-0.20231129163542-152cdb1503eb
 	golang.org/x/net v0.19.1-0.20240412193750-db050b07227e
 )
diff --git a/src/go.sum b/src/go.sum
index 86d173c9e6..c7def15f16 100644
--- a/src/go.sum
+++ b/src/go.sum
@@ -1,3 +1,5 @@
+github.com/golang-fips/openssl/v2 v2.0.3 h1:9+J2R0BQio6Jz8+dPZf/0ylISByl0gZWjTEKm+J+y7Y=
+github.com/golang-fips/openssl/v2 v2.0.3/go.mod h1:7tuBqX2Zov8Yq5mJ2yzlKhpnxOnWyEzi38AzeWRuQdg=
 golang.org/x/crypto v0.16.1-0.20231129163542-152cdb1503eb h1:1ceSY7sk6sJuiDREHpfyrqDnDljsLfEP2GuTClhBBfI=
 golang.org/x/crypto v0.16.1-0.20231129163542-152cdb1503eb/go.mod h1:gCAAfMLgwOJRpTjQ2zCCt2OcSfYMTeZVSRtQlPC7Nq4=
 golang.org/x/net v0.19.1-0.20240412193750-db050b07227e h1:oDnvqaqHo3ho8OChMtkQbQAyp9eqnm3J7JRtt0+Cabc=
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/.gitleaks.toml b/src/vendor/github.com/golang-fips/openssl/v2/.gitleaks.toml
new file mode 100644
index 0000000000..aed2e22df2
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/.gitleaks.toml
@@ -0,0 +1,9 @@
+#
+# GitLeaks Repo Specific Configuration
+#
+# This allowlist is used to ignore false positives during secret scans.
+
+[allowlist]
+paths = [
+      'ecdh_test.go',
+]
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/LICENSE b/src/vendor/github.com/golang-fips/openssl/v2/LICENSE
new file mode 100644
index 0000000000..97e8515401
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/LICENSE
@@ -0,0 +1,20 @@
+The MIT License (MIT)
+
+Copyright (c) 2022 The Golang FIPS Authors
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\ No newline at end of file
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/README.md b/src/vendor/github.com/golang-fips/openssl/v2/README.md
new file mode 100644
index 0000000000..1bfbaf60f4
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/README.md
@@ -0,0 +1,66 @@
+# Go OpenSSL bindings for FIPS compliance
+
+[![Go Reference](https://pkg.go.dev/badge/github.com/golang-fips/openssl.svg)](https://pkg.go.dev/github.com/golang-fips/openssl)
+
+The `openssl` package implements Go crypto primitives using OpenSSL shared libraries and cgo. When configured correctly, OpenSSL can be executed in FIPS mode, making the `openssl` package FIPS compliant.
+
+The `openssl` package is designed to be used as a drop-in replacement for the [boring](https://pkg.go.dev/crypto/internal/boring) package in order to facilitate integrating `openssl` inside a forked Go toolchain.
+
+## Disclaimer
+
+A program directly or indirectly using this package in FIPS mode can claim it is using a FIPS-certified cryptographic module (OpenSSL), but it can't claim the program as a whole is FIPS certified without passing the certification process, nor claim it is FIPS compliant without ensuring all crypto APIs and workflows are implemented in a FIPS-compliant manner.
+
+## Background
+
+FIPS 140-2 is a U.S. government computer security standard used to approve cryptographic modules. FIPS compliance may come up when working with U.S. government and other regulated industries.
+
+### Go FIPS compliance
+
+The Go `crypto` package is not FIPS certified, and the Go team has stated that it won't be, e.g. in [golang/go/issues/21734](https://github.com/golang/go/issues/21734#issuecomment-326980213) Adam Langley says:
+
+> The status of FIPS 140 for Go itself remains "no plans, basically zero chance".
+
+On the other hand, Google maintains a branch that uses cgo and BoringSSL to implement various crypto primitives: https://github.com/golang/go/blob/dev.boringcrypto/README.boringcrypto.md. As BoringSSL is FIPS 140-2 certified, an application using that branch is more likely to be FIPS 140-2 compliant, yet Google does not provide any liability about the suitability of this code in relation to the FIPS 140-2 standard.
+
+## Features
+
+### Multiple OpenSSL versions supported
+
+The `openssl` package has support for multiple OpenSSL versions, namely 1.0.2, 1.1.0, 1.1.1 and 3.x.
+
+All supported OpenSSL versions pass a small set of automatic tests that ensure they can be built and that there are no major regressions.
+These tests do not validate the cryptographic correctness of the `openssl` package.
+
+On top of that, the [golang-fips Go fork](https://github.com/golang-fips/go) -maintained by Red Hat- and the [Microsoft Go fork](https://github.com/microsoft/go), tests a subset of the supported OpenSSL versions when integrated with the Go `crypto` package.
+These tests are much more exhaustive and validate a specific OpenSSL version can produce working applications.
+
+### Building without OpenSSL headers
+
+The `openssl` package does not use any symbol from the OpenSSL headers. There is no need that have them installed to build an application which imports this library.
+
+The CI tests in this repository verify that all the functions and constants defined in our headers match the ones in the OpenSSL headers for every supported OpenSSL version.
+
+### Portable OpenSSL
+
+The OpenSSL bindings are implemented in such a way that the OpenSSL version available when building a program does not have to match with the OpenSSL version used when running it.
+In fact, OpenSSL doesn't need to be present on the builder.
+For example, using the `openssl` package and `go build .` on a Windows host with `GOOS=linux` can produce a program that successfully runs on Linux and uses OpenSSL.
+
+This feature does not require any additional configuration, but it only works with OpenSSL versions known and supported by the Go toolchain that integrates the `openssl` package.
+
+## Limitations
+
+- Only Unix, Unix-like and Windows platforms are supported.
+- The build must set `CGO_ENABLED=1`.
+
+## Acknowledgements
+
+The work done to support FIPS compatibility mode leverages code and ideas from other open-source projects:
+
+- All crypto stubs are a mirror of Google's [dev.boringcrypto branch](https://github.com/golang/go/tree/dev.boringcrypto) and the release branch ports of that branch.
+- The mapping between BoringSSL and OpenSSL APIs is taken from the former [Red Hat Go fork](https://pagure.io/go).
+- The portable OpenSSL implementation is ported from Microsoft's [.NET runtime](https://github.com/dotnet/runtime) cryptography module.
+
+## Code of Conduct
+
+This project adopts the Go code of conduct: https://go.dev/conduct.
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/aes.go b/src/vendor/github.com/golang-fips/openssl/v2/aes.go
new file mode 100644
index 0000000000..231b75e2ad
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/aes.go
@@ -0,0 +1,100 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"crypto/cipher"
+	"errors"
+)
+
+type extraModes interface {
+	// Copied out of crypto/aes/modes.go.
+	NewCBCEncrypter(iv []byte) cipher.BlockMode
+	NewCBCDecrypter(iv []byte) cipher.BlockMode
+	NewCTR(iv []byte) cipher.Stream
+	NewGCM(nonceSize, tagSize int) (cipher.AEAD, error)
+
+	// Invented for BoringCrypto.
+	NewGCMTLS() (cipher.AEAD, error)
+}
+
+var _ extraModes = (*aesCipher)(nil)
+
+func NewAESCipher(key []byte) (cipher.Block, error) {
+	var kind cipherKind
+	switch len(key) * 8 {
+	case 128:
+		kind = cipherAES128
+	case 192:
+		kind = cipherAES192
+	case 256:
+		kind = cipherAES256
+	default:
+		return nil, errors.New("crypto/aes: invalid key size")
+	}
+	c, err := newEVPCipher(key, kind)
+	if err != nil {
+		return nil, err
+	}
+	return &aesCipher{c}, nil
+}
+
+// NewGCMTLS returns a GCM cipher specific to TLS
+// and should not be used for non-TLS purposes.
+func NewGCMTLS(c cipher.Block) (cipher.AEAD, error) {
+	return c.(*aesCipher).NewGCMTLS()
+}
+
+// NewGCMTLS13 returns a GCM cipher specific to TLS 1.3 and should not be used
+// for non-TLS purposes.
+func NewGCMTLS13(c cipher.Block) (cipher.AEAD, error) {
+	return c.(*aesCipher).NewGCMTLS13()
+}
+
+type aesCipher struct {
+	*evpCipher
+}
+
+func (c *aesCipher) BlockSize() int {
+	return c.blockSize
+}
+
+func (c *aesCipher) Encrypt(dst, src []byte) {
+	if err := c.encrypt(dst, src); err != nil {
+		// crypto/aes expects that the panic message starts with "crypto/aes: ".
+		panic("crypto/aes: " + err.Error())
+	}
+}
+
+func (c *aesCipher) Decrypt(dst, src []byte) {
+	if err := c.decrypt(dst, src); err != nil {
+		// crypto/aes expects that the panic message starts with "crypto/aes: ".
+		panic("crypto/aes: " + err.Error())
+	}
+}
+
+func (c *aesCipher) NewCBCEncrypter(iv []byte) cipher.BlockMode {
+	return c.newCBC(iv, cipherOpEncrypt)
+}
+
+func (c *aesCipher) NewCBCDecrypter(iv []byte) cipher.BlockMode {
+	return c.newCBC(iv, cipherOpDecrypt)
+}
+
+func (c *aesCipher) NewCTR(iv []byte) cipher.Stream {
+	return c.newCTR(iv)
+}
+
+func (c *aesCipher) NewGCM(nonceSize, tagSize int) (cipher.AEAD, error) {
+	return c.newGCMChecked(nonceSize, tagSize)
+}
+
+func (c *aesCipher) NewGCMTLS() (cipher.AEAD, error) {
+	return c.newGCM(cipherGCMTLS12)
+}
+
+func (c *aesCipher) NewGCMTLS13() (cipher.AEAD, error) {
+	return c.newGCM(cipherGCMTLS13)
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/bbig/big.go b/src/vendor/github.com/golang-fips/openssl/v2/bbig/big.go
new file mode 100644
index 0000000000..a81cbdbef9
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/bbig/big.go
@@ -0,0 +1,37 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// This is a mirror of
+// https://github.com/golang/go/blob/36b87f273cc43e21685179dc1664ebb5493d26ae/src/crypto/internal/boring/bbig/big.go.
+
+package bbig
+
+import (
+	"math/big"
+	"unsafe"
+
+	"github.com/golang-fips/openssl/v2"
+)
+
+func Enc(b *big.Int) openssl.BigInt {
+	if b == nil {
+		return nil
+	}
+	x := b.Bits()
+	if len(x) == 0 {
+		return openssl.BigInt{}
+	}
+	return unsafe.Slice((*uint)(&x[0]), len(x))
+}
+
+func Dec(b openssl.BigInt) *big.Int {
+	if b == nil {
+		return nil
+	}
+	if len(b) == 0 {
+		return new(big.Int)
+	}
+	x := unsafe.Slice((*big.Word)(&b[0]), len(b))
+	return new(big.Int).SetBits(x)
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/big.go b/src/vendor/github.com/golang-fips/openssl/v2/big.go
new file mode 100644
index 0000000000..6461f241f8
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/big.go
@@ -0,0 +1,11 @@
+package openssl
+
+// This file does not have build constraints to
+// facilitate using BigInt in Go crypto.
+// Go crypto references BigInt unconditionally,
+// even if it is not finally used.
+
+// A BigInt is the raw words from a BigInt.
+// This definition allows us to avoid importing math/big.
+// Conversion between BigInt and *big.Int is in openssl/bbig.
+type BigInt []uint
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/cipher.go b/src/vendor/github.com/golang-fips/openssl/v2/cipher.go
new file mode 100644
index 0000000000..72f7aebfc1
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/cipher.go
@@ -0,0 +1,569 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+
+import (
+	"crypto/cipher"
+	"encoding/binary"
+	"errors"
+	"runtime"
+	"strconv"
+	"sync"
+	"unsafe"
+)
+
+type cipherKind int8
+
+const (
+	cipherAES128 cipherKind = iota
+	cipherAES192
+	cipherAES256
+	cipherDES
+	cipherDES3
+	cipherRC4
+)
+
+func (c cipherKind) String() string {
+	switch c {
+	case cipherAES128:
+		return "AES-128"
+	case cipherAES192:
+		return "AES-192"
+	case cipherAES256:
+		return "AES-256"
+	case cipherDES:
+		return "DES"
+	case cipherDES3:
+		return "DES3"
+	case cipherRC4:
+		return "RC4"
+	default:
+		panic("unknown cipher kind: " + strconv.Itoa(int(c)))
+	}
+}
+
+type cipherMode int8
+
+const (
+	cipherModeNone cipherMode = -1
+	cipherModeECB  cipherMode = iota
+	cipherModeCBC
+	cipherModeCTR
+	cipherModeGCM
+)
+
+// cipherOp is the allowed operations for a cipher,
+// as documented in [EVP_CipherInit_ex].
+//
+// [EVP_CipherInit_ex]: https://www.openssl.org/docs/man3.0/man3/EVP_CipherInit_ex.html
+type cipherOp int8
+
+const (
+	cipherOpNone    cipherOp = -1 // leaves the value of the previous call, if any.
+	cipherOpDecrypt cipherOp = 0
+	cipherOpEncrypt cipherOp = 1
+)
+
+// cacheCipher is a cache of cipherKind to GO_EVP_CIPHER_PTR.
+var cacheCipher sync.Map
+
+type cacheCipherKey struct {
+	kind cipherKind
+	mode cipherMode
+}
+
+// loadCipher returns a cipher object for the given k.
+func loadCipher(k cipherKind, mode cipherMode) (cipher C.GO_EVP_CIPHER_PTR) {
+	if v, ok := cacheCipher.Load(cacheCipherKey{k, mode}); ok {
+		return v.(C.GO_EVP_CIPHER_PTR)
+	}
+	defer func() {
+		if cipher != nil && vMajor == 3 {
+			// On OpenSSL 3, directly operating on a EVP_CIPHER object
+			// not created by EVP_CIPHER has negative performance
+			// implications, as cipher operations will have
+			// to fetch it on every call. Better to just fetch it once here.
+			cipher = C.go_openssl_EVP_CIPHER_fetch(nil, C.go_openssl_EVP_CIPHER_get0_name(cipher), nil)
+		}
+		cacheCipher.Store(cacheCipherKey{k, mode}, cipher)
+	}()
+	switch k {
+	case cipherAES128:
+		switch mode {
+		case cipherModeECB:
+			cipher = C.go_openssl_EVP_aes_128_ecb()
+		case cipherModeCBC:
+			cipher = C.go_openssl_EVP_aes_128_cbc()
+		case cipherModeCTR:
+			cipher = C.go_openssl_EVP_aes_128_ctr()
+		case cipherModeGCM:
+			cipher = C.go_openssl_EVP_aes_128_gcm()
+		}
+	case cipherAES192:
+		switch mode {
+		case cipherModeECB:
+			cipher = C.go_openssl_EVP_aes_192_ecb()
+		case cipherModeCBC:
+			cipher = C.go_openssl_EVP_aes_192_cbc()
+		case cipherModeCTR:
+			cipher = C.go_openssl_EVP_aes_192_ctr()
+		case cipherModeGCM:
+			cipher = C.go_openssl_EVP_aes_192_gcm()
+		}
+	case cipherAES256:
+		switch mode {
+		case cipherModeECB:
+			cipher = C.go_openssl_EVP_aes_256_ecb()
+		case cipherModeCBC:
+			cipher = C.go_openssl_EVP_aes_256_cbc()
+		case cipherModeCTR:
+			cipher = C.go_openssl_EVP_aes_256_ctr()
+		case cipherModeGCM:
+			cipher = C.go_openssl_EVP_aes_256_gcm()
+		}
+	case cipherDES:
+		switch mode {
+		case cipherModeECB:
+			cipher = C.go_openssl_EVP_des_ecb()
+		case cipherModeCBC:
+			cipher = C.go_openssl_EVP_des_cbc()
+		}
+	case cipherDES3:
+		switch mode {
+		case cipherModeECB:
+			cipher = C.go_openssl_EVP_des_ede3_ecb()
+		case cipherModeCBC:
+			cipher = C.go_openssl_EVP_des_ede3_cbc()
+		}
+	case cipherRC4:
+		cipher = C.go_openssl_EVP_rc4()
+	}
+	return cipher
+}
+
+type evpCipher struct {
+	key       []byte
+	kind      cipherKind
+	blockSize int
+}
+
+func newEVPCipher(key []byte, kind cipherKind) (*evpCipher, error) {
+	cipher := loadCipher(kind, cipherModeECB)
+	if cipher == nil {
+		return nil, errors.New("crypto/cipher: unsupported cipher: " + kind.String())
+	}
+	c := &evpCipher{key: make([]byte, len(key)), kind: kind}
+	copy(c.key, key)
+	c.blockSize = int(C.go_openssl_EVP_CIPHER_get_block_size(cipher))
+	return c, nil
+}
+
+func (c *evpCipher) encrypt(dst, src []byte) error {
+	if len(src) < c.blockSize {
+		return errors.New("input not full block")
+	}
+	if len(dst) < c.blockSize {
+		return errors.New("output not full block")
+	}
+	// Only check for overlap between the parts of src and dst that will actually be used.
+	// This matches Go standard library behavior.
+	if inexactOverlap(dst[:c.blockSize], src[:c.blockSize]) {
+		return errors.New("invalid buffer overlap")
+	}
+	enc_ctx, err := newCipherCtx(c.kind, cipherModeECB, cipherOpEncrypt, c.key, nil)
+	if err != nil {
+		return err
+	}
+	defer C.go_openssl_EVP_CIPHER_CTX_free(enc_ctx)
+
+	if C.go_openssl_EVP_EncryptUpdate_wrapper(enc_ctx, base(dst), base(src), C.int(c.blockSize)) != 1 {
+		return errors.New("EncryptUpdate failed")
+	}
+	runtime.KeepAlive(c)
+	return nil
+}
+
+func (c *evpCipher) decrypt(dst, src []byte) error {
+	if len(src) < c.blockSize {
+		return errors.New("input not full block")
+	}
+	if len(dst) < c.blockSize {
+		return errors.New("output not full block")
+	}
+	// Only check for overlap between the parts of src and dst that will actually be used.
+	// This matches Go standard library behavior.
+	if inexactOverlap(dst[:c.blockSize], src[:c.blockSize]) {
+		return errors.New("invalid buffer overlap")
+	}
+	dec_ctx, err := newCipherCtx(c.kind, cipherModeECB, cipherOpDecrypt, c.key, nil)
+	if err != nil {
+		return err
+	}
+	defer C.go_openssl_EVP_CIPHER_CTX_free(dec_ctx)
+
+	if C.go_openssl_EVP_CIPHER_CTX_set_padding(dec_ctx, 0) != 1 {
+		return errors.New("could not disable cipher padding")
+	}
+
+	C.go_openssl_EVP_DecryptUpdate_wrapper(dec_ctx, base(dst), base(src), C.int(c.blockSize))
+	runtime.KeepAlive(c)
+	return nil
+}
+
+type cipherCBC struct {
+	ctx       C.GO_EVP_CIPHER_CTX_PTR
+	blockSize int
+}
+
+func (c *cipherCBC) finalize() {
+	C.go_openssl_EVP_CIPHER_CTX_free(c.ctx)
+}
+
+func (x *cipherCBC) BlockSize() int { return x.blockSize }
+
+func (x *cipherCBC) CryptBlocks(dst, src []byte) {
+	if inexactOverlap(dst, src) {
+		panic("crypto/cipher: invalid buffer overlap")
+	}
+	if len(src)%x.blockSize != 0 {
+		panic("crypto/cipher: input not full blocks")
+	}
+	if len(dst) < len(src) {
+		panic("crypto/cipher: output smaller than input")
+	}
+	if len(src) > 0 {
+		if C.go_openssl_EVP_CipherUpdate_wrapper(x.ctx, base(dst), base(src), C.int(len(src))) != 1 {
+			panic("crypto/cipher: CipherUpdate failed")
+		}
+		runtime.KeepAlive(x)
+	}
+}
+
+func (x *cipherCBC) SetIV(iv []byte) {
+	if len(iv) != x.blockSize {
+		panic("cipher: incorrect length IV")
+	}
+	if C.go_openssl_EVP_CipherInit_ex(x.ctx, nil, nil, nil, base(iv), C.int(cipherOpNone)) != 1 {
+		panic("cipher: unable to initialize EVP cipher ctx")
+	}
+}
+
+func (c *evpCipher) newCBC(iv []byte, op cipherOp) cipher.BlockMode {
+	ctx, err := newCipherCtx(c.kind, cipherModeCBC, op, c.key, iv)
+	if err != nil {
+		panic(err)
+	}
+	x := &cipherCBC{ctx: ctx, blockSize: c.blockSize}
+	runtime.SetFinalizer(x, (*cipherCBC).finalize)
+	if C.go_openssl_EVP_CIPHER_CTX_set_padding(x.ctx, 0) != 1 {
+		panic("cipher: unable to set padding")
+	}
+	return x
+}
+
+type cipherCTR struct {
+	ctx C.GO_EVP_CIPHER_CTX_PTR
+}
+
+func (x *cipherCTR) XORKeyStream(dst, src []byte) {
+	if inexactOverlap(dst, src) {
+		panic("crypto/cipher: invalid buffer overlap")
+	}
+	if len(dst) < len(src) {
+		panic("crypto/cipher: output smaller than input")
+	}
+	if len(src) == 0 {
+		return
+	}
+	if C.go_openssl_EVP_EncryptUpdate_wrapper(x.ctx, base(dst), base(src), C.int(len(src))) != 1 {
+		panic("crypto/cipher: EncryptUpdate failed")
+	}
+	runtime.KeepAlive(x)
+}
+
+func (c *evpCipher) newCTR(iv []byte) cipher.Stream {
+	ctx, err := newCipherCtx(c.kind, cipherModeCTR, cipherOpEncrypt, c.key, iv)
+	if err != nil {
+		panic(err)
+	}
+	x := &cipherCTR{ctx: ctx}
+	runtime.SetFinalizer(x, (*cipherCTR).finalize)
+	return x
+}
+
+func (c *cipherCTR) finalize() {
+	C.go_openssl_EVP_CIPHER_CTX_free(c.ctx)
+}
+
+type cipherGCMTLS uint8
+
+const (
+	cipherGCMTLSNone cipherGCMTLS = iota
+	cipherGCMTLS12
+	cipherGCMTLS13
+)
+
+type cipherGCM struct {
+	c   *evpCipher
+	tls cipherGCMTLS
+	// minNextNonce is the minimum value that the next nonce can be, enforced by
+	// all TLS modes.
+	minNextNonce uint64
+	// mask is the nonce mask used in TLS 1.3 mode.
+	mask uint64
+	// maskInitialized is true if mask has been initialized. This happens during
+	// the first Seal. The initialized mask may be 0. Used by TLS 1.3 mode.
+	maskInitialized bool
+	blockSize       int
+}
+
+const (
+	gcmTagSize           = 16
+	gcmStandardNonceSize = 12
+	// TLS 1.2 additional data is constructed as:
+	//
+	//     additional_data = seq_num(8) + TLSCompressed.type(1) + TLSCompressed.version(2) + TLSCompressed.length(2);
+	gcmTls12AddSize = 13
+	// TLS 1.3 additional data is constructed as:
+	//
+	//     additional_data = TLSCiphertext.opaque_type(1) || TLSCiphertext.legacy_record_version(2) || TLSCiphertext.length(2)
+	gcmTls13AddSize      = 5
+	gcmTlsFixedNonceSize = 4
+)
+
+type noGCM struct {
+	*evpCipher
+}
+
+func (g *noGCM) BlockSize() int {
+	return g.blockSize
+}
+
+func (g *noGCM) Encrypt(dst, src []byte) {
+	g.encrypt(dst, src)
+}
+
+func (g *noGCM) Decrypt(dst, src []byte) {
+	g.decrypt(dst, src)
+}
+
+func (c *evpCipher) newGCMChecked(nonceSize, tagSize int) (cipher.AEAD, error) {
+	if nonceSize != gcmStandardNonceSize && tagSize != gcmTagSize {
+		return nil, errors.New("crypto/cipher: GCM tag and nonce sizes can't be non-standard at the same time")
+	}
+	// Fall back to standard library for GCM with non-standard nonce or tag size.
+	if nonceSize != gcmStandardNonceSize {
+		return cipher.NewGCMWithNonceSize(&noGCM{c}, nonceSize)
+	}
+	if tagSize != gcmTagSize {
+		return cipher.NewGCMWithTagSize(&noGCM{c}, tagSize)
+	}
+	return c.newGCM(cipherGCMTLSNone)
+}
+
+func (c *evpCipher) newGCM(tls cipherGCMTLS) (cipher.AEAD, error) {
+	g := &cipherGCM{c: c, tls: tls, blockSize: c.blockSize}
+	return g, nil
+}
+
+func (g *cipherGCM) NonceSize() int {
+	return gcmStandardNonceSize
+}
+
+func (g *cipherGCM) Overhead() int {
+	return gcmTagSize
+}
+
+func (g *cipherGCM) Seal(dst, nonce, plaintext, additionalData []byte) []byte {
+	if len(nonce) != gcmStandardNonceSize {
+		panic("cipher: incorrect nonce length given to GCM")
+	}
+	if uint64(len(plaintext)) > ((1<<32)-2)*uint64(g.blockSize) || len(plaintext)+gcmTagSize < len(plaintext) {
+		panic("cipher: message too large for GCM")
+	}
+	if len(dst)+len(plaintext)+gcmTagSize < len(dst) {
+		panic("cipher: message too large for buffer")
+	}
+	if g.tls != cipherGCMTLSNone {
+		if g.tls == cipherGCMTLS12 && len(additionalData) != gcmTls12AddSize {
+			panic("cipher: incorrect additional data length given to GCM TLS 1.2")
+		} else if g.tls == cipherGCMTLS13 && len(additionalData) != gcmTls13AddSize {
+			panic("cipher: incorrect additional data length given to GCM TLS 1.3")
+		}
+		counter := binary.BigEndian.Uint64(nonce[gcmTlsFixedNonceSize:])
+		if g.tls == cipherGCMTLS13 {
+			// In TLS 1.3, the counter in the nonce has a mask and requires
+			// further decoding.
+			if !g.maskInitialized {
+				// According to TLS 1.3 nonce construction details at
+				// https://tools.ietf.org/html/rfc8446#section-5.3:
+				//
+				//   the first record transmitted under a particular traffic
+				//   key MUST use sequence number 0.
+				//
+				//   The padded sequence number is XORed with [a mask].
+				//
+				//   The resulting quantity (of length iv_length) is used as
+				//   the per-record nonce.
+				//
+				// We need to convert from the given nonce to sequence numbers
+				// to keep track of minNextNonce and enforce the counter
+				// maximum. On the first call, we know counter^mask is 0^mask,
+				// so we can simply store it as the mask.
+				g.mask = counter
+				g.maskInitialized = true
+			}
+			counter ^= g.mask
+		}
+		// BoringCrypto enforces strictly monotonically increasing explicit nonces
+		// and to fail after 2^64 - 1 keys as per FIPS 140-2 IG A.5,
+		// but OpenSSL does not perform this check, so it is implemented here.
+		const maxUint64 = 1<<64 - 1
+		if counter == maxUint64 {
+			panic("cipher: nonce counter must be less than 2^64 - 1")
+		}
+		if counter < g.minNextNonce {
+			panic("cipher: nonce counter must be strictly monotonically increasing")
+		}
+		defer func() {
+			g.minNextNonce = counter + 1
+		}()
+	}
+
+	// Make room in dst to append plaintext+overhead.
+	ret, out := sliceForAppend(dst, len(plaintext)+gcmTagSize)
+
+	// Check delayed until now to make sure len(dst) is accurate.
+	if inexactOverlap(out, plaintext) {
+		panic("cipher: invalid buffer overlap")
+	}
+
+	ctx, err := newCipherCtx(g.c.kind, cipherModeGCM, cipherOpNone, g.c.key, nil)
+	if err != nil {
+		panic(err)
+	}
+	defer C.go_openssl_EVP_CIPHER_CTX_free(ctx)
+	// Encrypt additional data.
+	// When sealing a TLS payload, OpenSSL app sets the additional data using
+	// 'EVP_CIPHER_CTX_ctrl(g.ctx, C.EVP_CTRL_AEAD_TLS1_AAD, C.EVP_AEAD_TLS1_AAD_LEN, base(additionalData))'.
+	// This makes the explicit nonce component to monotonically increase on every Seal operation without
+	// relying in the explicit nonce being securely set externally,
+	// and it also gives some interesting speed gains.
+	// Unfortunately we can't use it because Go expects AEAD.Seal to honor the provided nonce.
+	if C.go_openssl_EVP_CIPHER_CTX_seal_wrapper(ctx, base(out), base(nonce),
+		base(plaintext), C.int(len(plaintext)),
+		base(additionalData), C.int(len(additionalData))) != 1 {
+
+		panic(fail("EVP_CIPHER_CTX_seal"))
+	}
+	runtime.KeepAlive(g)
+	return ret
+}
+
+var errOpen = errors.New("cipher: message authentication failed")
+
+func (g *cipherGCM) Open(dst, nonce, ciphertext, additionalData []byte) ([]byte, error) {
+	if len(nonce) != gcmStandardNonceSize {
+		panic("cipher: incorrect nonce length given to GCM")
+	}
+	if len(ciphertext) < gcmTagSize {
+		return nil, errOpen
+	}
+	if uint64(len(ciphertext)) > ((1<<32)-2)*uint64(g.blockSize)+gcmTagSize {
+		return nil, errOpen
+	}
+	// BoringCrypto does not do any TLS check when decrypting, neither do we.
+
+	tag := ciphertext[len(ciphertext)-gcmTagSize:]
+	ciphertext = ciphertext[:len(ciphertext)-gcmTagSize]
+
+	// Make room in dst to append ciphertext without tag.
+	ret, out := sliceForAppend(dst, len(ciphertext))
+
+	// Check delayed until now to make sure len(dst) is accurate.
+	if inexactOverlap(out, ciphertext) {
+		panic("cipher: invalid buffer overlap")
+	}
+
+	ctx, err := newCipherCtx(g.c.kind, cipherModeGCM, cipherOpNone, g.c.key, nil)
+	if err != nil {
+		return nil, err
+	}
+	defer C.go_openssl_EVP_CIPHER_CTX_free(ctx)
+	ok := C.go_openssl_EVP_CIPHER_CTX_open_wrapper(
+		ctx, base(out), base(nonce),
+		base(ciphertext), C.int(len(ciphertext)),
+		base(additionalData), C.int(len(additionalData)), base(tag))
+	runtime.KeepAlive(g)
+	if ok == 0 {
+		// Zero output buffer on error.
+		for i := range out {
+			out[i] = 0
+		}
+		return nil, errOpen
+	}
+	return ret, nil
+}
+
+// sliceForAppend is a mirror of crypto/cipher.sliceForAppend.
+func sliceForAppend(in []byte, n int) (head, tail []byte) {
+	if total := len(in) + n; cap(in) >= total {
+		head = in[:total]
+	} else {
+		head = make([]byte, total)
+		copy(head, in)
+	}
+	tail = head[len(in):]
+	return
+}
+
+func newCipherCtx(kind cipherKind, mode cipherMode, encrypt cipherOp, key, iv []byte) (_ C.GO_EVP_CIPHER_CTX_PTR, err error) {
+	cipher := loadCipher(kind, mode)
+	if cipher == nil {
+		panic("crypto/cipher: unsupported cipher: " + kind.String())
+	}
+	ctx := C.go_openssl_EVP_CIPHER_CTX_new()
+	if ctx == nil {
+		return nil, fail("unable to create EVP cipher ctx")
+	}
+	defer func() {
+		if err != nil {
+			C.go_openssl_EVP_CIPHER_CTX_free(ctx)
+		}
+	}()
+	if kind == cipherRC4 {
+		// RC4 cipher supports a variable key length.
+		// We need to set the key length before setting the key,
+		// and to do so we need to have an initialized cipher ctx.
+		if C.go_openssl_EVP_CipherInit_ex(ctx, cipher, nil, nil, nil, C.int(encrypt)) != 1 {
+			return nil, newOpenSSLError("EVP_CipherInit_ex")
+		}
+		if C.go_openssl_EVP_CIPHER_CTX_set_key_length(ctx, C.int(len(key))) != 1 {
+			return nil, newOpenSSLError("EVP_CIPHER_CTX_set_key_length")
+		}
+		// Pass nil to the next call to EVP_CipherInit_ex to avoid resetting ctx's cipher.
+		cipher = nil
+	}
+	if C.go_openssl_EVP_CipherInit_ex(ctx, cipher, nil, base(key), base(iv), C.int(encrypt)) != 1 {
+		return nil, newOpenSSLError("unable to initialize EVP cipher ctx")
+	}
+	return ctx, nil
+}
+
+// The following two functions are a mirror of golang.org/x/crypto/internal/subtle.
+
+func anyOverlap(x, y []byte) bool {
+	return len(x) > 0 && len(y) > 0 &&
+		uintptr(unsafe.Pointer(&x[0])) <= uintptr(unsafe.Pointer(&y[len(y)-1])) &&
+		uintptr(unsafe.Pointer(&y[0])) <= uintptr(unsafe.Pointer(&x[len(x)-1]))
+}
+
+func inexactOverlap(x, y []byte) bool {
+	if len(x) == 0 || len(y) == 0 || &x[0] == &y[0] {
+		return false
+	}
+	return anyOverlap(x, y)
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/des.go b/src/vendor/github.com/golang-fips/openssl/v2/des.go
new file mode 100644
index 0000000000..71b13333a2
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/des.go
@@ -0,0 +1,113 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"crypto/cipher"
+	"errors"
+)
+
+// SupportsDESCipher returns true if NewDESCipher is supported,
+// which uses ECB mode.
+// If CBC is also supported, then the returned cipher.Block
+// will also implement NewCBCEncrypter and NewCBCDecrypter.
+func SupportsDESCipher() bool {
+	// True for stock OpenSSL 1 w/o FIPS.
+	// False for stock OpenSSL 3 unless the legacy provider is available.
+	return (versionAtOrAbove(1, 1, 0) || !FIPS()) && loadCipher(cipherDES, cipherModeECB) != nil
+}
+
+// SupportsTripleDESCipher returns true if NewTripleDESCipher is supported,
+// which uses ECB mode.
+// If CBC is also supported, then the returned cipher.Block
+// will also implement NewCBCEncrypter and NewCBCDecrypter.
+func SupportsTripleDESCipher() bool {
+	// Should always be true for stock OpenSSL,
+	// even when using the FIPS provider.
+	return loadCipher(cipherDES3, cipherModeECB) != nil
+}
+
+func NewDESCipher(key []byte) (cipher.Block, error) {
+	if len(key) != 8 {
+		return nil, errors.New("crypto/des: invalid key size")
+	}
+	c, err := newEVPCipher(key, cipherDES)
+	if err != nil {
+		return nil, err
+	}
+	// Should always be true for stock OpenSSL.
+	if loadCipher(cipherDES, cipherModeCBC) == nil {
+		return &desCipherWithoutCBC{c}, nil
+	}
+	return &desCipher{c}, nil
+}
+
+func NewTripleDESCipher(key []byte) (cipher.Block, error) {
+	if len(key) != 24 {
+		return nil, errors.New("crypto/des: invalid key size")
+	}
+	c, err := newEVPCipher(key, cipherDES3)
+	if err != nil {
+		return nil, err
+	}
+	// Should always be true for stock OpenSSL.
+	if loadCipher(cipherDES, cipherModeCBC) != nil {
+		return &desCipherWithoutCBC{c}, nil
+	}
+	return &desCipher{c}, nil
+}
+
+type desExtraModes interface {
+	NewCBCEncrypter(iv []byte) cipher.BlockMode
+	NewCBCDecrypter(iv []byte) cipher.BlockMode
+}
+
+var _ desExtraModes = (*desCipher)(nil)
+
+type desCipher struct {
+	*evpCipher
+}
+
+func (c *desCipher) BlockSize() int {
+	return c.blockSize
+}
+
+func (c *desCipher) Encrypt(dst, src []byte) {
+	if err := c.encrypt(dst, src); err != nil {
+		// crypto/des expects that the panic message starts with "crypto/des: ".
+		panic("crypto/des: " + err.Error())
+	}
+}
+
+func (c *desCipher) Decrypt(dst, src []byte) {
+	if err := c.decrypt(dst, src); err != nil {
+		// crypto/des expects that the panic message starts with "crypto/des: ".
+		panic("crypto/des: " + err.Error())
+	}
+}
+
+func (c *desCipher) NewCBCEncrypter(iv []byte) cipher.BlockMode {
+	return c.newCBC(iv, cipherOpEncrypt)
+}
+
+func (c *desCipher) NewCBCDecrypter(iv []byte) cipher.BlockMode {
+	return c.newCBC(iv, cipherOpDecrypt)
+}
+
+type desCipherWithoutCBC struct {
+	*evpCipher
+}
+
+func (c *desCipherWithoutCBC) BlockSize() int {
+	return c.blockSize
+}
+
+func (c *desCipherWithoutCBC) Encrypt(dst, src []byte) {
+	c.encrypt(dst, src)
+}
+
+func (c *desCipherWithoutCBC) Decrypt(dst, src []byte) {
+	c.decrypt(dst, src)
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/ec.go b/src/vendor/github.com/golang-fips/openssl/v2/ec.go
new file mode 100644
index 0000000000..eac2f8bbee
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/ec.go
@@ -0,0 +1,59 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+
+var (
+	paramPubKey  = C.CString("pub")
+	paramPrivKey = C.CString("priv")
+	paramGroup   = C.CString("group")
+	paramECPubX  = C.CString("qx")
+	paramECPubY  = C.CString("qy")
+)
+
+func curveNID(curve string) (C.int, error) {
+	switch curve {
+	case "P-224":
+		return C.GO_NID_secp224r1, nil
+	case "P-256":
+		return C.GO_NID_X9_62_prime256v1, nil
+	case "P-384":
+		return C.GO_NID_secp384r1, nil
+	case "P-521":
+		return C.GO_NID_secp521r1, nil
+	}
+	return 0, errUnknownCurve
+}
+
+// encodeEcPoint encodes pt.
+func encodeEcPoint(group C.GO_EC_GROUP_PTR, pt C.GO_EC_POINT_PTR) ([]byte, error) {
+	// Get encoded point size.
+	n := C.go_openssl_EC_POINT_point2oct(group, pt, C.GO_POINT_CONVERSION_UNCOMPRESSED, nil, 0, nil)
+	if n == 0 {
+		return nil, newOpenSSLError("EC_POINT_point2oct")
+	}
+	// Encode point into bytes.
+	bytes := make([]byte, n)
+	n = C.go_openssl_EC_POINT_point2oct(group, pt, C.GO_POINT_CONVERSION_UNCOMPRESSED, base(bytes), n, nil)
+	if n == 0 {
+		return nil, newOpenSSLError("EC_POINT_point2oct")
+	}
+	return bytes, nil
+}
+
+// generateAndEncodeEcPublicKey calls newPubKeyPointFn to generate a public key point and then encodes it.
+func generateAndEncodeEcPublicKey(nid C.int, newPubKeyPointFn func(group C.GO_EC_GROUP_PTR) (C.GO_EC_POINT_PTR, error)) ([]byte, error) {
+	group := C.go_openssl_EC_GROUP_new_by_curve_name(nid)
+	if group == nil {
+		return nil, newOpenSSLError("EC_GROUP_new_by_curve_name")
+	}
+	defer C.go_openssl_EC_GROUP_free(group)
+	pt, err := newPubKeyPointFn(group)
+	if err != nil {
+		return nil, err
+	}
+	defer C.go_openssl_EC_POINT_free(pt)
+	return encodeEcPoint(group, pt)
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/ecdh.go b/src/vendor/github.com/golang-fips/openssl/v2/ecdh.go
new file mode 100644
index 0000000000..a1e627eff4
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/ecdh.go
@@ -0,0 +1,323 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"errors"
+	"runtime"
+	"unsafe"
+)
+
+type PublicKeyECDH struct {
+	_pkey C.GO_EVP_PKEY_PTR
+	bytes []byte
+}
+
+func (k *PublicKeyECDH) finalize() {
+	C.go_openssl_EVP_PKEY_free(k._pkey)
+}
+
+type PrivateKeyECDH struct {
+	_pkey        C.GO_EVP_PKEY_PTR
+	curve        string
+	hasPublicKey bool
+}
+
+func (k *PrivateKeyECDH) finalize() {
+	C.go_openssl_EVP_PKEY_free(k._pkey)
+}
+
+func NewPublicKeyECDH(curve string, bytes []byte) (*PublicKeyECDH, error) {
+	if len(bytes) < 1 {
+		return nil, errors.New("NewPublicKeyECDH: missing key")
+	}
+	pkey, err := newECDHPkey(curve, bytes, false)
+	if err != nil {
+		return nil, err
+	}
+	k := &PublicKeyECDH{pkey, append([]byte(nil), bytes...)}
+	runtime.SetFinalizer(k, (*PublicKeyECDH).finalize)
+	return k, nil
+}
+
+func (k *PublicKeyECDH) Bytes() []byte { return k.bytes }
+
+func NewPrivateKeyECDH(curve string, bytes []byte) (*PrivateKeyECDH, error) {
+	pkey, err := newECDHPkey(curve, bytes, true)
+	if err != nil {
+		return nil, err
+	}
+	k := &PrivateKeyECDH{pkey, curve, false}
+	runtime.SetFinalizer(k, (*PrivateKeyECDH).finalize)
+	return k, nil
+}
+
+func (k *PrivateKeyECDH) PublicKey() (*PublicKeyECDH, error) {
+	defer runtime.KeepAlive(k)
+	if !k.hasPublicKey {
+		err := deriveEcdhPublicKey(k._pkey, k.curve)
+		if err != nil {
+			return nil, err
+		}
+		k.hasPublicKey = true
+	}
+	var pkey C.GO_EVP_PKEY_PTR
+	defer func() {
+		C.go_openssl_EVP_PKEY_free(pkey)
+	}()
+
+	var bytes []byte
+	switch vMajor {
+	case 1:
+		pkey = C.go_openssl_EVP_PKEY_new()
+		if pkey == nil {
+			return nil, newOpenSSLError("EVP_PKEY_new")
+		}
+		key := getECKey(k._pkey)
+		if C.go_openssl_EVP_PKEY_set1_EC_KEY(pkey, key) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_set1_EC_KEY")
+		}
+		pt := C.go_openssl_EC_KEY_get0_public_key(key)
+		if pt == nil {
+			return nil, newOpenSSLError("EC_KEY_get0_public_key")
+		}
+		group := C.go_openssl_EC_KEY_get0_group(key)
+		var err error
+		bytes, err = encodeEcPoint(group, pt)
+		if err != nil {
+			return nil, err
+		}
+	case 3:
+		pkey = k._pkey
+		if C.go_openssl_EVP_PKEY_up_ref(pkey) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_up_ref")
+		}
+
+		var cbytes *C.uchar
+		n := C.go_openssl_EVP_PKEY_get1_encoded_public_key(k._pkey, &cbytes)
+		if n == 0 {
+			return nil, newOpenSSLError("EVP_PKEY_get_octet_string_param")
+		}
+		bytes = C.GoBytes(unsafe.Pointer(cbytes), C.int(n))
+		cryptoFree(unsafe.Pointer(cbytes))
+	default:
+		panic(errUnsupportedVersion())
+	}
+	pub := &PublicKeyECDH{pkey, bytes}
+	pkey = nil
+	runtime.SetFinalizer(pub, (*PublicKeyECDH).finalize)
+	return pub, nil
+}
+
+func newECDHPkey(curve string, bytes []byte, isPrivate bool) (C.GO_EVP_PKEY_PTR, error) {
+	nid, err := curveNID(curve)
+	if err != nil {
+		return nil, err
+	}
+	switch vMajor {
+	case 1:
+		return newECDHPkey1(nid, bytes, isPrivate)
+	case 3:
+		return newECDHPkey3(nid, bytes, isPrivate)
+	default:
+		panic(errUnsupportedVersion())
+	}
+}
+
+func newECDHPkey1(nid C.int, bytes []byte, isPrivate bool) (pkey C.GO_EVP_PKEY_PTR, err error) {
+	if vMajor != 1 {
+		panic("incorrect vMajor version")
+	}
+	key := C.go_openssl_EC_KEY_new_by_curve_name(nid)
+	if key == nil {
+		return nil, newOpenSSLError("EC_KEY_new_by_curve_name")
+	}
+	defer func() {
+		if pkey == nil {
+			C.go_openssl_EC_KEY_free(key)
+		}
+	}()
+	if isPrivate {
+		priv := C.go_openssl_BN_bin2bn(base(bytes), C.int(len(bytes)), nil)
+		if priv == nil {
+			return nil, newOpenSSLError("BN_bin2bn")
+		}
+		defer C.go_openssl_BN_clear_free(priv)
+		if C.go_openssl_EC_KEY_set_private_key(key, priv) != 1 {
+			return nil, newOpenSSLError("EC_KEY_set_private_key")
+		}
+	} else {
+		group := C.go_openssl_EC_KEY_get0_group(key)
+		pub := C.go_openssl_EC_POINT_new(group)
+		if pub == nil {
+			return nil, newOpenSSLError("EC_POINT_new")
+		}
+		defer C.go_openssl_EC_POINT_free(pub)
+		if C.go_openssl_EC_POINT_oct2point(group, pub, base(bytes), C.size_t(len(bytes)), nil) != 1 {
+			return nil, errors.New("point not on curve")
+		}
+		if C.go_openssl_EC_KEY_set_public_key(key, pub) != 1 {
+			return nil, newOpenSSLError("EC_KEY_set_public_key")
+		}
+	}
+	return newEVPPKEY(key)
+}
+
+func newECDHPkey3(nid C.int, bytes []byte, isPrivate bool) (C.GO_EVP_PKEY_PTR, error) {
+	if vMajor != 3 {
+		panic("incorrect vMajor version")
+	}
+	bld := C.go_openssl_OSSL_PARAM_BLD_new()
+	if bld == nil {
+		return nil, newOpenSSLError("OSSL_PARAM_BLD_new")
+	}
+	defer C.go_openssl_OSSL_PARAM_BLD_free(bld)
+	C.go_openssl_OSSL_PARAM_BLD_push_utf8_string(bld, paramGroup, C.go_openssl_OBJ_nid2sn(nid), 0)
+	var selection C.int
+	if isPrivate {
+		priv := C.go_openssl_BN_bin2bn(base(bytes), C.int(len(bytes)), nil)
+		if priv == nil {
+			return nil, newOpenSSLError("BN_bin2bn")
+		}
+		defer C.go_openssl_BN_clear_free(priv)
+		if C.go_openssl_OSSL_PARAM_BLD_push_BN(bld, paramPrivKey, priv) != 1 {
+			return nil, newOpenSSLError("OSSL_PARAM_BLD_push_BN")
+		}
+		selection = C.GO_EVP_PKEY_KEYPAIR
+	} else {
+		cbytes := C.CBytes(bytes)
+		defer C.free(cbytes)
+		C.go_openssl_OSSL_PARAM_BLD_push_octet_string(bld, paramPubKey, cbytes, C.size_t(len(bytes)))
+		selection = C.GO_EVP_PKEY_PUBLIC_KEY
+	}
+	params := C.go_openssl_OSSL_PARAM_BLD_to_param(bld)
+	if params == nil {
+		return nil, newOpenSSLError("OSSL_PARAM_BLD_to_param")
+	}
+	defer C.go_openssl_OSSL_PARAM_free(params)
+	return newEvpFromParams(C.GO_EVP_PKEY_EC, selection, params)
+}
+
+// deriveEcdhPublicKey sets the raw public key of pkey by deriving it from
+// the raw private key.
+func deriveEcdhPublicKey(pkey C.GO_EVP_PKEY_PTR, curve string) error {
+	derive := func(group C.GO_EC_GROUP_PTR, priv C.GO_BIGNUM_PTR) (C.GO_EC_POINT_PTR, error) {
+		// OpenSSL does not expose any method to generate the public
+		// key from the private key [1], so we have to calculate it here.
+		// [1] https://github.com/openssl/openssl/issues/18437#issuecomment-1144717206
+		pt := C.go_openssl_EC_POINT_new(group)
+		if pt == nil {
+			return nil, newOpenSSLError("EC_POINT_new")
+		}
+		if C.go_openssl_EC_POINT_mul(group, pt, priv, nil, nil, nil) == 0 {
+			C.go_openssl_EC_POINT_free(pt)
+			return nil, newOpenSSLError("EC_POINT_mul")
+		}
+		return pt, nil
+	}
+	switch vMajor {
+	case 1:
+		key := getECKey(pkey)
+		priv := C.go_openssl_EC_KEY_get0_private_key(key)
+		if priv == nil {
+			return newOpenSSLError("EC_KEY_get0_private_key")
+		}
+		group := C.go_openssl_EC_KEY_get0_group(key)
+		pub, err := derive(group, priv)
+		if err != nil {
+			return err
+		}
+		defer C.go_openssl_EC_POINT_free(pub)
+		if C.go_openssl_EC_KEY_set_public_key(key, pub) != 1 {
+			return newOpenSSLError("EC_KEY_set_public_key")
+		}
+	case 3:
+		var priv C.GO_BIGNUM_PTR
+		if C.go_openssl_EVP_PKEY_get_bn_param(pkey, paramPrivKey, &priv) != 1 {
+			return newOpenSSLError("EVP_PKEY_get_bn_param")
+		}
+		defer C.go_openssl_BN_clear_free(priv)
+		nid, _ := curveNID(curve)
+		pubBytes, err := generateAndEncodeEcPublicKey(nid, func(group C.GO_EC_GROUP_PTR) (C.GO_EC_POINT_PTR, error) {
+			return derive(group, priv)
+		})
+		if err != nil {
+			return err
+		}
+		if C.go_openssl_EVP_PKEY_set1_encoded_public_key(pkey, base(pubBytes), C.size_t(len(pubBytes))) != 1 {
+			return newOpenSSLError("EVP_PKEY_set1_encoded_public_key")
+		}
+	default:
+		panic(errUnsupportedVersion())
+	}
+	return nil
+}
+
+func ECDH(priv *PrivateKeyECDH, pub *PublicKeyECDH) ([]byte, error) {
+	defer runtime.KeepAlive(priv)
+	defer runtime.KeepAlive(pub)
+	ctx := C.go_openssl_EVP_PKEY_CTX_new(priv._pkey, nil)
+	if ctx == nil {
+		return nil, newOpenSSLError("EVP_PKEY_CTX_new")
+	}
+	defer C.go_openssl_EVP_PKEY_CTX_free(ctx)
+	if C.go_openssl_EVP_PKEY_derive_init(ctx) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive_init")
+	}
+	if C.go_openssl_EVP_PKEY_derive_set_peer(ctx, pub._pkey) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive_set_peer")
+	}
+	r := C.go_openssl_EVP_PKEY_derive_wrapper(ctx, nil, 0)
+	if r.result != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive_init")
+	}
+	out := make([]byte, r.keylen)
+	if C.go_openssl_EVP_PKEY_derive_wrapper(ctx, base(out), r.keylen).result != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive_init")
+	}
+	return out, nil
+}
+
+func GenerateKeyECDH(curve string) (*PrivateKeyECDH, []byte, error) {
+	pkey, err := generateEVPPKey(C.GO_EVP_PKEY_EC, 0, curve)
+	if err != nil {
+		return nil, nil, err
+	}
+	var k *PrivateKeyECDH
+	defer func() {
+		if k == nil {
+			C.go_openssl_EVP_PKEY_free(pkey)
+		}
+	}()
+	var priv C.GO_BIGNUM_PTR
+	switch vMajor {
+	case 1:
+		key := getECKey(pkey)
+		priv = C.go_openssl_EC_KEY_get0_private_key(key)
+		if priv == nil {
+			return nil, nil, newOpenSSLError("EC_KEY_get0_private_key")
+		}
+	case 3:
+		if C.go_openssl_EVP_PKEY_get_bn_param(pkey, paramPrivKey, &priv) != 1 {
+			return nil, nil, newOpenSSLError("EVP_PKEY_get_bn_param")
+		}
+		defer C.go_openssl_BN_clear_free(priv)
+	default:
+		panic(errUnsupportedVersion())
+	}
+	// We should not leak bit length of the secret scalar in the key.
+	// For this reason, we use BN_bn2binpad instead of BN_bn2bin with fixed length.
+	// The fixed length is the order of the large prime subgroup of the curve,
+	// returned by EVP_PKEY_get_bits, which is generally the upper bound for
+	// generating a private ECDH key.
+	bits := C.go_openssl_EVP_PKEY_get_bits(pkey)
+	bytes := make([]byte, (bits+7)/8)
+	if err := bnToBinPad(priv, bytes); err != nil {
+		return nil, nil, err
+	}
+	k = &PrivateKeyECDH{pkey, curve, true}
+	runtime.SetFinalizer(k, (*PrivateKeyECDH).finalize)
+	return k, bytes, nil
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/ecdsa.go b/src/vendor/github.com/golang-fips/openssl/v2/ecdsa.go
new file mode 100644
index 0000000000..46b16abf48
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/ecdsa.go
@@ -0,0 +1,217 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"crypto"
+	"errors"
+	"runtime"
+)
+
+type PrivateKeyECDSA struct {
+	// _pkey MUST NOT be accessed directly. Instead, use the withKey method.
+	_pkey C.GO_EVP_PKEY_PTR
+}
+
+func (k *PrivateKeyECDSA) finalize() {
+	C.go_openssl_EVP_PKEY_free(k._pkey)
+}
+
+func (k *PrivateKeyECDSA) withKey(f func(C.GO_EVP_PKEY_PTR) C.int) C.int {
+	defer runtime.KeepAlive(k)
+	return f(k._pkey)
+}
+
+type PublicKeyECDSA struct {
+	// _pkey MUST NOT be accessed directly. Instead, use the withKey method.
+	_pkey C.GO_EVP_PKEY_PTR
+}
+
+func (k *PublicKeyECDSA) finalize() {
+	C.go_openssl_EVP_PKEY_free(k._pkey)
+}
+
+func (k *PublicKeyECDSA) withKey(f func(C.GO_EVP_PKEY_PTR) C.int) C.int {
+	defer runtime.KeepAlive(k)
+	return f(k._pkey)
+}
+
+var errUnknownCurve = errors.New("openssl: unknown elliptic curve")
+
+func NewPublicKeyECDSA(curve string, X, Y BigInt) (*PublicKeyECDSA, error) {
+	pkey, err := newECDSAKey(curve, X, Y, nil)
+	if err != nil {
+		return nil, err
+	}
+	k := &PublicKeyECDSA{_pkey: pkey}
+	runtime.SetFinalizer(k, (*PublicKeyECDSA).finalize)
+	return k, nil
+}
+
+func NewPrivateKeyECDSA(curve string, X, Y, D BigInt) (*PrivateKeyECDSA, error) {
+	pkey, err := newECDSAKey(curve, X, Y, D)
+	if err != nil {
+		return nil, err
+	}
+	k := &PrivateKeyECDSA{_pkey: pkey}
+	runtime.SetFinalizer(k, (*PrivateKeyECDSA).finalize)
+	return k, nil
+}
+
+func GenerateKeyECDSA(curve string) (X, Y, D BigInt, err error) {
+	// Generate the private key.
+	pkey, err := generateEVPPKey(C.GO_EVP_PKEY_EC, 0, curve)
+	if err != nil {
+		return nil, nil, nil, err
+	}
+	defer C.go_openssl_EVP_PKEY_free(pkey)
+
+	var bx, by, bd C.GO_BIGNUM_PTR
+	defer func() {
+		C.go_openssl_BN_free(bx)
+		C.go_openssl_BN_free(by)
+	}()
+	switch vMajor {
+	case 1:
+		// Retrieve the internal EC_KEY, which holds the X, Y, and D coordinates.
+		key := getECKey(pkey)
+		group := C.go_openssl_EC_KEY_get0_group(key)
+		pt := C.go_openssl_EC_KEY_get0_public_key(key)
+		// Allocate two big numbers to store the X and Y coordinates.
+		bx, by = C.go_openssl_BN_new(), C.go_openssl_BN_new()
+		if bx == nil || by == nil {
+			return nil, nil, nil, newOpenSSLError("BN_new failed")
+		}
+		// Get X and Y.
+		if C.go_openssl_EC_POINT_get_affine_coordinates_GFp(group, pt, bx, by, nil) == 0 {
+			return nil, nil, nil, newOpenSSLError("EC_POINT_get_affine_coordinates_GFp failed")
+		}
+		// Get Z. We don't need to free it, get0 does not increase the reference count.
+		bd = C.go_openssl_EC_KEY_get0_private_key(key)
+	case 3:
+		if C.go_openssl_EVP_PKEY_get_bn_param(pkey, paramECPubX, &bx) != 1 ||
+			C.go_openssl_EVP_PKEY_get_bn_param(pkey, paramECPubY, &by) != 1 ||
+			C.go_openssl_EVP_PKEY_get_bn_param(pkey, paramPrivKey, &bd) != 1 {
+			return nil, nil, nil, newOpenSSLError("EVP_PKEY_get_bn_param")
+		}
+		defer C.go_openssl_BN_clear_free(bd)
+	default:
+		panic(errUnsupportedVersion())
+	}
+
+	// Get D.
+	return bnToBig(bx), bnToBig(by), bnToBig(bd), nil
+}
+
+func SignMarshalECDSA(priv *PrivateKeyECDSA, hash []byte) ([]byte, error) {
+	return evpSign(priv.withKey, 0, 0, 0, hash)
+}
+
+func HashSignECDSA(priv *PrivateKeyECDSA, h crypto.Hash, msg []byte) ([]byte, error) {
+	return evpHashSign(priv.withKey, h, msg)
+}
+
+func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, sig []byte) bool {
+	return evpVerify(pub.withKey, 0, 0, 0, sig, hash) == nil
+}
+
+func HashVerifyECDSA(pub *PublicKeyECDSA, h crypto.Hash, msg, sig []byte) bool {
+	return evpHashVerify(pub.withKey, h, msg, sig) == nil
+}
+
+func newECDSAKey(curve string, X, Y, D BigInt) (C.GO_EVP_PKEY_PTR, error) {
+	nid, err := curveNID(curve)
+	if err != nil {
+		return nil, err
+	}
+	var bx, by, bd C.GO_BIGNUM_PTR
+	defer func() {
+		C.go_openssl_BN_free(bx)
+		C.go_openssl_BN_free(by)
+		C.go_openssl_BN_clear_free(bd)
+	}()
+	bx = bigToBN(X)
+	by = bigToBN(Y)
+	bd = bigToBN(D)
+	if bx == nil || by == nil || (D != nil && bd == nil) {
+		return nil, newOpenSSLError("BN_lebin2bn failed")
+	}
+	switch vMajor {
+	case 1:
+		return newECDSAKey1(nid, bx, by, bd)
+	case 3:
+		return newECDSAKey3(nid, bx, by, bd)
+	default:
+		panic(errUnsupportedVersion())
+	}
+}
+
+func newECDSAKey1(nid C.int, bx, by, bd C.GO_BIGNUM_PTR) (pkey C.GO_EVP_PKEY_PTR, err error) {
+	if vMajor != 1 {
+		panic("incorrect vMajor version")
+	}
+	key := C.go_openssl_EC_KEY_new_by_curve_name(nid)
+	if key == nil {
+		return nil, newOpenSSLError("EC_KEY_new_by_curve_name failed")
+	}
+	defer func() {
+		if pkey == nil {
+			defer C.go_openssl_EC_KEY_free(key)
+		}
+	}()
+	if C.go_openssl_EC_KEY_set_public_key_affine_coordinates(key, bx, by) != 1 {
+		return nil, newOpenSSLError("EC_KEY_set_public_key_affine_coordinates failed")
+	}
+	if bd != nil && C.go_openssl_EC_KEY_set_private_key(key, bd) != 1 {
+		return nil, newOpenSSLError("EC_KEY_set_private_key failed")
+	}
+	return newEVPPKEY(key)
+}
+
+func newECDSAKey3(nid C.int, bx, by, bd C.GO_BIGNUM_PTR) (C.GO_EVP_PKEY_PTR, error) {
+	if vMajor != 3 {
+		panic("incorrect vMajor version")
+	}
+	// Create the encoded public key public key from bx and by.
+	pubBytes, err := generateAndEncodeEcPublicKey(nid, func(group C.GO_EC_GROUP_PTR) (C.GO_EC_POINT_PTR, error) {
+		pt := C.go_openssl_EC_POINT_new(group)
+		if pt == nil {
+			return nil, newOpenSSLError("EC_POINT_new")
+		}
+		if C.go_openssl_EC_POINT_set_affine_coordinates(group, pt, bx, by, nil) != 1 {
+			C.go_openssl_EC_POINT_free(pt)
+			return nil, newOpenSSLError("EC_POINT_set_affine_coordinates")
+		}
+		return pt, nil
+	})
+	if err != nil {
+		return nil, err
+	}
+	// Construct the parameters.
+	bld := C.go_openssl_OSSL_PARAM_BLD_new()
+	if bld == nil {
+		return nil, newOpenSSLError("OSSL_PARAM_BLD_new")
+	}
+	defer C.go_openssl_OSSL_PARAM_BLD_free(bld)
+	C.go_openssl_OSSL_PARAM_BLD_push_utf8_string(bld, paramGroup, C.go_openssl_OBJ_nid2sn(nid), 0)
+	cbytes := C.CBytes(pubBytes)
+	defer C.free(cbytes)
+	C.go_openssl_OSSL_PARAM_BLD_push_octet_string(bld, paramPubKey, cbytes, C.size_t(len(pubBytes)))
+	var selection C.int
+	if bd != nil {
+		if C.go_openssl_OSSL_PARAM_BLD_push_BN(bld, paramPrivKey, bd) != 1 {
+			return nil, newOpenSSLError("OSSL_PARAM_BLD_push_BN")
+		}
+		selection = C.GO_EVP_PKEY_KEYPAIR
+	} else {
+		selection = C.GO_EVP_PKEY_PUBLIC_KEY
+	}
+	params := C.go_openssl_OSSL_PARAM_BLD_to_param(bld)
+	if params == nil {
+		return nil, newOpenSSLError("OSSL_PARAM_BLD_to_param")
+	}
+	defer C.go_openssl_OSSL_PARAM_free(params)
+	return newEvpFromParams(C.GO_EVP_PKEY_EC, selection, params)
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/ed25519.go b/src/vendor/github.com/golang-fips/openssl/v2/ed25519.go
new file mode 100644
index 0000000000..f74bd8f8d7
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/ed25519.go
@@ -0,0 +1,218 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"errors"
+	"runtime"
+	"strconv"
+	"sync"
+	"unsafe"
+)
+
+const (
+	// publicKeySizeEd25519 is the size, in bytes, of public keys as used in crypto/ed25519.
+	publicKeySizeEd25519 = 32
+	// privateKeySizeEd25519 is the size, in bytes, of private keys as used in crypto/ed25519.
+	privateKeySizeEd25519 = 64
+	// signatureSizeEd25519 is the size, in bytes, of signatures generated and verified by crypto/ed25519.
+	signatureSizeEd25519 = 64
+	// seedSizeEd25519 is the size, in bytes, of private key seeds. These are the private key representations used by RFC 8032.
+	seedSizeEd25519 = 32
+)
+
+// TODO: Add support for Ed25519ph and Ed25519ctx when OpenSSL supports them,
+// which will probably be in 3.2.0 (https://github.com/openssl/openssl/issues/20418).
+
+var (
+	onceSupportsEd25519 sync.Once
+	supportsEd25519     bool
+)
+
+// SupportsEd25519 returns true if the current OpenSSL version supports
+// GenerateKeyEd25519, NewKeyFromSeedEd25519, SignEd25519 and VerifyEd25519.
+func SupportsEd25519() bool {
+	onceSupportsEd25519.Do(func() {
+		switch vMajor {
+		case 1:
+			supportsEd25519 = versionAtOrAbove(1, 1, 1)
+		case 3:
+			name := C.CString("ED25519")
+			defer C.free(unsafe.Pointer(name))
+			sig := C.go_openssl_EVP_SIGNATURE_fetch(nil, name, nil)
+			if sig != nil {
+				C.go_openssl_EVP_SIGNATURE_free(sig)
+				supportsEd25519 = true
+			}
+		}
+	})
+	return supportsEd25519
+}
+
+type PublicKeyEd25519 struct {
+	_pkey C.GO_EVP_PKEY_PTR
+}
+
+func (k *PublicKeyEd25519) finalize() {
+	C.go_openssl_EVP_PKEY_free(k._pkey)
+}
+
+func (k *PublicKeyEd25519) Bytes() ([]byte, error) {
+	defer runtime.KeepAlive(k)
+	pub := make([]byte, publicKeySizeEd25519)
+	if err := extractPKEYPubEd25519(k._pkey, pub); err != nil {
+		return nil, err
+	}
+	return pub, nil
+}
+
+type PrivateKeyEd25519 struct {
+	_pkey C.GO_EVP_PKEY_PTR
+}
+
+func (k *PrivateKeyEd25519) finalize() {
+	C.go_openssl_EVP_PKEY_free(k._pkey)
+}
+
+func (k *PrivateKeyEd25519) Bytes() ([]byte, error) {
+	defer runtime.KeepAlive(k)
+	priv := make([]byte, privateKeySizeEd25519)
+	if err := extractPKEYPrivEd25519(k._pkey, priv); err != nil {
+		return nil, err
+	}
+	return priv, nil
+}
+
+func (k *PrivateKeyEd25519) Public() (*PublicKeyEd25519, error) {
+	pub := make([]byte, publicKeySizeEd25519)
+	if err := extractPKEYPubEd25519(k._pkey, pub); err != nil {
+		return nil, err
+	}
+	pubk, err := NewPublicKeyEd25119(pub)
+	if err != nil {
+		return nil, err
+	}
+	return pubk, nil
+}
+
+// GenerateKeyEd25519 generates a private key.
+func GenerateKeyEd25519() (*PrivateKeyEd25519, error) {
+	pkeyPriv, err := generateEVPPKey(C.GO_EVP_PKEY_ED25519, 0, "")
+	if err != nil {
+		return nil, err
+	}
+	priv := &PrivateKeyEd25519{_pkey: pkeyPriv}
+	runtime.SetFinalizer(priv, (*PrivateKeyEd25519).finalize)
+	return priv, nil
+}
+
+func NewPrivateKeyEd25119(priv []byte) (*PrivateKeyEd25519, error) {
+	if len(priv) != privateKeySizeEd25519 {
+		panic("ed25519: bad private key length: " + strconv.Itoa(len(priv)))
+	}
+	return NewPrivateKeyEd25519FromSeed(priv[:seedSizeEd25519])
+}
+
+func NewPublicKeyEd25119(pub []byte) (*PublicKeyEd25519, error) {
+	if len(pub) != publicKeySizeEd25519 {
+		panic("ed25519: bad public key length: " + strconv.Itoa(len(pub)))
+	}
+	pkey := C.go_openssl_EVP_PKEY_new_raw_public_key(C.GO_EVP_PKEY_ED25519, nil, base(pub), C.size_t(len(pub)))
+	if pkey == nil {
+		return nil, newOpenSSLError("EVP_PKEY_new_raw_public_key")
+	}
+	pubk := &PublicKeyEd25519{_pkey: pkey}
+	runtime.SetFinalizer(pubk, (*PublicKeyEd25519).finalize)
+	return pubk, nil
+}
+
+// NewPrivateKeyEd25519FromSeed calculates a private key from a seed. It will panic if
+// len(seed) is not [SeedSize]. RFC 8032's private keys correspond to seeds in this
+// package.
+func NewPrivateKeyEd25519FromSeed(seed []byte) (*PrivateKeyEd25519, error) {
+	if len(seed) != seedSizeEd25519 {
+		panic("ed25519: bad seed length: " + strconv.Itoa(len(seed)))
+	}
+	pkey := C.go_openssl_EVP_PKEY_new_raw_private_key(C.GO_EVP_PKEY_ED25519, nil, base(seed), C.size_t(len(seed)))
+	if pkey == nil {
+		return nil, newOpenSSLError("EVP_PKEY_new_raw_private_key")
+	}
+	priv := &PrivateKeyEd25519{_pkey: pkey}
+	runtime.SetFinalizer(priv, (*PrivateKeyEd25519).finalize)
+	return priv, nil
+}
+
+func extractPKEYPubEd25519(pkey C.GO_EVP_PKEY_PTR, pub []byte) error {
+	r := C.go_openssl_EVP_PKEY_get_raw_public_key_wrapper(pkey, base(pub), C.size_t(publicKeySizeEd25519))
+	if r.result != 1 {
+		return newOpenSSLError("EVP_PKEY_get_raw_public_key")
+	}
+	if r.len != publicKeySizeEd25519 {
+		return errors.New("ed25519: bad public key length: " + strconv.Itoa(int(r.len)))
+	}
+	return nil
+}
+
+func extractPKEYPrivEd25519(pkey C.GO_EVP_PKEY_PTR, priv []byte) error {
+	if err := extractPKEYPubEd25519(pkey, priv[seedSizeEd25519:]); err != nil {
+		return err
+	}
+	r := C.go_openssl_EVP_PKEY_get_raw_private_key_wrapper(pkey, base(priv), C.size_t(seedSizeEd25519))
+	if r.result != 1 {
+		return newOpenSSLError("EVP_PKEY_get_raw_private_key")
+	}
+	if r.len != seedSizeEd25519 {
+		return errors.New("ed25519: bad private key length: " + strconv.Itoa(int(r.len)))
+	}
+	return nil
+}
+
+// SignEd25519 signs the message with priv and returns a signature.
+func SignEd25519(priv *PrivateKeyEd25519, message []byte) (sig []byte, err error) {
+	// Outline the function body so that the returned key can be stack-allocated.
+	sig = make([]byte, signatureSizeEd25519)
+	err = signEd25519(priv, sig, message)
+	if err != nil {
+		return nil, err
+	}
+	return sig, err
+}
+
+func signEd25519(priv *PrivateKeyEd25519, sig, message []byte) error {
+	defer runtime.KeepAlive(priv)
+	ctx := C.go_openssl_EVP_MD_CTX_new()
+	if ctx == nil {
+		return newOpenSSLError("EVP_MD_CTX_new")
+	}
+	defer C.go_openssl_EVP_MD_CTX_free(ctx)
+	if C.go_openssl_EVP_DigestSignInit(ctx, nil, nil, nil, priv._pkey) != 1 {
+		return newOpenSSLError("EVP_DigestSignInit")
+	}
+	r := C.go_openssl_EVP_DigestSign_wrapper(ctx, base(sig), C.size_t(signatureSizeEd25519), base(message), C.size_t(len(message)))
+	if r.result != 1 {
+		return newOpenSSLError("EVP_DigestSign")
+	}
+	if r.siglen != signatureSizeEd25519 {
+		return errors.New("ed25519: bad signature length: " + strconv.Itoa(int(r.siglen)))
+	}
+	return nil
+}
+
+// VerifyEd25519 reports whether sig is a valid signature of message by pub.
+func VerifyEd25519(pub *PublicKeyEd25519, message, sig []byte) error {
+	defer runtime.KeepAlive(pub)
+	ctx := C.go_openssl_EVP_MD_CTX_new()
+	if ctx == nil {
+		return newOpenSSLError("EVP_MD_CTX_new")
+	}
+	defer C.go_openssl_EVP_MD_CTX_free(ctx)
+	if C.go_openssl_EVP_DigestVerifyInit(ctx, nil, nil, nil, pub._pkey) != 1 {
+		return newOpenSSLError("EVP_DigestVerifyInit")
+	}
+	if C.go_openssl_EVP_DigestVerify(ctx, base(sig), C.size_t(len(sig)), base(message), C.size_t(len(message))) != 1 {
+		return errors.New("ed25519: invalid signature")
+	}
+	return nil
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/evp.go b/src/vendor/github.com/golang-fips/openssl/v2/evp.go
new file mode 100644
index 0000000000..a9237a6a0c
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/evp.go
@@ -0,0 +1,471 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"crypto"
+	"errors"
+	"hash"
+	"strconv"
+	"sync"
+	"unsafe"
+)
+
+// cacheMD is a cache of crypto.Hash to GO_EVP_MD_PTR.
+var cacheMD sync.Map
+
+// hashToMD converts a hash.Hash implementation from this package to a GO_EVP_MD_PTR.
+func hashToMD(h hash.Hash) C.GO_EVP_MD_PTR {
+	var ch crypto.Hash
+	switch h.(type) {
+	case *sha1Hash:
+		ch = crypto.SHA1
+	case *sha224Hash:
+		ch = crypto.SHA224
+	case *sha256Hash:
+		ch = crypto.SHA256
+	case *sha384Hash:
+		ch = crypto.SHA384
+	case *sha512Hash:
+		ch = crypto.SHA512
+	case *sha3_224Hash:
+		ch = crypto.SHA3_224
+	case *sha3_256Hash:
+		ch = crypto.SHA3_256
+	case *sha3_384Hash:
+		ch = crypto.SHA3_384
+	case *sha3_512Hash:
+		ch = crypto.SHA3_512
+	}
+	if ch != 0 {
+		return cryptoHashToMD(ch)
+	}
+	return nil
+}
+
+// cryptoHashToMD converts a crypto.Hash to a GO_EVP_MD_PTR.
+func cryptoHashToMD(ch crypto.Hash) (md C.GO_EVP_MD_PTR) {
+	if v, ok := cacheMD.Load(ch); ok {
+		return v.(C.GO_EVP_MD_PTR)
+	}
+	defer func() {
+		if md != nil && vMajor == 3 {
+			// On OpenSSL 3, directly operating on a EVP_MD object
+			// not created by EVP_MD_fetch has negative performance
+			// implications, as digest operations will have
+			// to fetch it on every call. Better to just fetch it once here.
+			md = C.go_openssl_EVP_MD_fetch(nil, C.go_openssl_EVP_MD_get0_name(md), nil)
+		}
+		cacheMD.Store(ch, md)
+	}()
+	// SupportsHash returns false for MD5SHA1 because we don't
+	// provide a hash.Hash implementation for it. Yet, it can
+	// still be used when signing/verifying with an RSA key.
+	if ch == crypto.MD5SHA1 {
+		if vMajor == 1 && vMinor == 0 {
+			return C.go_openssl_EVP_md5_sha1_backport()
+		} else {
+			return C.go_openssl_EVP_md5_sha1()
+		}
+	}
+	switch ch {
+	case crypto.MD4:
+		if versionAtOrAbove(1, 1, 0) || !FIPS() {
+			return C.go_openssl_EVP_md4()
+		}
+	case crypto.MD5:
+		if versionAtOrAbove(1, 1, 0) || !FIPS() {
+			return C.go_openssl_EVP_md5()
+		}
+	case crypto.SHA1:
+		return C.go_openssl_EVP_sha1()
+	case crypto.SHA224:
+		return C.go_openssl_EVP_sha224()
+	case crypto.SHA256:
+		return C.go_openssl_EVP_sha256()
+	case crypto.SHA384:
+		return C.go_openssl_EVP_sha384()
+	case crypto.SHA512:
+		return C.go_openssl_EVP_sha512()
+	case crypto.SHA3_224:
+		if versionAtOrAbove(1, 1, 1) {
+			return C.go_openssl_EVP_sha3_224()
+		}
+	case crypto.SHA3_256:
+		if versionAtOrAbove(1, 1, 1) {
+			return C.go_openssl_EVP_sha3_256()
+		}
+	case crypto.SHA3_384:
+		if versionAtOrAbove(1, 1, 1) {
+			return C.go_openssl_EVP_sha3_384()
+		}
+	case crypto.SHA3_512:
+		if versionAtOrAbove(1, 1, 1) {
+			return C.go_openssl_EVP_sha3_512()
+		}
+	}
+	return nil
+}
+
+func generateEVPPKey(id C.int, bits int, curve string) (C.GO_EVP_PKEY_PTR, error) {
+	if bits != 0 && curve != "" {
+		return nil, fail("incorrect generateEVPPKey parameters")
+	}
+	ctx := C.go_openssl_EVP_PKEY_CTX_new_id(id, nil)
+	if ctx == nil {
+		return nil, newOpenSSLError("EVP_PKEY_CTX_new_id failed")
+	}
+	defer C.go_openssl_EVP_PKEY_CTX_free(ctx)
+	if C.go_openssl_EVP_PKEY_keygen_init(ctx) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_keygen_init failed")
+	}
+	if bits != 0 {
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, id, -1, C.GO_EVP_PKEY_CTRL_RSA_KEYGEN_BITS, C.int(bits), nil) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+		}
+	}
+	if curve != "" {
+		nid, err := curveNID(curve)
+		if err != nil {
+			return nil, err
+		}
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, id, -1, C.GO_EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID, nid, nil) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+		}
+	}
+	var pkey C.GO_EVP_PKEY_PTR
+	if C.go_openssl_EVP_PKEY_keygen(ctx, &pkey) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_keygen failed")
+	}
+	return pkey, nil
+}
+
+type withKeyFunc func(func(C.GO_EVP_PKEY_PTR) C.int) C.int
+type initFunc func(C.GO_EVP_PKEY_CTX_PTR) error
+type cryptFunc func(C.GO_EVP_PKEY_CTX_PTR, *C.uchar, *C.size_t, *C.uchar, C.size_t) error
+type verifyFunc func(C.GO_EVP_PKEY_CTX_PTR, *C.uchar, C.size_t, *C.uchar, C.size_t) error
+
+func setupEVP(withKey withKeyFunc, padding C.int,
+	h, mgfHash hash.Hash, label []byte, saltLen C.int, ch crypto.Hash,
+	init initFunc) (_ C.GO_EVP_PKEY_CTX_PTR, err error) {
+	var ctx C.GO_EVP_PKEY_CTX_PTR
+	withKey(func(pkey C.GO_EVP_PKEY_PTR) C.int {
+		ctx = C.go_openssl_EVP_PKEY_CTX_new(pkey, nil)
+		return 1
+	})
+	if ctx == nil {
+		return nil, newOpenSSLError("EVP_PKEY_CTX_new failed")
+	}
+	defer func() {
+		if err != nil {
+			if ctx != nil {
+				C.go_openssl_EVP_PKEY_CTX_free(ctx)
+				ctx = nil
+			}
+		}
+	}()
+	if err := init(ctx); err != nil {
+		return nil, err
+	}
+	if padding == 0 {
+		return ctx, nil
+	}
+	// Each padding type has its own requirements in terms of when to apply the padding,
+	// so it can't be just set at this point.
+	setPadding := func() error {
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_PADDING, padding, nil) != 1 {
+			return newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+		}
+		return nil
+	}
+	switch padding {
+	case C.GO_RSA_PKCS1_OAEP_PADDING:
+		md := hashToMD(h)
+		if md == nil {
+			return nil, errors.New("crypto/rsa: unsupported hash function")
+		}
+		var mgfMD C.GO_EVP_MD_PTR
+		if mgfHash != nil {
+			// mgfHash is optional, but if it is set it must match a supported hash function.
+			mgfMD = hashToMD(mgfHash)
+			if mgfMD == nil {
+				return nil, errors.New("crypto/rsa: unsupported hash function")
+			}
+		}
+		// setPadding must happen before setting EVP_PKEY_CTRL_RSA_OAEP_MD.
+		if err := setPadding(); err != nil {
+			return nil, err
+		}
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_OAEP_MD, 0, unsafe.Pointer(md)) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+		}
+		if mgfHash != nil {
+			if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_MGF1_MD, 0, unsafe.Pointer(mgfMD)) != 1 {
+				return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+			}
+		}
+		// ctx takes ownership of label, so malloc a copy for OpenSSL to free.
+		// OpenSSL does not take ownership of the label if the length is zero,
+		// so better avoid the allocation.
+		var clabel *C.uchar
+		if len(label) > 0 {
+			clabel = (*C.uchar)(cryptoMalloc(len(label)))
+			copy((*[1 << 30]byte)(unsafe.Pointer(clabel))[:len(label)], label)
+			var err error
+			if vMajor == 3 {
+				ret := C.go_openssl_EVP_PKEY_CTX_set0_rsa_oaep_label(ctx, unsafe.Pointer(clabel), C.int(len(label)))
+				if ret != 1 {
+					err = newOpenSSLError("EVP_PKEY_CTX_set0_rsa_oaep_label failed")
+				}
+			} else {
+				ret := C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_OAEP_LABEL, C.int(len(label)), unsafe.Pointer(clabel))
+				if ret != 1 {
+					err = newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+				}
+			}
+			if err != nil {
+				cryptoFree(unsafe.Pointer(clabel))
+				return nil, err
+			}
+		}
+	case C.GO_RSA_PKCS1_PSS_PADDING:
+		md := cryptoHashToMD(ch)
+		if md == nil {
+			return nil, errors.New("crypto/rsa: unsupported hash function")
+		}
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_MD, 0, unsafe.Pointer(md)) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+		}
+		// setPadding must happen after setting EVP_PKEY_CTRL_MD.
+		if err := setPadding(); err != nil {
+			return nil, err
+		}
+		if saltLen != 0 {
+			if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, C.GO_EVP_PKEY_RSA, -1, C.GO_EVP_PKEY_CTRL_RSA_PSS_SALTLEN, saltLen, nil) != 1 {
+				return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+			}
+		}
+
+	case C.GO_RSA_PKCS1_PADDING:
+		if ch != 0 {
+			// We support unhashed messages.
+			md := cryptoHashToMD(ch)
+			if md == nil {
+				return nil, errors.New("crypto/rsa: unsupported hash function")
+			}
+			if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, -1, -1, C.GO_EVP_PKEY_CTRL_MD, 0, unsafe.Pointer(md)) != 1 {
+				return nil, newOpenSSLError("EVP_PKEY_CTX_ctrl failed")
+			}
+			if err := setPadding(); err != nil {
+				return nil, err
+			}
+		}
+	default:
+		if err := setPadding(); err != nil {
+			return nil, err
+		}
+	}
+	return ctx, nil
+}
+
+func cryptEVP(withKey withKeyFunc, padding C.int,
+	h, mgfHash hash.Hash, label []byte, saltLen C.int, ch crypto.Hash,
+	init initFunc, crypt cryptFunc, in []byte) ([]byte, error) {
+
+	ctx, err := setupEVP(withKey, padding, h, mgfHash, label, saltLen, ch, init)
+	if err != nil {
+		return nil, err
+	}
+	defer C.go_openssl_EVP_PKEY_CTX_free(ctx)
+	pkeySize := withKey(func(pkey C.GO_EVP_PKEY_PTR) C.int {
+		return C.go_openssl_EVP_PKEY_get_size(pkey)
+	})
+	outLen := C.size_t(pkeySize)
+	out := make([]byte, pkeySize)
+	if err := crypt(ctx, base(out), &outLen, base(in), C.size_t(len(in))); err != nil {
+		return nil, err
+	}
+	// The size returned by EVP_PKEY_get_size() is only preliminary and not exact,
+	// so the final contents of the out buffer may be smaller.
+	return out[:outLen], nil
+}
+
+func verifyEVP(withKey withKeyFunc, padding C.int,
+	h hash.Hash, label []byte, saltLen C.int, ch crypto.Hash,
+	init initFunc, verify verifyFunc,
+	sig, in []byte) error {
+
+	ctx, err := setupEVP(withKey, padding, h, nil, label, saltLen, ch, init)
+	if err != nil {
+		return err
+	}
+	defer C.go_openssl_EVP_PKEY_CTX_free(ctx)
+	return verify(ctx, base(sig), C.size_t(len(sig)), base(in), C.size_t(len(in)))
+}
+
+func evpEncrypt(withKey withKeyFunc, padding C.int, h, mgfHash hash.Hash, label, msg []byte) ([]byte, error) {
+	encryptInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {
+		if ret := C.go_openssl_EVP_PKEY_encrypt_init(ctx); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_encrypt_init failed")
+		}
+		return nil
+	}
+	encrypt := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) error {
+		if ret := C.go_openssl_EVP_PKEY_encrypt(ctx, out, outLen, in, inLen); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_encrypt failed")
+		}
+		return nil
+	}
+	return cryptEVP(withKey, padding, h, mgfHash, label, 0, 0, encryptInit, encrypt, msg)
+}
+
+func evpDecrypt(withKey withKeyFunc, padding C.int, h, mgfHash hash.Hash, label, msg []byte) ([]byte, error) {
+	decryptInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {
+		if ret := C.go_openssl_EVP_PKEY_decrypt_init(ctx); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_decrypt_init failed")
+		}
+		return nil
+	}
+	decrypt := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) error {
+		if ret := C.go_openssl_EVP_PKEY_decrypt(ctx, out, outLen, in, inLen); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_decrypt failed")
+		}
+		return nil
+	}
+	return cryptEVP(withKey, padding, h, mgfHash, label, 0, 0, decryptInit, decrypt, msg)
+}
+
+func evpSign(withKey withKeyFunc, padding C.int, saltLen C.int, h crypto.Hash, hashed []byte) ([]byte, error) {
+	signtInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {
+		if ret := C.go_openssl_EVP_PKEY_sign_init(ctx); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_sign_init failed")
+		}
+		return nil
+	}
+	sign := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen *C.size_t, in *C.uchar, inLen C.size_t) error {
+		if ret := C.go_openssl_EVP_PKEY_sign(ctx, out, outLen, in, inLen); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_sign failed")
+		}
+		return nil
+	}
+	return cryptEVP(withKey, padding, nil, nil, nil, saltLen, h, signtInit, sign, hashed)
+}
+
+func evpVerify(withKey withKeyFunc, padding C.int, saltLen C.int, h crypto.Hash, sig, hashed []byte) error {
+	verifyInit := func(ctx C.GO_EVP_PKEY_CTX_PTR) error {
+		if ret := C.go_openssl_EVP_PKEY_verify_init(ctx); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_verify_init failed")
+		}
+		return nil
+	}
+	verify := func(ctx C.GO_EVP_PKEY_CTX_PTR, out *C.uchar, outLen C.size_t, in *C.uchar, inLen C.size_t) error {
+		if ret := C.go_openssl_EVP_PKEY_verify(ctx, out, outLen, in, inLen); ret != 1 {
+			return newOpenSSLError("EVP_PKEY_verify failed")
+		}
+		return nil
+	}
+	return verifyEVP(withKey, padding, nil, nil, saltLen, h, verifyInit, verify, sig, hashed)
+}
+
+func evpHashSign(withKey withKeyFunc, h crypto.Hash, msg []byte) ([]byte, error) {
+	md := cryptoHashToMD(h)
+	if md == nil {
+		return nil, errors.New("unsupported hash function: " + strconv.Itoa(int(h)))
+	}
+	var out []byte
+	var outLen C.size_t
+	ctx := C.go_openssl_EVP_MD_CTX_new()
+	if ctx == nil {
+		return nil, newOpenSSLError("EVP_MD_CTX_new failed")
+	}
+	defer C.go_openssl_EVP_MD_CTX_free(ctx)
+	if withKey(func(key C.GO_EVP_PKEY_PTR) C.int {
+		return C.go_openssl_EVP_DigestSignInit(ctx, nil, md, nil, key)
+	}) != 1 {
+		return nil, newOpenSSLError("EVP_DigestSignInit failed")
+	}
+	if C.go_openssl_EVP_DigestUpdate(ctx, unsafe.Pointer(base(msg)), C.size_t(len(msg))) != 1 {
+		return nil, newOpenSSLError("EVP_DigestUpdate failed")
+	}
+	// Obtain the signature length
+	if C.go_openssl_EVP_DigestSignFinal(ctx, nil, &outLen) != 1 {
+		return nil, newOpenSSLError("EVP_DigestSignFinal failed")
+	}
+	out = make([]byte, outLen)
+	// Obtain the signature
+	if C.go_openssl_EVP_DigestSignFinal(ctx, base(out), &outLen) != 1 {
+		return nil, newOpenSSLError("EVP_DigestSignFinal failed")
+	}
+	return out[:outLen], nil
+}
+
+func evpHashVerify(withKey withKeyFunc, h crypto.Hash, msg, sig []byte) error {
+	md := cryptoHashToMD(h)
+	if md == nil {
+		return errors.New("unsupported hash function: " + strconv.Itoa(int(h)))
+	}
+	ctx := C.go_openssl_EVP_MD_CTX_new()
+	if ctx == nil {
+		return newOpenSSLError("EVP_MD_CTX_new failed")
+	}
+	defer C.go_openssl_EVP_MD_CTX_free(ctx)
+	if withKey(func(key C.GO_EVP_PKEY_PTR) C.int {
+		return C.go_openssl_EVP_DigestVerifyInit(ctx, nil, md, nil, key)
+	}) != 1 {
+		return newOpenSSLError("EVP_DigestVerifyInit failed")
+	}
+	if C.go_openssl_EVP_DigestUpdate(ctx, unsafe.Pointer(base(msg)), C.size_t(len(msg))) != 1 {
+		return newOpenSSLError("EVP_DigestUpdate failed")
+	}
+	if C.go_openssl_EVP_DigestVerifyFinal(ctx, base(sig), C.size_t(len(sig))) != 1 {
+		return newOpenSSLError("EVP_DigestVerifyFinal failed")
+	}
+	return nil
+}
+
+func newEVPPKEY(key C.GO_EC_KEY_PTR) (C.GO_EVP_PKEY_PTR, error) {
+	pkey := C.go_openssl_EVP_PKEY_new()
+	if pkey == nil {
+		return nil, newOpenSSLError("EVP_PKEY_new failed")
+	}
+	if C.go_openssl_EVP_PKEY_assign(pkey, C.GO_EVP_PKEY_EC, unsafe.Pointer(key)) != 1 {
+		C.go_openssl_EVP_PKEY_free(pkey)
+		return nil, newOpenSSLError("EVP_PKEY_assign failed")
+	}
+	return pkey, nil
+}
+
+// getECKey returns the EC_KEY from pkey.
+// If pkey does not contain an EC_KEY it panics.
+// The returned key should not be freed.
+func getECKey(pkey C.GO_EVP_PKEY_PTR) (key C.GO_EC_KEY_PTR) {
+	if vMajor == 1 && vMinor == 0 {
+		if key0 := C.go_openssl_EVP_PKEY_get0(pkey); key0 != nil {
+			key = C.GO_EC_KEY_PTR(key0)
+		}
+	} else {
+		key = C.go_openssl_EVP_PKEY_get0_EC_KEY(pkey)
+	}
+	if key == nil {
+		panic("pkey does not contain an EC_KEY")
+	}
+	return key
+}
+
+func newEvpFromParams(id C.int, selection C.int, params C.GO_OSSL_PARAM_PTR) (C.GO_EVP_PKEY_PTR, error) {
+	ctx := C.go_openssl_EVP_PKEY_CTX_new_id(id, nil)
+	if ctx == nil {
+		return nil, newOpenSSLError("EVP_PKEY_CTX_new_id")
+	}
+	defer C.go_openssl_EVP_PKEY_CTX_free(ctx)
+	if C.go_openssl_EVP_PKEY_fromdata_init(ctx) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_fromdata_init")
+	}
+	var pkey C.GO_EVP_PKEY_PTR
+	if C.go_openssl_EVP_PKEY_fromdata(ctx, &pkey, selection, params) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_fromdata")
+	}
+	return pkey, nil
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/goopenssl.c b/src/vendor/github.com/golang-fips/openssl/v2/goopenssl.c
new file mode 100644
index 0000000000..1e428d5269
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/goopenssl.c
@@ -0,0 +1,218 @@
+//go:build unix || windows
+
+#include "goopenssl.h"
+
+#ifdef _WIN32
+# include <windows.h>
+# define dlsym (void*)GetProcAddress
+#else
+# include <dlfcn.h> // dlsym
+#endif
+#include <stdio.h> // fprintf
+
+// Approach taken from .Net System.Security.Cryptography.Native
+// https://github.com/dotnet/runtime/blob/f64246ce08fb7a58221b2b7c8e68f69c02522b0d/src/libraries/Native/Unix/System.Security.Cryptography.Native/opensslshim.c
+
+#define DEFINEFUNC(ret, func, args, argscall)                  ret (*_g_##func)args;
+#define DEFINEFUNC_LEGACY_1_1(ret, func, args, argscall)       DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_LEGACY_1_0(ret, func, args, argscall)       DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_LEGACY_1(ret, func, args, argscall)         DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_1_1(ret, func, args, argscall)              DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_1_1_1(ret, func, args, argscall)            DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_3_0(ret, func, args, argscall)              DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_RENAMED_1_1(ret, func, oldfunc, args, argscall) DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_RENAMED_3_0(ret, func, oldfunc, args, argscall) DEFINEFUNC(ret, func, args, argscall)
+
+FOR_ALL_OPENSSL_FUNCTIONS
+
+#undef DEFINEFUNC
+#undef DEFINEFUNC_LEGACY_1_1
+#undef DEFINEFUNC_LEGACY_1_0
+#undef DEFINEFUNC_LEGACY_1
+#undef DEFINEFUNC_1_1
+#undef DEFINEFUNC_1_1_1
+#undef DEFINEFUNC_3_0
+#undef DEFINEFUNC_RENAMED_1_1
+#undef DEFINEFUNC_RENAMED_3_0
+
+int
+go_openssl_fips_enabled(void* handle)
+{
+    // For OpenSSL 1.x.
+    int (*FIPS_mode)(void);
+    FIPS_mode = (int (*)(void))dlsym(handle, "FIPS_mode");
+    if (FIPS_mode != NULL)
+        return FIPS_mode();
+
+    // For OpenSSL 3.x.
+    int (*EVP_default_properties_is_fips_enabled)(void*);
+    int (*OSSL_PROVIDER_available)(void*, const char*);
+    EVP_default_properties_is_fips_enabled = (int (*)(void*))dlsym(handle, "EVP_default_properties_is_fips_enabled"); 
+    OSSL_PROVIDER_available = (int (*)(void*, const char*))dlsym(handle, "OSSL_PROVIDER_available"); 
+    if (EVP_default_properties_is_fips_enabled != NULL && OSSL_PROVIDER_available != NULL &&
+        EVP_default_properties_is_fips_enabled(NULL) == 1 && OSSL_PROVIDER_available(NULL, "fips") == 1)
+            return 1;
+
+    return 0;
+}
+
+// Load all the functions stored in FOR_ALL_OPENSSL_FUNCTIONS
+// and assign them to their corresponding function pointer
+// defined in goopenssl.h.
+void
+go_openssl_load_functions(void* handle, unsigned int major, unsigned int minor, unsigned int patch)
+{
+#define DEFINEFUNC_INTERNAL(name, func)                                                                         \
+    _g_##name = dlsym(handle, func);                                                                            \
+    if (_g_##name == NULL) {                                                                                    \
+        fprintf(stderr, "Cannot get required symbol " #func " from libcrypto version %u.%u\n", major, minor);   \
+        abort();                                                                                                \
+    }
+#define DEFINEFUNC(ret, func, args, argscall) \
+    DEFINEFUNC_INTERNAL(func, #func)
+#define DEFINEFUNC_LEGACY_1_1(ret, func, args, argscall)  \
+    if (major == 1 && minor == 1)                         \
+    {                                                     \
+        DEFINEFUNC_INTERNAL(func, #func)                  \
+    }
+#define DEFINEFUNC_LEGACY_1_0(ret, func, args, argscall)  \
+    if (major == 1 && minor == 0)                         \
+    {                                                     \
+        DEFINEFUNC_INTERNAL(func, #func)                  \
+    }
+#define DEFINEFUNC_LEGACY_1(ret, func, args, argscall)  \
+    if (major == 1)                                     \
+    {                                                   \
+        DEFINEFUNC_INTERNAL(func, #func)                \
+    }
+#define DEFINEFUNC_1_1(ret, func, args, argscall)     \
+    if (major == 3 || (major == 1 && minor == 1))     \
+    {                                                 \
+        DEFINEFUNC_INTERNAL(func, #func)              \
+    }
+#define DEFINEFUNC_1_1_1(ret, func, args, argscall)     \
+    if (major == 3 || (major == 1 && minor == 1 && patch == 1))     \
+    {                                                 \
+        DEFINEFUNC_INTERNAL(func, #func)              \
+    }
+#define DEFINEFUNC_3_0(ret, func, args, argscall)     \
+    if (major == 3)                                   \
+    {                                                 \
+        DEFINEFUNC_INTERNAL(func, #func)              \
+    }
+#define DEFINEFUNC_RENAMED_1_1(ret, func, oldfunc, args, argscall)  \
+    if (major == 1 && minor == 0)                                   \
+    {                                                               \
+        DEFINEFUNC_INTERNAL(func, #oldfunc)                         \
+    }                                                               \
+    else                                                            \
+    {                                                               \
+        DEFINEFUNC_INTERNAL(func, #func)                            \
+    }
+#define DEFINEFUNC_RENAMED_3_0(ret, func, oldfunc, args, argscall)  \
+    if (major == 1)                                                 \
+    {                                                               \
+        DEFINEFUNC_INTERNAL(func, #oldfunc)                         \
+    }                                                               \
+    else                                                            \
+    {                                                               \
+        DEFINEFUNC_INTERNAL(func, #func)                            \
+    }
+
+FOR_ALL_OPENSSL_FUNCTIONS
+
+#undef DEFINEFUNC
+#undef DEFINEFUNC_LEGACY_1_1
+#undef DEFINEFUNC_LEGACY_1_0
+#undef DEFINEFUNC_LEGACY_1
+#undef DEFINEFUNC_1_1
+#undef DEFINEFUNC_1_1_1
+#undef DEFINEFUNC_3_0
+#undef DEFINEFUNC_RENAMED_1_1
+#undef DEFINEFUNC_RENAMED_3_0
+}
+
+static unsigned long
+version_num(void* handle)
+{
+    unsigned long (*fn)(void);
+    // OPENSSL_version_num is defined in OpenSSL 1.1.0 and 1.1.1.
+    fn = (unsigned long (*)(void))dlsym(handle, "OpenSSL_version_num");
+    if (fn != NULL)
+        return fn();
+
+    // SSLeay is defined in OpenSSL 1.0.2.
+    fn = (unsigned long (*)(void))dlsym(handle, "SSLeay");
+    if (fn != NULL)
+        return fn();
+
+    return 0;
+} 
+
+int
+go_openssl_version_major(void* handle)
+{
+    unsigned int (*fn)(void);
+    // OPENSSL_version_major is supported since OpenSSL 3.
+    fn = (unsigned int (*)(void))dlsym(handle, "OPENSSL_version_major");
+    if (fn != NULL)
+        return (int)fn();
+
+    // If OPENSSL_version_major is not defined, try with OpenSSL 1 functions.
+    unsigned long num = version_num(handle);
+    if (num < 0x10000000L || num >= 0x20000000L)
+        return -1;
+
+    return 1;
+}
+
+int
+go_openssl_version_minor(void* handle)
+{
+    unsigned int (*fn)(void);
+    // OPENSSL_version_minor is supported since OpenSSL 3.
+    fn = (unsigned int (*)(void))dlsym(handle, "OPENSSL_version_minor");
+    if (fn != NULL)
+        return (int)fn();
+
+    // If OPENSSL_version_minor is not defined, try with OpenSSL 1 functions.
+    unsigned long num = version_num(handle);
+    // OpenSSL version number follows this schema:
+    // MNNFFPPS: major minor fix patch status.
+    if (num < 0x10000000L || num >= 0x10200000L)
+    {
+        // We only support minor version 0 and 1,
+        // so there is no need to implement an algorithm
+        // that decodes the version number into individual components.
+        return -1;
+    }
+
+    if (num >= 0x10100000L)
+        return 1;
+    
+    return 0;
+}
+
+int
+go_openssl_version_patch(void* handle)
+{
+    unsigned int (*fn)(void);
+    // OPENSSL_version_patch is supported since OpenSSL 3.
+    fn = (unsigned int (*)(void))dlsym(handle, "OPENSSL_version_patch");
+    if (fn != NULL)
+        return (int)fn();
+
+    // If OPENSSL_version_patch is not defined, try with OpenSSL 1 functions.
+    unsigned long num = version_num(handle);
+    // OpenSSL version number follows this schema:
+    // MNNFFPPS: major minor fix patch status.
+    if (num < 0x10000000L || num >= 0x10200000L)
+    {
+        // We only support minor version 0 and 1,
+        // so there is no need to implement an algorithm
+        // that decodes the version number into individual components.
+        return -1;
+    }
+
+    return (num >> 12) & 0xff;
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/goopenssl.h b/src/vendor/github.com/golang-fips/openssl/v2/goopenssl.h
new file mode 100644
index 0000000000..e488bf2014
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/goopenssl.h
@@ -0,0 +1,255 @@
+// This header file describes the OpenSSL ABI as built for use in Go.
+
+#include <stdlib.h> // size_t
+
+#include "shims.h"
+
+// Suppress warnings about unused parameters.
+#define UNUSED(x) (void)(x)
+
+static inline void
+go_openssl_do_leak_check(void)
+{
+#ifndef __has_feature
+#define __has_feature(x) 0
+#endif
+
+#if (defined(__SANITIZE_ADDRESS__) && __SANITIZE_ADDRESS__) ||	\
+    __has_feature(address_sanitizer)
+    extern void __lsan_do_leak_check(void);
+    __lsan_do_leak_check();
+#endif
+}
+
+int go_openssl_fips_enabled(void* handle);
+int go_openssl_version_major(void* handle);
+int go_openssl_version_minor(void* handle);
+int go_openssl_version_patch(void* handle);
+int go_openssl_thread_setup(void);
+void go_openssl_load_functions(void* handle, unsigned int major, unsigned int minor, unsigned int patch);
+const GO_EVP_MD_PTR go_openssl_EVP_md5_sha1_backport(void);
+
+// Define pointers to all the used OpenSSL functions.
+// Calling C function pointers from Go is currently not supported.
+// It is possible to circumvent this by using a C function wrapper.
+// https://pkg.go.dev/cmd/cgo
+#define DEFINEFUNC(ret, func, args, argscall)      \
+    extern ret (*_g_##func)args;                   \
+    static inline ret go_openssl_##func args       \
+    {                                              \
+        return _g_##func argscall;                 \
+    }
+#define DEFINEFUNC_LEGACY_1_1(ret, func, args, argscall)    \
+    DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_LEGACY_1_0(ret, func, args, argscall)    \
+    DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_LEGACY_1(ret, func, args, argscall)  \
+    DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_1_1(ret, func, args, argscall)   \
+    DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_1_1_1(ret, func, args, argscall)     \
+    DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_3_0(ret, func, args, argscall)     \
+    DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_RENAMED_1_1(ret, func, oldfunc, args, argscall)     \
+    DEFINEFUNC(ret, func, args, argscall)
+#define DEFINEFUNC_RENAMED_3_0(ret, func, oldfunc, args, argscall)     \
+    DEFINEFUNC(ret, func, args, argscall)
+
+FOR_ALL_OPENSSL_FUNCTIONS
+
+#undef DEFINEFUNC
+#undef DEFINEFUNC_LEGACY_1_1
+#undef DEFINEFUNC_LEGACY_1_0
+#undef DEFINEFUNC_LEGACY_1
+#undef DEFINEFUNC_1_1
+#undef DEFINEFUNC_1_1_1
+#undef DEFINEFUNC_3_0
+#undef DEFINEFUNC_RENAMED_1_1
+#undef DEFINEFUNC_RENAMED_3_0
+
+// go_hash_sum copies ctx into ctx2 and calls EVP_DigestFinal using ctx2.
+// This is necessary because Go hash.Hash mandates that Sum has no effect
+// on the underlying stream. In particular it is OK to Sum, then Write more,
+// then Sum again, and the second Sum acts as if the first didn't happen.
+// It is written in C because Sum() tend to be in the hot path,
+// and doing one cgo call instead of two is a significant performance win.
+static inline int
+go_hash_sum(GO_EVP_MD_CTX_PTR ctx, GO_EVP_MD_CTX_PTR ctx2, unsigned char *out)
+{
+    if (go_openssl_EVP_MD_CTX_copy(ctx2, ctx) != 1)
+        return 0;
+    // TODO: use EVP_DigestFinal_ex once we know why it leaks
+    // memory on OpenSSL 1.0.2.
+    return go_openssl_EVP_DigestFinal(ctx2, out, NULL);
+}
+
+// These wrappers allocate out_len on the C stack to avoid having to pass a pointer from Go, which would escape to the heap.
+// Use them only in situations where the output length can be safely discarded.
+static inline int
+go_openssl_EVP_EncryptUpdate_wrapper(GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *out, const unsigned char *in, int in_len)
+{
+    int len;
+    return go_openssl_EVP_EncryptUpdate(ctx, out, &len, in, in_len);
+}
+
+static inline int
+go_openssl_EVP_DecryptUpdate_wrapper(GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *out, const unsigned char *in, int in_len)
+{
+    int len;
+    return go_openssl_EVP_DecryptUpdate(ctx, out, &len, in, in_len);
+}
+
+static inline int
+go_openssl_EVP_CipherUpdate_wrapper(GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *out, const unsigned char *in, int in_len)
+{
+    int len;
+    return go_openssl_EVP_CipherUpdate(ctx, out, &len, in, in_len);
+}
+
+// These wrappers also allocate length variables on the C stack to avoid escape to the heap, but do return the result.
+// A struct is returned that contains multiple return values instead of OpenSSL's approach of using pointers.
+
+typedef struct
+{
+    int result;
+    size_t keylen;
+} go_openssl_EVP_PKEY_derive_wrapper_out;
+
+static inline go_openssl_EVP_PKEY_derive_wrapper_out
+go_openssl_EVP_PKEY_derive_wrapper(GO_EVP_PKEY_CTX_PTR ctx, unsigned char *key, size_t keylen)
+{
+    go_openssl_EVP_PKEY_derive_wrapper_out r = {0, keylen};
+    r.result = go_openssl_EVP_PKEY_derive(ctx, key, &r.keylen);
+    return r;
+}
+
+typedef struct
+{
+    int result;
+    size_t len;
+} go_openssl_EVP_PKEY_get_raw_key_out;
+
+static inline go_openssl_EVP_PKEY_get_raw_key_out
+go_openssl_EVP_PKEY_get_raw_public_key_wrapper(const GO_EVP_PKEY_PTR pkey, unsigned char *pub, size_t len)
+{
+    go_openssl_EVP_PKEY_get_raw_key_out r = {0, len};
+    r.result = go_openssl_EVP_PKEY_get_raw_public_key(pkey, pub, &r.len);
+    return r;
+}
+
+static inline go_openssl_EVP_PKEY_get_raw_key_out
+go_openssl_EVP_PKEY_get_raw_private_key_wrapper(const GO_EVP_PKEY_PTR pkey, unsigned char *priv, size_t len)
+{
+    go_openssl_EVP_PKEY_get_raw_key_out r = {0, len};
+    r.result = go_openssl_EVP_PKEY_get_raw_private_key(pkey, priv, &r.len);
+    return r;
+}
+
+typedef struct
+{
+    int result;
+    size_t siglen;
+} go_openssl_EVP_DigestSign_wrapper_out;
+
+static inline go_openssl_EVP_DigestSign_wrapper_out
+go_openssl_EVP_DigestSign_wrapper(GO_EVP_MD_CTX_PTR ctx, unsigned char *sigret, size_t siglen, const unsigned char *tbs, size_t tbslen)
+{
+    go_openssl_EVP_DigestSign_wrapper_out r = {0, siglen};
+    r.result = go_openssl_EVP_DigestSign(ctx, sigret, &r.siglen, tbs, tbslen);
+    return r;
+}
+
+// These wrappers allocate out_len on the C stack, and check that it matches the expected
+// value, to avoid having to pass a pointer from Go, which would escape to the heap.
+
+static inline int
+go_openssl_EVP_CIPHER_CTX_seal_wrapper(const GO_EVP_CIPHER_CTX_PTR ctx,
+                                       unsigned char *out,
+                                       const unsigned char *nonce,
+                                       const unsigned char *in, int in_len,
+                                       const unsigned char *aad, int aad_len)
+{
+    if (in_len == 0) in = (const unsigned char *)"";
+    if (aad_len == 0) aad = (const unsigned char *)"";
+
+    if (go_openssl_EVP_EncryptInit_ex(ctx, NULL, NULL, NULL, nonce) != 1)
+        return 0;
+
+    int discard_len, out_len;
+    if (go_openssl_EVP_EncryptUpdate(ctx, NULL, &discard_len, aad, aad_len) != 1
+        || go_openssl_EVP_EncryptUpdate(ctx, out, &out_len, in, in_len) != 1
+        || go_openssl_EVP_EncryptFinal_ex(ctx, out + out_len, &discard_len) != 1)
+    {
+        return 0;
+    }
+
+    if (in_len != out_len)
+        return 0;
+
+    return go_openssl_EVP_CIPHER_CTX_ctrl(ctx, GO_EVP_CTRL_GCM_GET_TAG, 16, out + out_len);
+}
+
+static inline int
+go_openssl_EVP_CIPHER_CTX_open_wrapper(const GO_EVP_CIPHER_CTX_PTR ctx,
+                                       unsigned char *out,
+                                       const unsigned char *nonce,
+                                       const unsigned char *in, int in_len,
+                                       const unsigned char *aad, int aad_len,
+                                       const unsigned char *tag)
+{
+    if (in_len == 0) {
+        in = (const unsigned char *)"";
+        // OpenSSL 1.0.2 in FIPS mode contains a bug: it will fail to verify
+        // unless EVP_DecryptUpdate is called at least once with a non-NULL
+        // output buffer.  OpenSSL will not dereference the output buffer when
+        // the input length is zero, so set it to an arbitrary non-NULL pointer
+        // to satisfy OpenSSL when the caller only has authenticated additional
+        // data (AAD) to verify. While a stack-allocated buffer could be used,
+        // that would risk a stack-corrupting buffer overflow if OpenSSL
+        // unexpectedly dereferenced it. Instead pass a value which would
+        // segfault if dereferenced on any modern platform where a NULL-pointer
+        // dereference would also segfault.
+        if (out == NULL) out = (unsigned char *)1;
+    }
+    if (aad_len == 0) aad = (const unsigned char *)"";
+
+    if (go_openssl_EVP_DecryptInit_ex(ctx, NULL, NULL, NULL, nonce) != 1)
+        return 0;
+
+    // OpenSSL 1.0.x FIPS Object Module 2.0 versions below 2.0.5 require that
+    // the tag be set before the ciphertext, otherwise EVP_DecryptUpdate returns
+    // an error. At least one extant commercially-supported, FIPS validated
+    // build of OpenSSL 1.0.2 uses FIPS module version 2.0.1. Set the tag first
+    // to maximize compatibility with all OpenSSL version combinations.
+    if (go_openssl_EVP_CIPHER_CTX_ctrl(ctx, GO_EVP_CTRL_GCM_SET_TAG, 16, (unsigned char *)(tag)) != 1)
+        return 0;
+
+    int discard_len, out_len;
+    if (go_openssl_EVP_DecryptUpdate(ctx, NULL, &discard_len, aad, aad_len) != 1
+        || go_openssl_EVP_DecryptUpdate(ctx, out, &out_len, in, in_len) != 1)
+    {
+        return 0;
+    }
+
+    if (go_openssl_EVP_DecryptFinal_ex(ctx, out + out_len, &discard_len) != 1)
+        return 0;
+
+    if (out_len != in_len)
+        return 0;
+
+    return 1;
+}
+
+// Hand-roll custom wrappers for CRYPTO_malloc and CRYPTO_free which cast the
+// function pointers to the correct signatures for OpenSSL 1.0.2.
+
+static inline void *
+go_openssl_CRYPTO_malloc_legacy102(int num, const char *file, int line) {
+    return ((void *(*)(int, const char *, int))_g_CRYPTO_malloc)(num, file, line);
+}
+
+static inline void
+go_openssl_CRYPTO_free_legacy102(void *str) {
+    ((void (*)(void *))_g_CRYPTO_free)(str);
+}
\ No newline at end of file
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/hash.go b/src/vendor/github.com/golang-fips/openssl/v2/hash.go
new file mode 100644
index 0000000000..646b4ce295
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/hash.go
@@ -0,0 +1,793 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"crypto"
+	"errors"
+	"hash"
+	"runtime"
+	"strconv"
+	"unsafe"
+)
+
+// NOTE: Implementation ported from https://go-review.googlesource.com/c/go/+/404295.
+// The cgo calls in this file are arranged to avoid marking the parameters as escaping.
+// To do that, we call noescape (including via addr).
+// We must also make sure that the data pointer arguments have the form unsafe.Pointer(&...)
+// so that cgo does not annotate them with cgoCheckPointer calls. If it did that, it might look
+// beyond the byte slice and find Go pointers in unprocessed parts of a larger allocation.
+// To do both of these simultaneously, the idiom is unsafe.Pointer(&*addr(p)),
+// where addr returns the base pointer of p, substituting a non-nil pointer for nil,
+// and applying a noescape along the way.
+// This is all to preserve compatibility with the allocation behavior of the non-openssl implementations.
+
+func hashOneShot(ch crypto.Hash, p []byte, sum []byte) bool {
+	return C.go_openssl_EVP_Digest(unsafe.Pointer(&*addr(p)), C.size_t(len(p)), (*C.uchar)(unsafe.Pointer(&*addr(sum))), nil, cryptoHashToMD(ch), nil) != 0
+}
+
+func MD4(p []byte) (sum [16]byte) {
+	if !hashOneShot(crypto.MD4, p, sum[:]) {
+		panic("openssl: MD4 failed")
+	}
+	return
+}
+
+func MD5(p []byte) (sum [16]byte) {
+	if !hashOneShot(crypto.MD5, p, sum[:]) {
+		panic("openssl: MD5 failed")
+	}
+	return
+}
+
+func SHA1(p []byte) (sum [20]byte) {
+	if !hashOneShot(crypto.SHA1, p, sum[:]) {
+		panic("openssl: SHA1 failed")
+	}
+	return
+}
+
+func SHA224(p []byte) (sum [28]byte) {
+	if !hashOneShot(crypto.SHA224, p, sum[:]) {
+		panic("openssl: SHA224 failed")
+	}
+	return
+}
+
+func SHA256(p []byte) (sum [32]byte) {
+	if !hashOneShot(crypto.SHA256, p, sum[:]) {
+		panic("openssl: SHA256 failed")
+	}
+	return
+}
+
+func SHA384(p []byte) (sum [48]byte) {
+	if !hashOneShot(crypto.SHA384, p, sum[:]) {
+		panic("openssl: SHA384 failed")
+	}
+	return
+}
+
+func SHA512(p []byte) (sum [64]byte) {
+	if !hashOneShot(crypto.SHA512, p, sum[:]) {
+		panic("openssl: SHA512 failed")
+	}
+	return
+}
+
+// SupportsHash returns true if a hash.Hash implementation is supported for h.
+func SupportsHash(h crypto.Hash) bool {
+	return cryptoHashToMD(h) != nil
+}
+
+func SHA3_224(p []byte) (sum [28]byte) {
+	if !hashOneShot(crypto.SHA3_224, p, sum[:]) {
+		panic("openssl: SHA3_224 failed")
+	}
+	return
+}
+
+func SHA3_256(p []byte) (sum [32]byte) {
+	if !hashOneShot(crypto.SHA3_256, p, sum[:]) {
+		panic("openssl: SHA3_256 failed")
+	}
+	return
+}
+
+func SHA3_384(p []byte) (sum [48]byte) {
+	if !hashOneShot(crypto.SHA3_384, p, sum[:]) {
+		panic("openssl: SHA3_384 failed")
+	}
+	return
+}
+
+func SHA3_512(p []byte) (sum [64]byte) {
+	if !hashOneShot(crypto.SHA3_512, p, sum[:]) {
+		panic("openssl: SHA3_512 failed")
+	}
+	return
+}
+
+// evpHash implements generic hash methods.
+type evpHash struct {
+	ctx C.GO_EVP_MD_CTX_PTR
+	// ctx2 is used in evpHash.sum to avoid changing
+	// the state of ctx. Having it here allows reusing the
+	// same allocated object multiple times.
+	ctx2      C.GO_EVP_MD_CTX_PTR
+	size      int
+	blockSize int
+}
+
+func newEvpHash(ch crypto.Hash, size, blockSize int) *evpHash {
+	md := cryptoHashToMD(ch)
+	if md == nil {
+		panic("openssl: unsupported hash function: " + strconv.Itoa(int(ch)))
+	}
+	ctx := C.go_openssl_EVP_MD_CTX_new()
+	if C.go_openssl_EVP_DigestInit_ex(ctx, md, nil) != 1 {
+		C.go_openssl_EVP_MD_CTX_free(ctx)
+		panic(newOpenSSLError("EVP_DigestInit_ex"))
+	}
+	ctx2 := C.go_openssl_EVP_MD_CTX_new()
+	h := &evpHash{
+		ctx:       ctx,
+		ctx2:      ctx2,
+		size:      size,
+		blockSize: blockSize,
+	}
+	runtime.SetFinalizer(h, (*evpHash).finalize)
+	return h
+}
+
+func (h *evpHash) finalize() {
+	C.go_openssl_EVP_MD_CTX_free(h.ctx)
+	C.go_openssl_EVP_MD_CTX_free(h.ctx2)
+}
+
+func (h *evpHash) Reset() {
+	// There is no need to reset h.ctx2 because it is always reset after
+	// use in evpHash.sum.
+	if C.go_openssl_EVP_DigestInit_ex(h.ctx, nil, nil) != 1 {
+		panic(newOpenSSLError("EVP_DigestInit_ex"))
+	}
+	runtime.KeepAlive(h)
+}
+
+func (h *evpHash) Write(p []byte) (int, error) {
+	if len(p) > 0 && C.go_openssl_EVP_DigestUpdate(h.ctx, unsafe.Pointer(&*addr(p)), C.size_t(len(p))) != 1 {
+		panic(newOpenSSLError("EVP_DigestUpdate"))
+	}
+	runtime.KeepAlive(h)
+	return len(p), nil
+}
+
+func (h *evpHash) WriteString(s string) (int, error) {
+	if len(s) > 0 && C.go_openssl_EVP_DigestUpdate(h.ctx, unsafe.Pointer(unsafe.StringData(s)), C.size_t(len(s))) == 0 {
+		panic("openssl: EVP_DigestUpdate failed")
+	}
+	runtime.KeepAlive(h)
+	return len(s), nil
+}
+
+func (h *evpHash) WriteByte(c byte) error {
+	if C.go_openssl_EVP_DigestUpdate(h.ctx, unsafe.Pointer(&c), 1) == 0 {
+		panic("openssl: EVP_DigestUpdate failed")
+	}
+	runtime.KeepAlive(h)
+	return nil
+}
+
+func (h *evpHash) Size() int {
+	return h.size
+}
+
+func (h *evpHash) BlockSize() int {
+	return h.blockSize
+}
+
+func (h *evpHash) sum(out []byte) {
+	if C.go_hash_sum(h.ctx, h.ctx2, base(out)) != 1 {
+		panic(newOpenSSLError("go_hash_sum"))
+	}
+	runtime.KeepAlive(h)
+}
+
+// hashState returns a pointer to the internal hash structure.
+//
+// The EVP_MD_CTX memory layout has changed in OpenSSL 3
+// and the property holding the internal structure is no longer md_data but algctx.
+func (h *evpHash) hashState() unsafe.Pointer {
+	switch vMajor {
+	case 1:
+		// https://github.com/openssl/openssl/blob/0418e993c717a6863f206feaa40673a261de7395/crypto/evp/evp_local.h#L12.
+		type mdCtx struct {
+			_       [2]unsafe.Pointer
+			_       C.ulong
+			md_data unsafe.Pointer
+		}
+		return (*mdCtx)(unsafe.Pointer(h.ctx)).md_data
+	case 3:
+		// https://github.com/openssl/openssl/blob/5675a5aaf6a2e489022bcfc18330dae9263e598e/crypto/evp/evp_local.h#L16.
+		type mdCtx struct {
+			_      [3]unsafe.Pointer
+			_      C.ulong
+			_      [3]unsafe.Pointer
+			algctx unsafe.Pointer
+		}
+		return (*mdCtx)(unsafe.Pointer(h.ctx)).algctx
+	default:
+		panic(errUnsupportedVersion())
+	}
+}
+
+// NewMD4 returns a new MD4 hash.
+// The returned hash doesn't implement encoding.BinaryMarshaler and
+// encoding.BinaryUnmarshaler.
+func NewMD4() hash.Hash {
+	return &md4Hash{
+		evpHash: newEvpHash(crypto.MD4, 16, 64),
+	}
+}
+
+type md4Hash struct {
+	*evpHash
+	out [16]byte
+}
+
+func (h *md4Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// NewMD5 returns a new MD5 hash.
+func NewMD5() hash.Hash {
+	return &md5Hash{
+		evpHash: newEvpHash(crypto.MD5, 16, 64),
+	}
+}
+
+// md5State layout is taken from
+// https://github.com/openssl/openssl/blob/0418e993c717a6863f206feaa40673a261de7395/include/openssl/md5.h#L33.
+type md5State struct {
+	h      [4]uint32
+	nl, nh uint32
+	x      [64]byte
+	nx     uint32
+}
+
+type md5Hash struct {
+	*evpHash
+	out [16]byte
+}
+
+func (h *md5Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+const (
+	md5Magic         = "md5\x01"
+	md5MarshaledSize = len(md5Magic) + 4*4 + 64 + 8
+)
+
+func (h *md5Hash) MarshalBinary() ([]byte, error) {
+	d := (*md5State)(h.hashState())
+	if d == nil {
+		return nil, errors.New("crypto/md5: can't retrieve hash state")
+	}
+	b := make([]byte, 0, md5MarshaledSize)
+	b = append(b, md5Magic...)
+	b = appendUint32(b, d.h[0])
+	b = appendUint32(b, d.h[1])
+	b = appendUint32(b, d.h[2])
+	b = appendUint32(b, d.h[3])
+	b = append(b, d.x[:d.nx]...)
+	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
+	b = appendUint64(b, uint64(d.nl)>>3|uint64(d.nh)<<29)
+	return b, nil
+}
+
+func (h *md5Hash) UnmarshalBinary(b []byte) error {
+	if len(b) < len(md5Magic) || string(b[:len(md5Magic)]) != md5Magic {
+		return errors.New("crypto/md5: invalid hash state identifier")
+	}
+	if len(b) != md5MarshaledSize {
+		return errors.New("crypto/md5: invalid hash state size")
+	}
+	d := (*md5State)(h.hashState())
+	if d == nil {
+		return errors.New("crypto/md5: can't retrieve hash state")
+	}
+	b = b[len(md5Magic):]
+	b, d.h[0] = consumeUint32(b)
+	b, d.h[1] = consumeUint32(b)
+	b, d.h[2] = consumeUint32(b)
+	b, d.h[3] = consumeUint32(b)
+	b = b[copy(d.x[:], b):]
+	_, n := consumeUint64(b)
+	d.nl = uint32(n << 3)
+	d.nh = uint32(n >> 29)
+	d.nx = uint32(n) % 64
+	return nil
+}
+
+// NewSHA1 returns a new SHA1 hash.
+func NewSHA1() hash.Hash {
+	return &sha1Hash{
+		evpHash: newEvpHash(crypto.SHA1, 20, 64),
+	}
+}
+
+type sha1Hash struct {
+	*evpHash
+	out [20]byte
+}
+
+func (h *sha1Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// sha1State layout is taken from
+// https://github.com/openssl/openssl/blob/0418e993c717a6863f206feaa40673a261de7395/include/openssl/sha.h#L34.
+type sha1State struct {
+	h      [5]uint32
+	nl, nh uint32
+	x      [64]byte
+	nx     uint32
+}
+
+const (
+	sha1Magic         = "sha\x01"
+	sha1MarshaledSize = len(sha1Magic) + 5*4 + 64 + 8
+)
+
+func (h *sha1Hash) MarshalBinary() ([]byte, error) {
+	d := (*sha1State)(h.hashState())
+	if d == nil {
+		return nil, errors.New("crypto/sha1: can't retrieve hash state")
+	}
+	b := make([]byte, 0, sha1MarshaledSize)
+	b = append(b, sha1Magic...)
+	b = appendUint32(b, d.h[0])
+	b = appendUint32(b, d.h[1])
+	b = appendUint32(b, d.h[2])
+	b = appendUint32(b, d.h[3])
+	b = appendUint32(b, d.h[4])
+	b = append(b, d.x[:d.nx]...)
+	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
+	b = appendUint64(b, uint64(d.nl)>>3|uint64(d.nh)<<29)
+	return b, nil
+}
+
+func (h *sha1Hash) UnmarshalBinary(b []byte) error {
+	if len(b) < len(sha1Magic) || string(b[:len(sha1Magic)]) != sha1Magic {
+		return errors.New("crypto/sha1: invalid hash state identifier")
+	}
+	if len(b) != sha1MarshaledSize {
+		return errors.New("crypto/sha1: invalid hash state size")
+	}
+	d := (*sha1State)(h.hashState())
+	if d == nil {
+		return errors.New("crypto/sha1: can't retrieve hash state")
+	}
+	b = b[len(sha1Magic):]
+	b, d.h[0] = consumeUint32(b)
+	b, d.h[1] = consumeUint32(b)
+	b, d.h[2] = consumeUint32(b)
+	b, d.h[3] = consumeUint32(b)
+	b, d.h[4] = consumeUint32(b)
+	b = b[copy(d.x[:], b):]
+	_, n := consumeUint64(b)
+	d.nl = uint32(n << 3)
+	d.nh = uint32(n >> 29)
+	d.nx = uint32(n) % 64
+	return nil
+}
+
+// NewSHA224 returns a new SHA224 hash.
+func NewSHA224() hash.Hash {
+	return &sha224Hash{
+		evpHash: newEvpHash(crypto.SHA224, 224/8, 64),
+	}
+}
+
+type sha224Hash struct {
+	*evpHash
+	out [224 / 8]byte
+}
+
+func (h *sha224Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// NewSHA256 returns a new SHA256 hash.
+func NewSHA256() hash.Hash {
+	return &sha256Hash{
+		evpHash: newEvpHash(crypto.SHA256, 256/8, 64),
+	}
+}
+
+type sha256Hash struct {
+	*evpHash
+	out [256 / 8]byte
+}
+
+func (h *sha256Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+const (
+	magic224         = "sha\x02"
+	magic256         = "sha\x03"
+	marshaledSize256 = len(magic256) + 8*4 + 64 + 8
+)
+
+// sha256State layout is taken from
+// https://github.com/openssl/openssl/blob/0418e993c717a6863f206feaa40673a261de7395/include/openssl/sha.h#L51.
+type sha256State struct {
+	h      [8]uint32
+	nl, nh uint32
+	x      [64]byte
+	nx     uint32
+}
+
+func (h *sha224Hash) MarshalBinary() ([]byte, error) {
+	d := (*sha256State)(h.hashState())
+	if d == nil {
+		return nil, errors.New("crypto/sha256: can't retrieve hash state")
+	}
+	b := make([]byte, 0, marshaledSize256)
+	b = append(b, magic224...)
+	b = appendUint32(b, d.h[0])
+	b = appendUint32(b, d.h[1])
+	b = appendUint32(b, d.h[2])
+	b = appendUint32(b, d.h[3])
+	b = appendUint32(b, d.h[4])
+	b = appendUint32(b, d.h[5])
+	b = appendUint32(b, d.h[6])
+	b = appendUint32(b, d.h[7])
+	b = append(b, d.x[:d.nx]...)
+	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
+	b = appendUint64(b, uint64(d.nl)>>3|uint64(d.nh)<<29)
+	return b, nil
+}
+
+func (h *sha256Hash) MarshalBinary() ([]byte, error) {
+	d := (*sha256State)(h.hashState())
+	if d == nil {
+		return nil, errors.New("crypto/sha256: can't retrieve hash state")
+	}
+	b := make([]byte, 0, marshaledSize256)
+	b = append(b, magic256...)
+	b = appendUint32(b, d.h[0])
+	b = appendUint32(b, d.h[1])
+	b = appendUint32(b, d.h[2])
+	b = appendUint32(b, d.h[3])
+	b = appendUint32(b, d.h[4])
+	b = appendUint32(b, d.h[5])
+	b = appendUint32(b, d.h[6])
+	b = appendUint32(b, d.h[7])
+	b = append(b, d.x[:d.nx]...)
+	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
+	b = appendUint64(b, uint64(d.nl)>>3|uint64(d.nh)<<29)
+	return b, nil
+}
+
+func (h *sha224Hash) UnmarshalBinary(b []byte) error {
+	if len(b) < len(magic224) || string(b[:len(magic224)]) != magic224 {
+		return errors.New("crypto/sha256: invalid hash state identifier")
+	}
+	if len(b) != marshaledSize256 {
+		return errors.New("crypto/sha256: invalid hash state size")
+	}
+	d := (*sha256State)(h.hashState())
+	if d == nil {
+		return errors.New("crypto/sha256: can't retrieve hash state")
+	}
+	b = b[len(magic224):]
+	b, d.h[0] = consumeUint32(b)
+	b, d.h[1] = consumeUint32(b)
+	b, d.h[2] = consumeUint32(b)
+	b, d.h[3] = consumeUint32(b)
+	b, d.h[4] = consumeUint32(b)
+	b, d.h[5] = consumeUint32(b)
+	b, d.h[6] = consumeUint32(b)
+	b, d.h[7] = consumeUint32(b)
+	b = b[copy(d.x[:], b):]
+	_, n := consumeUint64(b)
+	d.nl = uint32(n << 3)
+	d.nh = uint32(n >> 29)
+	d.nx = uint32(n) % 64
+	return nil
+}
+
+func (h *sha256Hash) UnmarshalBinary(b []byte) error {
+	if len(b) < len(magic256) || string(b[:len(magic256)]) != magic256 {
+		return errors.New("crypto/sha256: invalid hash state identifier")
+	}
+	if len(b) != marshaledSize256 {
+		return errors.New("crypto/sha256: invalid hash state size")
+	}
+	d := (*sha256State)(h.hashState())
+	if d == nil {
+		return errors.New("crypto/sha256: can't retrieve hash state")
+	}
+	b = b[len(magic256):]
+	b, d.h[0] = consumeUint32(b)
+	b, d.h[1] = consumeUint32(b)
+	b, d.h[2] = consumeUint32(b)
+	b, d.h[3] = consumeUint32(b)
+	b, d.h[4] = consumeUint32(b)
+	b, d.h[5] = consumeUint32(b)
+	b, d.h[6] = consumeUint32(b)
+	b, d.h[7] = consumeUint32(b)
+	b = b[copy(d.x[:], b):]
+	_, n := consumeUint64(b)
+	d.nl = uint32(n << 3)
+	d.nh = uint32(n >> 29)
+	d.nx = uint32(n) % 64
+	return nil
+}
+
+// NewSHA384 returns a new SHA384 hash.
+func NewSHA384() hash.Hash {
+	return &sha384Hash{
+		evpHash: newEvpHash(crypto.SHA384, 384/8, 128),
+	}
+}
+
+type sha384Hash struct {
+	*evpHash
+	out [384 / 8]byte
+}
+
+func (h *sha384Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// NewSHA512 returns a new SHA512 hash.
+func NewSHA512() hash.Hash {
+	return &sha512Hash{
+		evpHash: newEvpHash(crypto.SHA512, 512/8, 128),
+	}
+}
+
+type sha512Hash struct {
+	*evpHash
+	out [512 / 8]byte
+}
+
+func (h *sha512Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// sha512State layout is taken from
+// https://github.com/openssl/openssl/blob/0418e993c717a6863f206feaa40673a261de7395/include/openssl/sha.h#L95.
+type sha512State struct {
+	h      [8]uint64
+	nl, nh uint64
+	x      [128]byte
+	nx     uint32
+}
+
+const (
+	magic384         = "sha\x04"
+	magic512_224     = "sha\x05"
+	magic512_256     = "sha\x06"
+	magic512         = "sha\x07"
+	marshaledSize512 = len(magic512) + 8*8 + 128 + 8
+)
+
+func (h *sha384Hash) MarshalBinary() ([]byte, error) {
+	d := (*sha512State)(h.hashState())
+	if d == nil {
+		return nil, errors.New("crypto/sha512: can't retrieve hash state")
+	}
+	b := make([]byte, 0, marshaledSize512)
+	b = append(b, magic384...)
+	b = appendUint64(b, d.h[0])
+	b = appendUint64(b, d.h[1])
+	b = appendUint64(b, d.h[2])
+	b = appendUint64(b, d.h[3])
+	b = appendUint64(b, d.h[4])
+	b = appendUint64(b, d.h[5])
+	b = appendUint64(b, d.h[6])
+	b = appendUint64(b, d.h[7])
+	b = append(b, d.x[:d.nx]...)
+	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
+	b = appendUint64(b, d.nl>>3|d.nh<<61)
+	return b, nil
+}
+
+func (h *sha512Hash) MarshalBinary() ([]byte, error) {
+	d := (*sha512State)(h.hashState())
+	if d == nil {
+		return nil, errors.New("crypto/sha512: can't retrieve hash state")
+	}
+	b := make([]byte, 0, marshaledSize512)
+	b = append(b, magic512...)
+	b = appendUint64(b, d.h[0])
+	b = appendUint64(b, d.h[1])
+	b = appendUint64(b, d.h[2])
+	b = appendUint64(b, d.h[3])
+	b = appendUint64(b, d.h[4])
+	b = appendUint64(b, d.h[5])
+	b = appendUint64(b, d.h[6])
+	b = appendUint64(b, d.h[7])
+	b = append(b, d.x[:d.nx]...)
+	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
+	b = appendUint64(b, d.nl>>3|d.nh<<61)
+	return b, nil
+}
+
+func (h *sha384Hash) UnmarshalBinary(b []byte) error {
+	if len(b) < len(magic512) {
+		return errors.New("crypto/sha512: invalid hash state identifier")
+	}
+	if string(b[:len(magic384)]) != magic384 {
+		return errors.New("crypto/sha512: invalid hash state identifier")
+	}
+	if len(b) != marshaledSize512 {
+		return errors.New("crypto/sha512: invalid hash state size")
+	}
+	d := (*sha512State)(h.hashState())
+	if d == nil {
+		return errors.New("crypto/sha512: can't retrieve hash state")
+	}
+	b = b[len(magic512):]
+	b, d.h[0] = consumeUint64(b)
+	b, d.h[1] = consumeUint64(b)
+	b, d.h[2] = consumeUint64(b)
+	b, d.h[3] = consumeUint64(b)
+	b, d.h[4] = consumeUint64(b)
+	b, d.h[5] = consumeUint64(b)
+	b, d.h[6] = consumeUint64(b)
+	b, d.h[7] = consumeUint64(b)
+	b = b[copy(d.x[:], b):]
+	_, n := consumeUint64(b)
+	d.nl = n << 3
+	d.nh = n >> 61
+	d.nx = uint32(n) % 128
+	return nil
+}
+
+func (h *sha512Hash) UnmarshalBinary(b []byte) error {
+	if len(b) < len(magic512) {
+		return errors.New("crypto/sha512: invalid hash state identifier")
+	}
+	if string(b[:len(magic512)]) != magic512 {
+		return errors.New("crypto/sha512: invalid hash state identifier")
+	}
+	if len(b) != marshaledSize512 {
+		return errors.New("crypto/sha512: invalid hash state size")
+	}
+	d := (*sha512State)(h.hashState())
+	if d == nil {
+		return errors.New("crypto/sha512: can't retrieve hash state")
+	}
+	b = b[len(magic512):]
+	b, d.h[0] = consumeUint64(b)
+	b, d.h[1] = consumeUint64(b)
+	b, d.h[2] = consumeUint64(b)
+	b, d.h[3] = consumeUint64(b)
+	b, d.h[4] = consumeUint64(b)
+	b, d.h[5] = consumeUint64(b)
+	b, d.h[6] = consumeUint64(b)
+	b, d.h[7] = consumeUint64(b)
+	b = b[copy(d.x[:], b):]
+	_, n := consumeUint64(b)
+	d.nl = n << 3
+	d.nh = n >> 61
+	d.nx = uint32(n) % 128
+	return nil
+}
+
+// NewSHA3_224 returns a new SHA3-224 hash.
+func NewSHA3_224() hash.Hash {
+	return &sha3_224Hash{
+		evpHash: newEvpHash(crypto.SHA3_224, 224/8, 64),
+	}
+}
+
+type sha3_224Hash struct {
+	*evpHash
+	out [224 / 8]byte
+}
+
+func (h *sha3_224Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// NewSHA3_256 returns a new SHA3-256 hash.
+func NewSHA3_256() hash.Hash {
+	return &sha3_256Hash{
+		evpHash: newEvpHash(crypto.SHA3_256, 256/8, 64),
+	}
+}
+
+type sha3_256Hash struct {
+	*evpHash
+	out [256 / 8]byte
+}
+
+func (h *sha3_256Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// NewSHA3_384 returns a new SHA3-384 hash.
+func NewSHA3_384() hash.Hash {
+	return &sha3_384Hash{
+		evpHash: newEvpHash(crypto.SHA3_384, 384/8, 128),
+	}
+}
+
+type sha3_384Hash struct {
+	*evpHash
+	out [384 / 8]byte
+}
+
+func (h *sha3_384Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// NewSHA3_512 returns a new SHA3-512 hash.
+func NewSHA3_512() hash.Hash {
+	return &sha3_512Hash{
+		evpHash: newEvpHash(crypto.SHA3_512, 512/8, 128),
+	}
+}
+
+type sha3_512Hash struct {
+	*evpHash
+	out [512 / 8]byte
+}
+
+func (h *sha3_512Hash) Sum(in []byte) []byte {
+	h.sum(h.out[:])
+	return append(in, h.out[:]...)
+}
+
+// appendUint64 appends x into b as a big endian byte sequence.
+func appendUint64(b []byte, x uint64) []byte {
+	return append(b,
+		byte(x>>56),
+		byte(x>>48),
+		byte(x>>40),
+		byte(x>>32),
+		byte(x>>24),
+		byte(x>>16),
+		byte(x>>8),
+		byte(x),
+	)
+}
+
+// appendUint32 appends x into b as a big endian byte sequence.
+func appendUint32(b []byte, x uint32) []byte {
+	return append(b, byte(x>>24), byte(x>>16), byte(x>>8), byte(x))
+}
+
+// consumeUint64 reads a big endian uint64 number from b.
+func consumeUint64(b []byte) ([]byte, uint64) {
+	_ = b[7]
+	x := uint64(b[7]) | uint64(b[6])<<8 | uint64(b[5])<<16 | uint64(b[4])<<24 |
+		uint64(b[3])<<32 | uint64(b[2])<<40 | uint64(b[1])<<48 | uint64(b[0])<<56
+	return b[8:], x
+}
+
+// consumeUint32 reads a big endian uint32 number from b.
+func consumeUint32(b []byte) ([]byte, uint32) {
+	_ = b[3]
+	x := uint32(b[3]) | uint32(b[2])<<8 | uint32(b[1])<<16 | uint32(b[0])<<24
+	return b[4:], x
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/hkdf.go b/src/vendor/github.com/golang-fips/openssl/v2/hkdf.go
new file mode 100644
index 0000000000..61cf483fed
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/hkdf.go
@@ -0,0 +1,174 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"errors"
+	"hash"
+	"io"
+	"runtime"
+	"unsafe"
+)
+
+func SupportsHKDF() bool {
+	return versionAtOrAbove(1, 1, 1)
+}
+
+func newHKDF(h func() hash.Hash, mode C.int) (*hkdf, error) {
+	if !SupportsHKDF() {
+		return nil, errUnsupportedVersion()
+	}
+
+	ch := h()
+	md := hashToMD(ch)
+	if md == nil {
+		return nil, errors.New("unsupported hash function")
+	}
+
+	ctx := C.go_openssl_EVP_PKEY_CTX_new_id(C.GO_EVP_PKEY_HKDF, nil)
+	if ctx == nil {
+		return nil, newOpenSSLError("EVP_PKEY_CTX_new_id")
+	}
+	defer func() {
+		C.go_openssl_EVP_PKEY_CTX_free(ctx)
+	}()
+
+	if C.go_openssl_EVP_PKEY_derive_init(ctx) != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive_init")
+	}
+	switch vMajor {
+	case 3:
+		if C.go_openssl_EVP_PKEY_CTX_set_hkdf_mode(ctx, mode) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_set_hkdf_mode")
+		}
+		if C.go_openssl_EVP_PKEY_CTX_set_hkdf_md(ctx, md) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_set_hkdf_md")
+		}
+	case 1:
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, -1, C.GO1_EVP_PKEY_OP_DERIVE,
+			C.GO_EVP_PKEY_CTRL_HKDF_MODE,
+			C.int(mode), nil) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_set_hkdf_mode")
+		}
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, -1, C.GO1_EVP_PKEY_OP_DERIVE,
+			C.GO_EVP_PKEY_CTRL_HKDF_MD,
+			0, unsafe.Pointer(md)) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_set_hkdf_md")
+		}
+	}
+
+	c := &hkdf{ctx: ctx, hashLen: ch.Size()}
+	ctx = nil
+
+	runtime.SetFinalizer(c, (*hkdf).finalize)
+
+	return c, nil
+}
+
+type hkdf struct {
+	ctx C.GO_EVP_PKEY_CTX_PTR
+
+	hashLen int
+	buf     []byte
+}
+
+func (c *hkdf) finalize() {
+	if c.ctx != nil {
+		C.go_openssl_EVP_PKEY_CTX_free(c.ctx)
+	}
+}
+
+func (c *hkdf) Read(p []byte) (int, error) {
+	defer runtime.KeepAlive(c)
+
+	// EVP_PKEY_derive doesn't support incremental output, each call
+	// derives the key from scratch and returns the requested bytes.
+	// To implement io.Reader, we need to ask for len(c.buf) + len(p)
+	// bytes and copy the last derived len(p) bytes to p.
+	// We use c.buf to know how many bytes we've already derived and
+	// to avoid allocating the whole output buffer on each call.
+	prevLen := len(c.buf)
+	needLen := len(p)
+	remains := 255*c.hashLen - prevLen
+	// Check whether enough data can be generated.
+	if remains < needLen {
+		return 0, errors.New("hkdf: entropy limit reached")
+	}
+	c.buf = append(c.buf, make([]byte, needLen)...)
+	outLen := C.size_t(prevLen + needLen)
+	if C.go_openssl_EVP_PKEY_derive_wrapper(c.ctx, base(c.buf), outLen).result != 1 {
+		return 0, newOpenSSLError("EVP_PKEY_derive")
+	}
+	n := copy(p, c.buf[prevLen:outLen])
+	return n, nil
+}
+
+func ExtractHKDF(h func() hash.Hash, secret, salt []byte) ([]byte, error) {
+	c, err := newHKDF(h, C.GO_EVP_KDF_HKDF_MODE_EXTRACT_ONLY)
+	if err != nil {
+		return nil, err
+	}
+	switch vMajor {
+	case 3:
+		if C.go_openssl_EVP_PKEY_CTX_set1_hkdf_key(c.ctx,
+			base(secret), C.int(len(secret))) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_set1_hkdf_key")
+		}
+		if C.go_openssl_EVP_PKEY_CTX_set1_hkdf_salt(c.ctx,
+			base(salt), C.int(len(salt))) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_set1_hkdf_salt")
+		}
+	case 1:
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(c.ctx, -1, C.GO1_EVP_PKEY_OP_DERIVE,
+			C.GO_EVP_PKEY_CTRL_HKDF_KEY,
+			C.int(len(secret)), unsafe.Pointer(base(secret))) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_set1_hkdf_key")
+		}
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(c.ctx, -1, C.GO1_EVP_PKEY_OP_DERIVE,
+			C.GO_EVP_PKEY_CTRL_HKDF_SALT,
+			C.int(len(salt)), unsafe.Pointer(base(salt))) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_set1_hkdf_salt")
+		}
+	}
+	r := C.go_openssl_EVP_PKEY_derive_wrapper(c.ctx, nil, 0)
+	if r.result != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive_init")
+	}
+	out := make([]byte, r.keylen)
+	if C.go_openssl_EVP_PKEY_derive_wrapper(c.ctx, base(out), r.keylen).result != 1 {
+		return nil, newOpenSSLError("EVP_PKEY_derive")
+	}
+	return out[:r.keylen], nil
+}
+
+func ExpandHKDF(h func() hash.Hash, pseudorandomKey, info []byte) (io.Reader, error) {
+	c, err := newHKDF(h, C.GO_EVP_KDF_HKDF_MODE_EXPAND_ONLY)
+	if err != nil {
+		return nil, err
+	}
+	switch vMajor {
+	case 3:
+		if C.go_openssl_EVP_PKEY_CTX_set1_hkdf_key(c.ctx,
+			base(pseudorandomKey), C.int(len(pseudorandomKey))) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_set1_hkdf_key")
+		}
+		if C.go_openssl_EVP_PKEY_CTX_add1_hkdf_info(c.ctx,
+			base(info), C.int(len(info))) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_add1_hkdf_info")
+		}
+	case 1:
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(c.ctx, -1, C.GO1_EVP_PKEY_OP_DERIVE,
+			C.GO_EVP_PKEY_CTRL_HKDF_KEY,
+			C.int(len(pseudorandomKey)), unsafe.Pointer(base(pseudorandomKey))) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_set1_hkdf_key")
+		}
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(c.ctx, -1, C.GO1_EVP_PKEY_OP_DERIVE,
+			C.GO_EVP_PKEY_CTRL_HKDF_INFO,
+			C.int(len(info)), unsafe.Pointer(base(info))) != 1 {
+			return nil, newOpenSSLError("EVP_PKEY_CTX_add1_hkdf_info")
+		}
+	}
+	return c, nil
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/hmac.go b/src/vendor/github.com/golang-fips/openssl/v2/hmac.go
new file mode 100644
index 0000000000..ef8116ce66
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/hmac.go
@@ -0,0 +1,238 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"hash"
+	"runtime"
+	"sync"
+	"unsafe"
+)
+
+var paramDigest = C.CString("digest")
+
+var (
+	fetchHMACOnce sync.Once
+	evpHMAC       C.GO_EVP_MAC_PTR
+)
+
+// NewHMAC returns a new HMAC using OpenSSL.
+// The function h must return a hash implemented by
+// OpenSSL (for example, h could be openssl.NewSHA256).
+// If h is not recognized, NewHMAC returns nil.
+func NewHMAC(h func() hash.Hash, key []byte) hash.Hash {
+	ch := h()
+	md := hashToMD(ch)
+	if md == nil {
+		return nil
+	}
+
+	if len(key) == 0 {
+		// This is supported in OpenSSL/Standard lib and as such
+		// we must support it here. When using HMAC with a null key
+		// HMAC_Init will try and reuse the key from the ctx. This is
+		// not the behavior previously implemented, so as a workaround
+		// we pass an "empty" key.
+		key = make([]byte, C.GO_EVP_MAX_MD_SIZE)
+	}
+
+	switch vMajor {
+	case 1:
+		return newHMAC1(key, ch, md)
+	case 3:
+		return newHMAC3(key, ch, md)
+	default:
+		panic(errUnsupportedVersion())
+	}
+}
+
+// hmacCtx3 is used for OpenSSL 1.
+type hmacCtx1 struct {
+	ctx C.GO_HMAC_CTX_PTR
+}
+
+// hmacCtx3 is used for OpenSSL 3.
+type hmacCtx3 struct {
+	ctx C.GO_EVP_MAC_CTX_PTR
+	key []byte // only set for OpenSSL 3.0.0, 3.0.1, and 3.0.2.
+}
+
+type opensslHMAC struct {
+	ctx1      hmacCtx1
+	ctx3      hmacCtx3
+	size      int
+	blockSize int
+	sum       []byte
+}
+
+func newHMAC1(key []byte, h hash.Hash, md C.GO_EVP_MD_PTR) *opensslHMAC {
+	ctx := hmacCtxNew()
+	if ctx == nil {
+		panic("openssl: EVP_MAC_CTX_new failed")
+	}
+	if C.go_openssl_HMAC_Init_ex(ctx, unsafe.Pointer(&key[0]), C.int(len(key)), md, nil) == 0 {
+		panic(newOpenSSLError("HMAC_Init_ex failed"))
+	}
+	hmac := &opensslHMAC{
+		size:      h.Size(),
+		blockSize: h.BlockSize(),
+		ctx1:      hmacCtx1{ctx},
+	}
+	runtime.SetFinalizer(hmac, (*opensslHMAC).finalize)
+	return hmac
+}
+
+func newHMAC3(key []byte, h hash.Hash, md C.GO_EVP_MD_PTR) *opensslHMAC {
+	fetchHMACOnce.Do(func() {
+		name := C.CString("HMAC")
+		evpHMAC = C.go_openssl_EVP_MAC_fetch(nil, name, nil)
+		C.free(unsafe.Pointer(name))
+	})
+	if evpHMAC == nil {
+		panic("openssl: HMAC not supported")
+	}
+	ctx := C.go_openssl_EVP_MAC_CTX_new(evpHMAC)
+	if ctx == nil {
+		panic("openssl: EVP_MAC_CTX_new failed")
+	}
+	digest := C.go_openssl_EVP_MD_get0_name(md)
+	bld := C.go_openssl_OSSL_PARAM_BLD_new()
+	if bld == nil {
+		panic(newOpenSSLError("OSSL_PARAM_BLD_new"))
+	}
+	defer C.go_openssl_OSSL_PARAM_BLD_free(bld)
+	C.go_openssl_OSSL_PARAM_BLD_push_utf8_string(bld, paramDigest, digest, 0)
+	params := C.go_openssl_OSSL_PARAM_BLD_to_param(bld)
+	if params == nil {
+		panic(newOpenSSLError("OSSL_PARAM_BLD_to_param"))
+	}
+	defer C.go_openssl_OSSL_PARAM_free(params)
+	if C.go_openssl_EVP_MAC_init(ctx, base(key), C.size_t(len(key)), params) == 0 {
+		panic(newOpenSSLError("EVP_MAC_init failed"))
+	}
+	var hkey []byte
+	if vMinor == 0 && vPatch <= 2 {
+		// EVP_MAC_init only resets the ctx internal state if a key is passed
+		// when using OpenSSL 3.0.0, 3.0.1, and 3.0.2. Save a copy of the key
+		// in the context so Reset can use it later. New OpenSSL versions
+		// do not have this issue so it isn't necessary to save the key.
+		// See https://github.com/openssl/openssl/issues/17811.
+		hkey = make([]byte, len(key))
+		copy(hkey, key)
+	}
+	hmac := &opensslHMAC{
+		size:      h.Size(),
+		blockSize: h.BlockSize(),
+		ctx3:      hmacCtx3{ctx, hkey},
+	}
+	runtime.SetFinalizer(hmac, (*opensslHMAC).finalize)
+	return hmac
+}
+
+func (h *opensslHMAC) Reset() {
+	switch vMajor {
+	case 1:
+		if C.go_openssl_HMAC_Init_ex(h.ctx1.ctx, nil, 0, nil, nil) == 0 {
+			panic(newOpenSSLError("HMAC_Init_ex failed"))
+		}
+	case 3:
+		if C.go_openssl_EVP_MAC_init(h.ctx3.ctx, base(h.ctx3.key), C.size_t(len(h.ctx3.key)), nil) == 0 {
+			panic(newOpenSSLError("EVP_MAC_init failed"))
+		}
+	default:
+		panic(errUnsupportedVersion())
+	}
+
+	runtime.KeepAlive(h) // Next line will keep h alive too; just making doubly sure.
+	h.sum = nil
+}
+
+func (h *opensslHMAC) finalize() {
+	switch vMajor {
+	case 1:
+		hmacCtxFree(h.ctx1.ctx)
+	case 3:
+		C.go_openssl_EVP_MAC_CTX_free(h.ctx3.ctx)
+	default:
+		panic(errUnsupportedVersion())
+	}
+}
+
+func (h *opensslHMAC) Write(p []byte) (int, error) {
+	if len(p) > 0 {
+		switch vMajor {
+		case 1:
+			C.go_openssl_HMAC_Update(h.ctx1.ctx, base(p), C.size_t(len(p)))
+		case 3:
+			C.go_openssl_EVP_MAC_update(h.ctx3.ctx, base(p), C.size_t(len(p)))
+		default:
+			panic(errUnsupportedVersion())
+		}
+	}
+	runtime.KeepAlive(h)
+	return len(p), nil
+}
+
+func (h *opensslHMAC) Size() int {
+	return h.size
+}
+
+func (h *opensslHMAC) BlockSize() int {
+	return h.blockSize
+}
+
+func (h *opensslHMAC) Sum(in []byte) []byte {
+	if h.sum == nil {
+		size := h.Size()
+		h.sum = make([]byte, size)
+	}
+	// Make copy of context because Go hash.Hash mandates
+	// that Sum has no effect on the underlying stream.
+	// In particular it is OK to Sum, then Write more, then Sum again,
+	// and the second Sum acts as if the first didn't happen.
+	switch vMajor {
+	case 1:
+		ctx2 := hmacCtxNew()
+		if ctx2 == nil {
+			panic("openssl: HMAC_CTX_new failed")
+		}
+		defer hmacCtxFree(ctx2)
+		if C.go_openssl_HMAC_CTX_copy(ctx2, h.ctx1.ctx) == 0 {
+			panic("openssl: HMAC_CTX_copy failed")
+		}
+		C.go_openssl_HMAC_Final(ctx2, base(h.sum), nil)
+	case 3:
+		ctx2 := C.go_openssl_EVP_MAC_CTX_dup(h.ctx3.ctx)
+		if ctx2 == nil {
+			panic("openssl: EVP_MAC_CTX_dup failed")
+		}
+		defer C.go_openssl_EVP_MAC_CTX_free(ctx2)
+		C.go_openssl_EVP_MAC_final(ctx2, base(h.sum), nil, C.size_t(len(h.sum)))
+	default:
+		panic(errUnsupportedVersion())
+	}
+	return append(in, h.sum...)
+}
+
+func hmacCtxNew() C.GO_HMAC_CTX_PTR {
+	if vMajor == 1 && vMinor == 0 {
+		// 0x120 is the sizeof value when building against OpenSSL 1.0.2 on Ubuntu 16.04.
+		ctx := (C.GO_HMAC_CTX_PTR)(C.malloc(0x120))
+		if ctx != nil {
+			C.go_openssl_HMAC_CTX_init(ctx)
+		}
+		return ctx
+	}
+	return C.go_openssl_HMAC_CTX_new()
+}
+
+func hmacCtxFree(ctx C.GO_HMAC_CTX_PTR) {
+	if vMajor == 1 && vMinor == 0 {
+		C.go_openssl_HMAC_CTX_cleanup(ctx)
+		C.free(unsafe.Pointer(ctx))
+		return
+	}
+	C.go_openssl_HMAC_CTX_free(ctx)
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/init.go b/src/vendor/github.com/golang-fips/openssl/v2/init.go
new file mode 100644
index 0000000000..a14663298b
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/init.go
@@ -0,0 +1,64 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"errors"
+)
+
+// opensslInit loads and initialize OpenSSL.
+// If successful, it returns the major and minor OpenSSL version
+// as reported by the OpenSSL API.
+//
+// See Init() for details about file.
+func opensslInit(file string) (major, minor, patch uint, err error) {
+	// Load the OpenSSL shared library using dlopen.
+	handle, err := dlopen(file)
+	if err != nil {
+		return 0, 0, 0, err
+	}
+
+	// Retrieve the loaded OpenSSL version and check if it is supported.
+	// Notice that major and minor could not match with the version parameter
+	// in case the name of the shared library file differs from the OpenSSL
+	// version it contains.
+	imajor := int(C.go_openssl_version_major(handle))
+	iminor := int(C.go_openssl_version_minor(handle))
+	ipatch := int(C.go_openssl_version_patch(handle))
+	if imajor < 0 || iminor < 0 || ipatch < 0 {
+		return 0, 0, 0, errors.New("openssl: can't retrieve OpenSSL version")
+	}
+	major, minor, patch = uint(imajor), uint(iminor), uint(ipatch)
+	var supported bool
+	if major == 1 {
+		supported = minor == 0 || minor == 1
+	} else if major == 3 {
+		// OpenSSL guarantees API and ABI compatibility within the same major version since OpenSSL 3.
+		supported = true
+	}
+	if !supported {
+		return 0, 0, 0, errUnsupportedVersion()
+	}
+
+	// Load the OpenSSL functions.
+	// See shims.go for the complete list of supported functions.
+	C.go_openssl_load_functions(handle, C.uint(major), C.uint(minor), C.uint(patch))
+
+	// Initialize OpenSSL.
+	C.go_openssl_OPENSSL_init()
+	if major == 1 && minor == 0 {
+		if C.go_openssl_thread_setup() != 1 {
+			return 0, 0, 0, fail("openssl: thread setup")
+		}
+		C.go_openssl_OPENSSL_add_all_algorithms_conf()
+		C.go_openssl_ERR_load_crypto_strings()
+	} else {
+		flags := C.uint64_t(C.GO_OPENSSL_INIT_ADD_ALL_CIPHERS | C.GO_OPENSSL_INIT_ADD_ALL_DIGESTS | C.GO_OPENSSL_INIT_LOAD_CONFIG | C.GO_OPENSSL_INIT_LOAD_CRYPTO_STRINGS)
+		if C.go_openssl_OPENSSL_init_crypto(flags, nil) != 1 {
+			return 0, 0, 0, fail("openssl: init crypto")
+		}
+	}
+	return major, minor, patch, nil
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/init_unix.go b/src/vendor/github.com/golang-fips/openssl/v2/init_unix.go
new file mode 100644
index 0000000000..5c09da86ee
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/init_unix.go
@@ -0,0 +1,31 @@
+//go:build unix && !cmd_go_bootstrap
+
+package openssl
+
+// #cgo LDFLAGS: -ldl -pthread
+// #include <stdlib.h>
+// #include <dlfcn.h>
+import "C"
+import (
+	"errors"
+	"unsafe"
+)
+
+func dlopen(file string) (handle unsafe.Pointer, err error) {
+	cv := C.CString(file)
+	defer C.free(unsafe.Pointer(cv))
+	handle = C.dlopen(cv, C.RTLD_LAZY|C.RTLD_LOCAL)
+	if handle == nil {
+		errstr := C.GoString(C.dlerror())
+		return nil, errors.New("openssl: can't load " + file + ": " + errstr)
+	}
+	return handle, nil
+}
+
+func dlclose(handle unsafe.Pointer) error {
+	if C.dlclose(handle) != 0 {
+		errstr := C.GoString(C.dlerror())
+		return errors.New("openssl: can't close libcrypto: " + errstr)
+	}
+	return nil
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/init_windows.go b/src/vendor/github.com/golang-fips/openssl/v2/init_windows.go
new file mode 100644
index 0000000000..3778e21227
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/init_windows.go
@@ -0,0 +1,36 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+import (
+	"syscall"
+	"unsafe"
+)
+
+type dlopenError struct {
+	file string
+	err  error
+}
+
+func (e *dlopenError) Error() string {
+	return "openssl: can't load " + e.file + ": " + e.err.Error()
+}
+
+func (e *dlopenError) Unwrap() error {
+	return e.err
+}
+
+func dlopen(file string) (handle unsafe.Pointer, err error) {
+	// As Windows generally does not ship with a system OpenSSL library, let
+	// alone a FIPS 140 certified one, use the default library search order so
+	// that we preferentially load the DLL bundled with the application.
+	h, err := syscall.LoadLibrary(file)
+	if err != nil {
+		return nil, &dlopenError{file: file, err: err}
+	}
+	return unsafe.Pointer(h), nil
+}
+
+func dlclose(handle unsafe.Pointer) error {
+	return syscall.FreeLibrary(syscall.Handle(handle))
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/openssl.go b/src/vendor/github.com/golang-fips/openssl/v2/openssl.go
new file mode 100644
index 0000000000..691bb16f72
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/openssl.go
@@ -0,0 +1,419 @@
+//go:build !cmd_go_bootstrap
+
+// Package openssl provides access to OpenSSL cryptographic functions.
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"encoding/binary"
+	"errors"
+	"math/bits"
+	"runtime"
+	"strconv"
+	"strings"
+	"sync"
+	"unsafe"
+)
+
+var (
+	// vMajor and vMinor hold the major/minor OpenSSL version.
+	// It is only populated if Init has been called.
+	vMajor, vMinor, vPatch uint
+)
+
+var (
+	initOnce sync.Once
+	initErr  error
+)
+
+var nativeEndian binary.ByteOrder
+
+// CheckVersion checks if the OpenSSL version can be loaded
+// and if the FIPS mode is enabled.
+// This function can be called before Init.
+func CheckVersion(version string) (exists, fips bool) {
+	handle, _ := dlopen(version)
+	if handle == nil {
+		return false, false
+	}
+	defer dlclose(handle)
+	fips = C.go_openssl_fips_enabled(handle) == 1
+	return true, fips
+}
+
+// Init loads and initializes OpenSSL from the shared library at path.
+// It must be called before any other OpenSSL call, except CheckVersion.
+//
+// Only the first call to Init is effective.
+// Subsequent calls will return the same error result as the one from the first call.
+//
+// The file is passed to dlopen() verbatim to load the OpenSSL shared library.
+// For example, `file=libcrypto.so.1.1.1k-fips` makes Init look for the shared
+// library libcrypto.so.1.1.1k-fips.
+func Init(file string) error {
+	initOnce.Do(func() {
+		buf := [2]byte{}
+		*(*uint16)(unsafe.Pointer(&buf[0])) = uint16(0xABCD)
+
+		switch buf {
+		case [2]byte{0xCD, 0xAB}:
+			nativeEndian = binary.LittleEndian
+		case [2]byte{0xAB, 0xCD}:
+			nativeEndian = binary.BigEndian
+		default:
+			panic("Could not determine native endianness.")
+		}
+		vMajor, vMinor, vPatch, initErr = opensslInit(file)
+	})
+	return initErr
+}
+
+func utoa(n uint) string {
+	return strconv.FormatUint(uint64(n), 10)
+}
+
+func errUnsupportedVersion() error {
+	return errors.New("openssl: OpenSSL version: " + utoa(vMajor) + "." + utoa(vMinor) + "." + utoa(vPatch))
+}
+
+type fail string
+
+func (e fail) Error() string { return "openssl: " + string(e) + " failed" }
+
+// VersionText returns the version text of the OpenSSL currently loaded.
+func VersionText() string {
+	return C.GoString(C.go_openssl_OpenSSL_version(0))
+}
+
+var (
+	providerNameFips    = C.CString("fips")
+	providerNameDefault = C.CString("default")
+)
+
+// FIPS returns true if OpenSSL is running in FIPS mode, else returns false.
+func FIPS() bool {
+	switch vMajor {
+	case 1:
+		return C.go_openssl_FIPS_mode() == 1
+	case 3:
+		// If FIPS is not enabled via default properties, then we are sure FIPS is not used.
+		if C.go_openssl_EVP_default_properties_is_fips_enabled(nil) == 0 {
+			return false
+		}
+		// EVP_default_properties_is_fips_enabled can return true even if the FIPS provider isn't loaded,
+		// it is only based on the default properties.
+		// We can be sure that the FIPS provider is available if we can fetch an algorithm, e.g., SHA2-256,
+		// explicitly setting `fips=yes`.
+		return C.go_openssl_OSSL_PROVIDER_available(nil, providerNameFips) == 1
+	default:
+		panic(errUnsupportedVersion())
+	}
+}
+
+// SetFIPS enables or disables FIPS mode.
+//
+// For OpenSSL 3, the `fips` provider is loaded if enabled is true,
+// else the `default` provider is loaded.
+func SetFIPS(enabled bool) error {
+	var mode C.int
+	if enabled {
+		mode = C.int(1)
+	} else {
+		mode = C.int(0)
+	}
+	switch vMajor {
+	case 1:
+		if C.go_openssl_FIPS_mode_set(mode) != 1 {
+			return newOpenSSLError("FIPS_mode_set")
+		}
+		return nil
+	case 3:
+		var provName *C.char
+		if enabled {
+			provName = providerNameFips
+		} else {
+			provName = providerNameDefault
+		}
+		// Check if there is any provider that matches props.
+		if C.go_openssl_OSSL_PROVIDER_available(nil, provName) != 1 {
+			// If not, fallback to provName provider.
+			if C.go_openssl_OSSL_PROVIDER_load(nil, provName) == nil {
+				return newOpenSSLError("OSSL_PROVIDER_try_load")
+			}
+			// Make sure we now have a provider available.
+			if C.go_openssl_OSSL_PROVIDER_available(nil, provName) != 1 {
+				return fail("SetFIPS(" + strconv.FormatBool(enabled) + ") not supported")
+			}
+		}
+		if C.go_openssl_EVP_default_properties_enable_fips(nil, mode) != 1 {
+			return newOpenSSLError("openssl: EVP_default_properties_enable_fips")
+		}
+		return nil
+	default:
+		panic(errUnsupportedVersion())
+	}
+}
+
+// noescape hides a pointer from escape analysis. noescape is
+// the identity function but escape analysis doesn't think the
+// output depends on the input. noescape is inlined and currently
+// compiles down to zero instructions.
+// USE CAREFULLY!
+//
+//go:nosplit
+func noescape(p unsafe.Pointer) unsafe.Pointer {
+	x := uintptr(p)
+	return unsafe.Pointer(x ^ 0)
+}
+
+var zero byte
+
+// addr converts p to its base addr, including a noescape along the way.
+// If p is nil, addr returns a non-nil pointer, so that the result can always
+// be dereferenced.
+//
+//go:nosplit
+func addr(p []byte) *byte {
+	if len(p) == 0 {
+		return &zero
+	}
+	return (*byte)(noescape(unsafe.Pointer(&p[0])))
+}
+
+// base returns the address of the underlying array in b,
+// being careful not to panic when b has zero length.
+func base(b []byte) *C.uchar {
+	if len(b) == 0 {
+		return nil
+	}
+	return (*C.uchar)(unsafe.Pointer(&b[0]))
+}
+
+func sbase(b []byte) *C.char {
+	if len(b) == 0 {
+		return nil
+	}
+	return (*C.char)(unsafe.Pointer(&b[0]))
+}
+
+func newOpenSSLError(msg string) error {
+	var b strings.Builder
+	b.WriteString(msg)
+	b.WriteString("\nopenssl error(s):")
+	for {
+		var (
+			e    C.ulong
+			file *C.char
+			line C.int
+		)
+		switch vMajor {
+		case 1:
+			e = C.go_openssl_ERR_get_error_line(&file, &line)
+		case 3:
+			e = C.go_openssl_ERR_get_error_all(&file, &line, nil, nil, nil)
+		default:
+			panic(errUnsupportedVersion())
+		}
+		if e == 0 {
+			break
+		}
+		b.WriteByte('\n')
+		var buf [256]byte
+		C.go_openssl_ERR_error_string_n(e, (*C.char)(unsafe.Pointer(&buf[0])), C.size_t(len(buf)))
+		b.WriteString(string(buf[:]) + "\n\t" + C.GoString(file) + ":" + strconv.Itoa(int(line)))
+	}
+	return errors.New(b.String())
+}
+
+var unknownFile = "<go code>\000"
+
+// caller reports file and line number information about function invocations on
+// the calling goroutine's stack, in a form suitable for passing to C code.
+// The argument skip is the number of stack frames to ascend, with 0 identifying
+// the caller of caller. The return values report the file name and line number
+// within the file of the corresponding call. The returned file is a C string
+// with static storage duration.
+func caller(skip int) (file *C.char, line C.int) {
+	_, f, l, ok := runtime.Caller(skip + 1)
+	if !ok {
+		f = unknownFile
+	}
+	// The underlying bytes of the file string are null-terminated rodata with
+	// static lifetimes, so can be safely passed to C without worrying about
+	// leaking memory or use-after-free.
+	return (*C.char)(noescape(unsafe.Pointer(unsafe.StringData(f)))), C.int(l)
+}
+
+// cryptoMalloc allocates n bytes of memory on the OpenSSL heap, which may be
+// different from the heap which C.malloc allocates on. The allocated object
+// must be freed using cryptoFree. cryptoMalloc is equivalent to the
+// OPENSSL_malloc macro.
+//
+// Like C.malloc, this function is guaranteed to never return nil. If OpenSSL's
+// malloc indicates out of memory, it crashes the program.
+//
+// Only objects which the OpenSSL library will take ownership of (i.e. will be
+// freed by OPENSSL_free / CRYPTO_free) need to be allocated on the OpenSSL
+// heap.
+func cryptoMalloc(n int) unsafe.Pointer {
+	file, line := caller(1)
+	var p unsafe.Pointer
+	if vMajor == 1 && vMinor == 0 {
+		p = C.go_openssl_CRYPTO_malloc_legacy102(C.int(n), file, line)
+	} else {
+		p = C.go_openssl_CRYPTO_malloc(C.size_t(n), file, line)
+	}
+	if p == nil {
+		// Un-recover()-ably crash the program in the same manner as the
+		// C.malloc() wrapper function.
+		runtime_throw("openssl: CRYPTO_malloc failed")
+	}
+	return p
+}
+
+// cryptoFree frees an object allocated on the OpenSSL heap, which may be
+// different from the heap which C.malloc allocates on. cryptoFree is equivalent
+// to the OPENSSL_free macro.
+func cryptoFree(p unsafe.Pointer) {
+	if vMajor == 1 && vMinor == 0 {
+		C.go_openssl_CRYPTO_free_legacy102(p)
+		return
+	}
+	file, line := caller(1)
+	C.go_openssl_CRYPTO_free(p, file, line)
+}
+
+const wordBytes = bits.UintSize / 8
+
+// Reverse each limb of z.
+func (z BigInt) byteSwap() {
+	for i, d := range z {
+		var n uint = 0
+		for j := 0; j < wordBytes; j++ {
+			n |= uint(byte(d)) << (8 * (wordBytes - j - 1))
+			d >>= 8
+		}
+		z[i] = n
+	}
+}
+
+func wbase(b BigInt) *C.uchar {
+	if len(b) == 0 {
+		return nil
+	}
+	return (*C.uchar)(unsafe.Pointer(&b[0]))
+}
+
+// bignum_st_1_0_2 is bignum_st (BIGNUM) memory layout in OpenSSL 1.0.2.
+type bignum_st_1_0_2 struct {
+	d     unsafe.Pointer // Pointer to an array of BN_ULONG bit chunks
+	top   C.int          // Index of last used d +1
+	dmax  C.int
+	neg   C.int
+	flags C.int
+}
+
+func bigToBN(x BigInt) C.GO_BIGNUM_PTR {
+	if len(x) == 0 {
+		return nil
+	}
+
+	if vMajor == 1 && vMinor == 0 {
+		// OpenSSL 1.0.x does not export bn_lebin2bn on all platforms,
+		// so we have to emulate it.
+		bn := C.go_openssl_BN_new()
+		if bn == nil {
+			return nil
+		}
+		if C.go_openssl_bn_expand2(bn, C.int(len(x))) == nil {
+			C.go_openssl_BN_free(bn)
+			panic(newOpenSSLError("BN_expand2"))
+		}
+		// The bytes of a BigInt are laid out in memory in the same order as a
+		// BIGNUM, regardless of host endianness.
+		bns := (*bignum_st_1_0_2)(unsafe.Pointer(bn))
+		d := unsafe.Slice((*uint)(bns.d), len(x))
+		bns.top = C.int(copy(d, x))
+		return bn
+	}
+
+	if nativeEndian == binary.BigEndian {
+		z := make(BigInt, len(x))
+		copy(z, x)
+		z.byteSwap()
+		x = z
+	}
+	// Limbs are always ordered in LSB first, so we can safely apply
+	// BN_lebin2bn regardless of host endianness.
+	return C.go_openssl_BN_lebin2bn(wbase(x), C.int(len(x)*wordBytes), nil)
+}
+
+func bnToBig(bn C.GO_BIGNUM_PTR) BigInt {
+	if bn == nil {
+		return nil
+	}
+
+	if vMajor == 1 && vMinor == 0 {
+		// OpenSSL 1.0.x does not export bn_bn2lebinpad on all platforms,
+		// so we have to emulate it.
+		bns := (*bignum_st_1_0_2)(unsafe.Pointer(bn))
+		d := unsafe.Slice((*uint)(bns.d), bns.top)
+		x := make(BigInt, len(d))
+		copy(x, d)
+		return x
+	}
+
+	// Limbs are always ordered in LSB first, so we can safely apply
+	// BN_bn2lebinpad regardless of host endianness.
+	x := make(BigInt, C.go_openssl_BN_num_bits(bn))
+	if C.go_openssl_BN_bn2lebinpad(bn, wbase(x), C.int(len(x)*wordBytes)) == 0 {
+		panic("openssl: bignum conversion failed")
+	}
+	if nativeEndian == binary.BigEndian {
+		x.byteSwap()
+	}
+	return x
+}
+
+func bnNumBytes(bn C.GO_BIGNUM_PTR) int {
+	return (int(C.go_openssl_BN_num_bits(bn)) + 7) / 8
+}
+
+// bnToBinPad converts the absolute value of bn into big-endian form and stores
+// it at to, padding with zeroes if necessary. If len(to) is not large enough to
+// hold the result, an error is returned.
+func bnToBinPad(bn C.GO_BIGNUM_PTR, to []byte) error {
+	if vMajor == 1 && vMinor == 0 {
+		// OpenSSL 1.0.x does not export bn_bn2binpad on all platforms,
+		// so we have to emulate it.
+		n := bnNumBytes(bn)
+		pad := len(to) - n
+		if pad < 0 {
+			return errors.New("openssl: destination buffer too small")
+		}
+		for i := 0; i < pad; i++ {
+			to[i] = 0
+		}
+		if int(C.go_openssl_BN_bn2bin(bn, base(to[pad:]))) != n {
+			return errors.New("openssl: BN_bn2bin short write")
+		}
+		return nil
+	}
+
+	if C.go_openssl_BN_bn2binpad(bn, base(to), C.int(len(to))) < 0 {
+		return newOpenSSLError("BN_bn2binpad")
+	}
+	return nil
+}
+
+func CheckLeaks() {
+	C.go_openssl_do_leak_check()
+}
+
+// versionAtOrAbove returns true when
+// (vMajor, vMinor, vPatch) >= (major, minor, patch),
+// compared lexicographically.
+func versionAtOrAbove(major, minor, patch uint) bool {
+	return vMajor > major || (vMajor == major && vMinor > minor) || (vMajor == major && vMinor == minor && vPatch >= patch)
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/pbkdf2.go b/src/vendor/github.com/golang-fips/openssl/v2/pbkdf2.go
new file mode 100644
index 0000000000..a895eab2d5
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/pbkdf2.go
@@ -0,0 +1,28 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"errors"
+	"hash"
+)
+
+func PBKDF2(password, salt []byte, iter, keyLen int, h func() hash.Hash) ([]byte, error) {
+	md := hashToMD(h())
+	if md == nil {
+		return nil, errors.New("unsupported hash function")
+	}
+	if len(password) == 0 && vMajor == 1 && vMinor == 0 {
+		// x/crypto/pbkdf2 supports empty passwords, but OpenSSL 1.0.2
+		// does not. As a workaround, we pass an "empty" password.
+		password = make([]byte, C.GO_EVP_MAX_MD_SIZE)
+	}
+	out := make([]byte, keyLen)
+	ok := C.go_openssl_PKCS5_PBKDF2_HMAC(sbase(password), C.int(len(password)), base(salt), C.int(len(salt)), C.int(iter), md, C.int(keyLen), base(out))
+	if ok != 1 {
+		return nil, newOpenSSLError("PKCS5_PBKDF2_HMAC")
+	}
+	return out, nil
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/port_evp_md5_sha1.c b/src/vendor/github.com/golang-fips/openssl/v2/port_evp_md5_sha1.c
new file mode 100644
index 0000000000..50d49b1f10
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/port_evp_md5_sha1.c
@@ -0,0 +1,126 @@
+// The following is a partial backport of crypto/evp/m_md5_sha1.c,
+// commit cbc8a839959418d8a2c2e3ec6bdf394852c9501e on the
+// OpenSSL_1_1_0-stable branch.  The ctrl function has been removed.
+
+/*
+ * Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#include "goopenssl.h"
+
+#define NID_md5_sha1            114
+
+#define MD5_CBLOCK      64
+#define MD5_LBLOCK      (MD5_CBLOCK/4)
+#define MD5_DIGEST_LENGTH 16
+#define SHA_LBLOCK      16
+#define SHA_DIGEST_LENGTH 20
+
+#define EVP_PKEY_NULL_method    NULL,NULL,{0,0,0,0}
+
+// Change: MD5_LONG and SHA_LONG have been expanded to unsigned int,
+// which is always 32 bits. This avoids adding some obscure logic
+// to support 16-bit platforms.
+
+# define MD5_LONG unsigned int
+# define SHA_LONG unsigned int
+
+typedef struct env_md_st EVP_MD;
+typedef struct env_md_ctx_st EVP_MD_CTX;
+
+struct env_md_ctx_st {
+    void *digest;
+    void *engine;             
+    unsigned long flags;
+    void *md_data;
+    void *pctx;
+    void *update;
+} /* EVP_MD_CTX */ ;
+
+struct env_md_st {
+    int type;
+    int pkey_type;
+    int md_size;
+    unsigned long flags;
+    int (*init) (EVP_MD_CTX *ctx);
+    int (*update) (EVP_MD_CTX *ctx, const void *data, size_t count);
+    int (*final) (EVP_MD_CTX *ctx, unsigned char *md);
+    void *copy;
+    void *cleanup;
+    void *sign;
+    void *verify;
+    int required_pkey_type[5];
+    int block_size;
+    int ctx_size;
+    void *md_ctrl;
+} /* EVP_MD */ ;
+
+typedef struct MD5state_st {
+    MD5_LONG A, B, C, D;
+    MD5_LONG Nl, Nh;
+    MD5_LONG data[MD5_LBLOCK];
+    MD5_LONG num;
+} MD5_CTX;
+
+typedef struct SHAstate_st {
+    SHA_LONG h0, h1, h2, h3, h4;
+    SHA_LONG Nl, Nh;
+    SHA_LONG data[SHA_LBLOCK];
+    SHA_LONG num;
+} SHA_CTX;
+
+struct md5_sha1_ctx {
+    MD5_CTX md5;
+    SHA_CTX sha1;
+};
+
+static int md5_sha1_init(EVP_MD_CTX *ctx) {
+    struct md5_sha1_ctx *mctx = ctx->md_data;
+    if (!go_openssl_MD5_Init(&mctx->md5))
+        return 0;
+    return go_openssl_SHA1_Init(&mctx->sha1);
+}
+
+static int md5_sha1_update(EVP_MD_CTX *ctx, const void *data,
+                                           size_t count) {
+    struct md5_sha1_ctx *mctx = ctx->md_data;
+    if (!go_openssl_MD5_Update(&mctx->md5, data, count))
+        return 0;
+    return go_openssl_SHA1_Update(&mctx->sha1, data, count);
+}
+
+static int md5_sha1_final(EVP_MD_CTX *ctx, unsigned char *md) {
+    struct md5_sha1_ctx *mctx = ctx->md_data;
+    if (!go_openssl_MD5_Final(md, &mctx->md5))
+        return 0;
+    return go_openssl_SHA1_Final(md + MD5_DIGEST_LENGTH, &mctx->sha1);
+}
+
+// Change: Removed:
+// static int ctrl(EVP_MD_CTX *ctx, int cmd, int mslen, void *ms)
+
+static const EVP_MD md5_sha1_md = {
+    NID_md5_sha1,
+    NID_md5_sha1,
+    MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH,
+    0,
+    md5_sha1_init,
+    md5_sha1_update,
+    md5_sha1_final,
+    NULL,
+    NULL,
+    EVP_PKEY_NULL_method, // Change: inserted
+    MD5_CBLOCK,
+    sizeof(EVP_MD *) + sizeof(struct md5_sha1_ctx),
+    NULL, // Change: was ctrl
+};
+
+// Change: Apply name mangling.
+const GO_EVP_MD_PTR go_openssl_EVP_md5_sha1_backport(void) {
+    return (const GO_EVP_MD_PTR)&md5_sha1_md;
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/rand.go b/src/vendor/github.com/golang-fips/openssl/v2/rand.go
new file mode 100644
index 0000000000..9fd709635c
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/rand.go
@@ -0,0 +1,20 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import "unsafe"
+
+type randReader int
+
+func (randReader) Read(b []byte) (int, error) {
+	// Note: RAND_bytes should never fail; the return value exists only for historical reasons.
+	// We check it even so.
+	if len(b) > 0 && C.go_openssl_RAND_bytes((*C.uchar)(unsafe.Pointer(&b[0])), C.int(len(b))) == 0 {
+		return 0, newOpenSSLError("RAND_bytes")
+	}
+	return len(b), nil
+}
+
+const RandReader = randReader(0)
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/rc4.go b/src/vendor/github.com/golang-fips/openssl/v2/rc4.go
new file mode 100644
index 0000000000..f88150591e
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/rc4.go
@@ -0,0 +1,66 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import "runtime"
+
+// SupportsRC4 returns true if NewRC4Cipher is supported.
+func SupportsRC4() bool {
+	// True for stock OpenSSL 1 w/o FIPS.
+	// False for stock OpenSSL 3 unless the legacy provider is available.
+	return (versionAtOrAbove(1, 1, 0) || !FIPS()) && loadCipher(cipherRC4, cipherModeNone) != nil
+}
+
+// A RC4Cipher is an instance of RC4 using a particular key.
+type RC4Cipher struct {
+	ctx C.GO_EVP_CIPHER_CTX_PTR
+}
+
+// NewRC4Cipher creates and returns a new Cipher.
+func NewRC4Cipher(key []byte) (*RC4Cipher, error) {
+	ctx, err := newCipherCtx(cipherRC4, cipherModeNone, cipherOpEncrypt, key, nil)
+	if err != nil {
+		return nil, err
+	}
+	c := &RC4Cipher{ctx}
+	runtime.SetFinalizer(c, (*RC4Cipher).finalize)
+	return c, nil
+}
+
+func (c *RC4Cipher) finalize() {
+	if c.ctx != nil {
+		C.go_openssl_EVP_CIPHER_CTX_free(c.ctx)
+	}
+}
+
+// Reset zeros the key data and makes the Cipher unusable.
+func (c *RC4Cipher) Reset() {
+	if c.ctx != nil {
+		C.go_openssl_EVP_CIPHER_CTX_free(c.ctx)
+		c.ctx = nil
+	}
+}
+
+// XORKeyStream sets dst to the result of XORing src with the key stream.
+// Dst and src must overlap entirely or not at all.
+func (c *RC4Cipher) XORKeyStream(dst, src []byte) {
+	if c.ctx == nil || len(src) == 0 {
+		return
+	}
+	if inexactOverlap(dst[:len(src)], src) {
+		panic("crypto/rc4: invalid buffer overlap")
+	}
+	// panic if len(dst) < len(src) with a runtime out of bound error,
+	// which is what crypto/rc4 does.
+	_ = dst[len(src)-1]
+	var outLen C.int
+	if C.go_openssl_EVP_EncryptUpdate(c.ctx, base(dst), &outLen, base(src), C.int(len(src))) != 1 {
+		panic("crypto/cipher: EncryptUpdate failed")
+	}
+	if int(outLen) != len(src) {
+		panic("crypto/rc4: src not fully XORed")
+	}
+	runtime.KeepAlive(c)
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/rsa.go b/src/vendor/github.com/golang-fips/openssl/v2/rsa.go
new file mode 100644
index 0000000000..f28d323adc
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/rsa.go
@@ -0,0 +1,435 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"crypto"
+	"crypto/subtle"
+	"errors"
+	"hash"
+	"runtime"
+	"unsafe"
+)
+
+var (
+	paramRSA_N    = C.CString("n")
+	paramRSA_E    = C.CString("e")
+	paramRSA_D    = C.CString("d")
+	paramRSA_P    = C.CString("rsa-factor1")
+	paramRSA_Q    = C.CString("rsa-factor2")
+	paramRSA_Dp   = C.CString("rsa-exponent1")
+	paramRSA_Dq   = C.CString("rsa-exponent2")
+	paramRSA_Qinv = C.CString("rsa-coefficient1")
+)
+
+func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
+	bad := func(e error) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
+		return nil, nil, nil, nil, nil, nil, nil, nil, e
+	}
+	pkey, err := generateEVPPKey(C.GO_EVP_PKEY_RSA, bits, "")
+	if err != nil {
+		return bad(err)
+	}
+	defer C.go_openssl_EVP_PKEY_free(pkey)
+	switch vMajor {
+	case 1:
+		key := C.go_openssl_EVP_PKEY_get1_RSA(pkey)
+		if key == nil {
+			return bad(newOpenSSLError("EVP_PKEY_get1_RSA failed"))
+		}
+		defer C.go_openssl_RSA_free(key)
+		var n, e, d, p, q, dmp1, dmq1, iqmp C.GO_BIGNUM_PTR
+		if vMinor == 0 {
+			r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
+			n, e, d, p, q, dmp1, dmq1, iqmp = r.n, r.e, r.d, r.p, r.q, r.dmp1, r.dmq1, r.iqmp
+		} else {
+			C.go_openssl_RSA_get0_key(key, &n, &e, &d)
+			C.go_openssl_RSA_get0_factors(key, &p, &q)
+			C.go_openssl_RSA_get0_crt_params(key, &dmp1, &dmq1, &iqmp)
+		}
+		N, E, D = bnToBig(n), bnToBig(e), bnToBig(d)
+		P, Q = bnToBig(p), bnToBig(q)
+		Dp, Dq, Qinv = bnToBig(dmp1), bnToBig(dmq1), bnToBig(iqmp)
+	case 3:
+		tmp := C.go_openssl_BN_new()
+		if tmp == nil {
+			return bad(newOpenSSLError("BN_new failed"))
+		}
+		defer func() {
+			C.go_openssl_BN_clear_free(tmp)
+		}()
+		var err error
+		setBigInt := func(bi *BigInt, param *C.char) bool {
+			if err != nil {
+				return false
+			}
+			if C.go_openssl_EVP_PKEY_get_bn_param(pkey, param, &tmp) != 1 {
+				err = newOpenSSLError("EVP_PKEY_get_bn_param failed")
+				return false
+			}
+			*bi = bnToBig(tmp)
+			C.go_openssl_BN_clear(tmp)
+			return true
+		}
+		if !(setBigInt(&N, paramRSA_N) &&
+			setBigInt(&E, paramRSA_E) &&
+			setBigInt(&D, paramRSA_D) &&
+			setBigInt(&P, paramRSA_P) &&
+			setBigInt(&Q, paramRSA_Q) &&
+			setBigInt(&Dp, paramRSA_Dp) &&
+			setBigInt(&Dq, paramRSA_Dq) &&
+			setBigInt(&Qinv, paramRSA_Qinv)) {
+			return bad(err)
+		}
+	default:
+		panic(errUnsupportedVersion())
+	}
+	return
+}
+
+type PublicKeyRSA struct {
+	// _pkey MUST NOT be accessed directly. Instead, use the withKey method.
+	_pkey C.GO_EVP_PKEY_PTR
+}
+
+func NewPublicKeyRSA(N, E BigInt) (*PublicKeyRSA, error) {
+	var pkey C.GO_EVP_PKEY_PTR
+	switch vMajor {
+	case 1:
+		key := C.go_openssl_RSA_new()
+		if key == nil {
+			return nil, newOpenSSLError("RSA_new failed")
+		}
+		if !rsaSetKey(key, N, E, nil) {
+			return nil, fail("RSA_set0_key")
+		}
+		pkey = C.go_openssl_EVP_PKEY_new()
+		if pkey == nil {
+			C.go_openssl_RSA_free(key)
+			return nil, newOpenSSLError("EVP_PKEY_new failed")
+		}
+		if C.go_openssl_EVP_PKEY_assign(pkey, C.GO_EVP_PKEY_RSA, (unsafe.Pointer)(key)) != 1 {
+			C.go_openssl_RSA_free(key)
+			C.go_openssl_EVP_PKEY_free(pkey)
+			return nil, newOpenSSLError("EVP_PKEY_assign failed")
+		}
+	case 3:
+		var err error
+		if pkey, err = newRSAKey3(false, N, E, nil, nil, nil, nil, nil, nil); err != nil {
+			return nil, err
+		}
+	default:
+		panic(errUnsupportedVersion())
+	}
+	k := &PublicKeyRSA{_pkey: pkey}
+	runtime.SetFinalizer(k, (*PublicKeyRSA).finalize)
+	return k, nil
+}
+
+func (k *PublicKeyRSA) finalize() {
+	C.go_openssl_EVP_PKEY_free(k._pkey)
+}
+
+func (k *PublicKeyRSA) withKey(f func(C.GO_EVP_PKEY_PTR) C.int) C.int {
+	// Because of the finalizer, any time _pkey is passed to cgo, that call must
+	// be followed by a call to runtime.KeepAlive, to make sure k is not
+	// collected (and finalized) before the cgo call returns.
+	defer runtime.KeepAlive(k)
+	return f(k._pkey)
+}
+
+type PrivateKeyRSA struct {
+	// _pkey MUST NOT be accessed directly. Instead, use the withKey method.
+	_pkey C.GO_EVP_PKEY_PTR
+}
+
+func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv BigInt) (*PrivateKeyRSA, error) {
+	var pkey C.GO_EVP_PKEY_PTR
+	switch vMajor {
+	case 1:
+		key := C.go_openssl_RSA_new()
+		if key == nil {
+			return nil, newOpenSSLError("RSA_new failed")
+		}
+		if !rsaSetKey(key, N, E, D) {
+			return nil, fail("RSA_set0_key")
+		}
+		if P != nil && Q != nil {
+			if !rsaSetFactors(key, P, Q) {
+				return nil, fail("RSA_set0_factors")
+			}
+		}
+		if Dp != nil && Dq != nil && Qinv != nil {
+			if !rsaSetCRTParams(key, Dp, Dq, Qinv) {
+				return nil, fail("RSA_set0_crt_params")
+			}
+		}
+		pkey = C.go_openssl_EVP_PKEY_new()
+		if pkey == nil {
+			C.go_openssl_RSA_free(key)
+			return nil, newOpenSSLError("EVP_PKEY_new failed")
+		}
+		if C.go_openssl_EVP_PKEY_assign(pkey, C.GO_EVP_PKEY_RSA, (unsafe.Pointer)(key)) != 1 {
+			C.go_openssl_RSA_free(key)
+			C.go_openssl_EVP_PKEY_free(pkey)
+			return nil, newOpenSSLError("EVP_PKEY_assign failed")
+		}
+	case 3:
+		var err error
+		if pkey, err = newRSAKey3(true, N, E, D, P, Q, Dp, Dq, Qinv); err != nil {
+			return nil, err
+		}
+	default:
+		panic(errUnsupportedVersion())
+	}
+	k := &PrivateKeyRSA{_pkey: pkey}
+	runtime.SetFinalizer(k, (*PrivateKeyRSA).finalize)
+	return k, nil
+}
+
+func (k *PrivateKeyRSA) finalize() {
+	C.go_openssl_EVP_PKEY_free(k._pkey)
+}
+
+func (k *PrivateKeyRSA) withKey(f func(C.GO_EVP_PKEY_PTR) C.int) C.int {
+	// Because of the finalizer, any time _pkey is passed to cgo, that call must
+	// be followed by a call to runtime.KeepAlive, to make sure k is not
+	// collected (and finalized) before the cgo call returns.
+	defer runtime.KeepAlive(k)
+	return f(k._pkey)
+}
+
+func DecryptRSAOAEP(h, mgfHash hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
+	return evpDecrypt(priv.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, mgfHash, label, ciphertext)
+}
+
+func EncryptRSAOAEP(h, mgfHash hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
+	return evpEncrypt(pub.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, mgfHash, label, msg)
+}
+
+func DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	return evpDecrypt(priv.withKey, C.GO_RSA_PKCS1_PADDING, nil, nil, nil, ciphertext)
+}
+
+func EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	return evpEncrypt(pub.withKey, C.GO_RSA_PKCS1_PADDING, nil, nil, nil, msg)
+}
+
+func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	ret, err := evpDecrypt(priv.withKey, C.GO_RSA_NO_PADDING, nil, nil, nil, ciphertext)
+	if err != nil {
+		return nil, err
+	}
+	// We could return here, but the Go standard library test expects DecryptRSANoPadding to verify the result
+	// in order to defend against errors in the CRT computation.
+	//
+	// The following code tries to replicate the verification implemented in the upstream function decryptAndCheck, found at
+	// https://github.com/golang/go/blob/9de1ac6ac2cad3871760d0aa288f5ca713afd0a6/src/crypto/rsa/rsa.go#L569-L582.
+	pub := &PublicKeyRSA{_pkey: priv._pkey}
+	// A private EVP_PKEY can be used as a public key as it contains the public information.
+	enc, err := EncryptRSANoPadding(pub, ret)
+	if err != nil {
+		return nil, err
+	}
+	// Upstream does not do a constant time comparison because it works with math/big instead of byte slices,
+	// and math/big does not support constant-time arithmetic yet. See #20654 for more info.
+	if subtle.ConstantTimeCompare(ciphertext, enc) != 1 {
+		return nil, errors.New("rsa: internal error")
+	}
+	return ret, nil
+}
+
+func EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	return evpEncrypt(pub.withKey, C.GO_RSA_NO_PADDING, nil, nil, nil, msg)
+}
+
+func saltLength(saltLen int, sign bool) (C.int, error) {
+	// A salt length of -2 is valid in OpenSSL, but not in crypto/rsa, so reject
+	// it, and lengths < -2, before we convert to the OpenSSL sentinel values.
+	if saltLen <= -2 {
+		return 0, errors.New("crypto/rsa: PSSOptions.SaltLength cannot be negative")
+	}
+	// OpenSSL uses sentinel salt length values like Go crypto does,
+	// but the values don't fully match for rsa.PSSSaltLengthAuto (0).
+	if saltLen == 0 {
+		if sign {
+			if vMajor == 1 {
+				// OpenSSL 1.x uses -2 to mean maximal size when signing where Go crypto uses 0.
+				return C.GO_RSA_PSS_SALTLEN_MAX_SIGN, nil
+			}
+			// OpenSSL 3.x deprecated RSA_PSS_SALTLEN_MAX_SIGN
+			// and uses -3 to mean maximal size when signing where Go crypto uses 0.
+			return C.GO_RSA_PSS_SALTLEN_MAX, nil
+		}
+		// OpenSSL uses -2 to mean auto-detect size when verifying where Go crypto uses 0.
+		return C.GO_RSA_PSS_SALTLEN_AUTO, nil
+	}
+	return C.int(saltLen), nil
+}
+
+func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
+	cSaltLen, err := saltLength(saltLen, true)
+	if err != nil {
+		return nil, err
+	}
+	return evpSign(priv.withKey, C.GO_RSA_PKCS1_PSS_PADDING, cSaltLen, h, hashed)
+}
+
+func VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
+	cSaltLen, err := saltLength(saltLen, false)
+	if err != nil {
+		return err
+	}
+	return evpVerify(pub.withKey, C.GO_RSA_PKCS1_PSS_PADDING, cSaltLen, h, sig, hashed)
+}
+
+func SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
+	return evpSign(priv.withKey, C.GO_RSA_PKCS1_PADDING, 0, h, hashed)
+}
+
+func HashSignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, msg []byte) ([]byte, error) {
+	return evpHashSign(priv.withKey, h, msg)
+}
+
+func VerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
+	if pub.withKey(func(pkey C.GO_EVP_PKEY_PTR) C.int {
+		size := C.go_openssl_EVP_PKEY_get_size(pkey)
+		if len(sig) < int(size) {
+			return 0
+		}
+		return 1
+	}) == 0 {
+		return errors.New("crypto/rsa: verification error")
+	}
+	return evpVerify(pub.withKey, C.GO_RSA_PKCS1_PADDING, 0, h, sig, hashed)
+}
+
+func HashVerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, msg, sig []byte) error {
+	return evpHashVerify(pub.withKey, h, msg, sig)
+}
+
+// rsa_st_1_0_2 is rsa_st memory layout in OpenSSL 1.0.2.
+type rsa_st_1_0_2 struct {
+	_                C.int
+	_                C.long
+	_                [2]unsafe.Pointer
+	n, e, d          C.GO_BIGNUM_PTR
+	p, q             C.GO_BIGNUM_PTR
+	dmp1, dmq1, iqmp C.GO_BIGNUM_PTR
+	// It contains more fields, but we are not interesed on them.
+}
+
+func bnSet(b1 *C.GO_BIGNUM_PTR, b2 BigInt) {
+	if b2 == nil {
+		return
+	}
+	if *b1 != nil {
+		C.go_openssl_BN_clear_free(*b1)
+	}
+	*b1 = bigToBN(b2)
+}
+
+func rsaSetKey(key C.GO_RSA_PTR, n, e, d BigInt) bool {
+	if vMajor == 1 && vMinor == 0 {
+		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
+		//r.d and d will be nil for public keys.
+		if (r.n == nil && n == nil) ||
+			(r.e == nil && e == nil) {
+			return false
+		}
+		bnSet(&r.n, n)
+		bnSet(&r.e, e)
+		bnSet(&r.d, d)
+		return true
+	}
+	return C.go_openssl_RSA_set0_key(key, bigToBN(n), bigToBN(e), bigToBN(d)) == 1
+}
+
+func rsaSetFactors(key C.GO_RSA_PTR, p, q BigInt) bool {
+	if vMajor == 1 && vMinor == 0 {
+		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
+		if (r.p == nil && p == nil) ||
+			(r.q == nil && q == nil) {
+			return false
+		}
+		bnSet(&r.p, p)
+		bnSet(&r.q, q)
+		return true
+	}
+	return C.go_openssl_RSA_set0_factors(key, bigToBN(p), bigToBN(q)) == 1
+}
+
+func rsaSetCRTParams(key C.GO_RSA_PTR, dmp1, dmq1, iqmp BigInt) bool {
+	if vMajor == 1 && vMinor == 0 {
+		r := (*rsa_st_1_0_2)(unsafe.Pointer(key))
+		if (r.dmp1 == nil && dmp1 == nil) ||
+			(r.dmq1 == nil && dmq1 == nil) ||
+			(r.iqmp == nil && iqmp == nil) {
+			return false
+		}
+		bnSet(&r.dmp1, dmp1)
+		bnSet(&r.dmq1, dmq1)
+		bnSet(&r.iqmp, iqmp)
+		return true
+	}
+	return C.go_openssl_RSA_set0_crt_params(key, bigToBN(dmp1), bigToBN(dmq1), bigToBN(iqmp)) == 1
+}
+
+func newRSAKey3(isPriv bool, N, E, D, P, Q, Dp, Dq, Qinv BigInt) (C.GO_EVP_PKEY_PTR, error) {
+	// Construct the parameters.
+	bld := C.go_openssl_OSSL_PARAM_BLD_new()
+	if bld == nil {
+		return nil, newOpenSSLError("OSSL_PARAM_BLD_new")
+	}
+	defer C.go_openssl_OSSL_PARAM_BLD_free(bld)
+
+	type bigIntParam struct{
+		name *C.char
+		num  BigInt
+	}
+
+	comps := make([]bigIntParam, 0, 8)
+
+	required := [...]bigIntParam{
+		{paramRSA_N, N}, {paramRSA_E, E}, {paramRSA_D, D},
+	}
+	comps = append(comps, required[:]...)
+
+	// OpenSSL 3.0 and 3.1 required all the precomputed values if
+	// P and Q are present. See:
+	// https://github.com/openssl/openssl/pull/22334
+	if P != nil && Q != nil && Dp != nil && Dq != nil && Qinv != nil {
+		precomputed := [...]bigIntParam{
+			{paramRSA_P, P}, {paramRSA_Q, Q},
+			{paramRSA_Dp, Dp}, {paramRSA_Dq, Dq}, {paramRSA_Qinv, Qinv},
+		}
+		comps = append(comps, precomputed[:]...)
+	}
+
+	for _, comp := range comps {
+		if comp.num == nil {
+			continue
+		}
+		b := bigToBN(comp.num)
+		if b == nil {
+			return nil, newOpenSSLError("BN_lebin2bn failed")
+		}
+		// b must remain valid until OSSL_PARAM_BLD_to_param has been called.
+		defer C.go_openssl_BN_clear_free(b)
+		if C.go_openssl_OSSL_PARAM_BLD_push_BN(bld, comp.name, b) != 1 {
+			return nil, newOpenSSLError("OSSL_PARAM_BLD_push_BN")
+		}
+	}
+	params := C.go_openssl_OSSL_PARAM_BLD_to_param(bld)
+	if params == nil {
+		return nil, newOpenSSLError("OSSL_PARAM_BLD_to_param")
+	}
+	defer C.go_openssl_OSSL_PARAM_free(params)
+	selection := C.GO_EVP_PKEY_PUBLIC_KEY
+	if isPriv {
+		selection = C.GO_EVP_PKEY_KEYPAIR
+	}
+	return newEvpFromParams(C.GO_EVP_PKEY_RSA, C.int(selection), params)
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/shims.h b/src/vendor/github.com/golang-fips/openssl/v2/shims.h
new file mode 100644
index 0000000000..99656f0cf2
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/shims.h
@@ -0,0 +1,371 @@
+#include <stdlib.h> // size_t
+#include <stdint.h> // uint64_t
+
+// #include <openssl/crypto.h>
+enum {
+    GO_OPENSSL_INIT_LOAD_CRYPTO_STRINGS = 0x00000002L,
+    GO_OPENSSL_INIT_ADD_ALL_CIPHERS = 0x00000004L,
+    GO_OPENSSL_INIT_ADD_ALL_DIGESTS = 0x00000008L,
+    GO_OPENSSL_INIT_LOAD_CONFIG = 0x00000040L
+};
+
+// #include <openssl/evp.h>
+enum {
+    GO_EVP_CTRL_GCM_GET_TAG = 0x10,
+    GO_EVP_CTRL_GCM_SET_TAG = 0x11,
+    GO_EVP_PKEY_CTRL_MD = 1,
+    GO_EVP_PKEY_RSA = 6,
+    GO_EVP_PKEY_EC = 408,
+    GO_EVP_PKEY_TLS1_PRF = 1021,
+    GO_EVP_PKEY_HKDF = 1036,
+    GO_EVP_PKEY_ED25519 = 1087,
+    /* This is defined differently in OpenSSL 3 (1 << 11), but in our
+     * code it is only used in OpenSSL 1.
+    */
+    GO1_EVP_PKEY_OP_DERIVE = (1 << 10),
+    GO_EVP_MAX_MD_SIZE = 64,
+
+    GO_EVP_PKEY_PUBLIC_KEY = 0x86,
+    GO_EVP_PKEY_KEYPAIR = 0x87
+};
+
+// #include <openssl/ec.h>
+enum {
+    GO_EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID = 0x1001
+};
+
+// #include <openssl/kdf.h>
+enum {
+    GO_EVP_KDF_HKDF_MODE_EXTRACT_ONLY = 1,
+    GO_EVP_KDF_HKDF_MODE_EXPAND_ONLY = 2,
+
+    GO_EVP_PKEY_CTRL_TLS_MD = 0x1000,
+    GO_EVP_PKEY_CTRL_TLS_SECRET = 0x1001,
+    GO_EVP_PKEY_CTRL_TLS_SEED = 0x1002,
+    GO_EVP_PKEY_CTRL_HKDF_MD = 0x1003,
+    GO_EVP_PKEY_CTRL_HKDF_SALT = 0x1004,
+    GO_EVP_PKEY_CTRL_HKDF_KEY = 0x1005,
+    GO_EVP_PKEY_CTRL_HKDF_INFO = 0x1006,
+    GO_EVP_PKEY_CTRL_HKDF_MODE = 0x1007
+};
+
+typedef enum {
+    GO_POINT_CONVERSION_UNCOMPRESSED = 4,
+} point_conversion_form_t;
+
+// #include <openssl/obj_mac.h>
+enum {
+    GO_NID_X9_62_prime256v1 = 415,
+    GO_NID_secp224r1 = 713,
+    GO_NID_secp384r1 = 715,
+    GO_NID_secp521r1 = 716
+};
+
+// #include <openssl/rsa.h>
+enum {
+    GO_RSA_PKCS1_PADDING = 1,
+    GO_RSA_NO_PADDING = 3,
+    GO_RSA_PKCS1_OAEP_PADDING = 4,
+    GO_RSA_PKCS1_PSS_PADDING = 6,
+    GO_RSA_PSS_SALTLEN_DIGEST = -1,
+    GO_RSA_PSS_SALTLEN_AUTO = -2,
+    GO_RSA_PSS_SALTLEN_MAX_SIGN = -2,
+    GO_RSA_PSS_SALTLEN_MAX = -3,
+    GO_EVP_PKEY_CTRL_RSA_PADDING = 0x1001,
+    GO_EVP_PKEY_CTRL_RSA_PSS_SALTLEN = 0x1002,
+    GO_EVP_PKEY_CTRL_RSA_KEYGEN_BITS = 0x1003,
+    GO_EVP_PKEY_CTRL_RSA_MGF1_MD = 0x1005,
+    GO_EVP_PKEY_CTRL_RSA_OAEP_MD = 0x1009,
+    GO_EVP_PKEY_CTRL_RSA_OAEP_LABEL = 0x100A
+};
+
+typedef void* GO_OPENSSL_INIT_SETTINGS_PTR;
+typedef void* GO_OSSL_LIB_CTX_PTR;
+typedef void* GO_OSSL_PROVIDER_PTR;
+typedef void* GO_ENGINE_PTR;
+typedef void* GO_EVP_PKEY_PTR;
+typedef void* GO_EVP_PKEY_CTX_PTR;
+typedef void* GO_EVP_MD_PTR;
+typedef void* GO_EVP_MD_CTX_PTR;
+typedef void* GO_HMAC_CTX_PTR;
+typedef void* GO_EVP_CIPHER_PTR;
+typedef void* GO_EVP_CIPHER_CTX_PTR;
+typedef void* GO_EC_KEY_PTR;
+typedef void* GO_EC_POINT_PTR;
+typedef void* GO_EC_GROUP_PTR;
+typedef void* GO_RSA_PTR;
+typedef void* GO_BIGNUM_PTR;
+typedef void* GO_BN_CTX_PTR;
+typedef void* GO_EVP_MAC_PTR;
+typedef void* GO_EVP_MAC_CTX_PTR;
+typedef void* GO_OSSL_PARAM_BLD_PTR;
+typedef void* GO_OSSL_PARAM_PTR;
+typedef void* GO_CRYPTO_THREADID_PTR;
+typedef void* GO_EVP_SIGNATURE_PTR;
+
+// #include <openssl/md5.h>
+typedef void* GO_MD5_CTX_PTR;
+
+// #include <openssl/sha.h>
+typedef void* GO_SHA_CTX_PTR;
+
+// FOR_ALL_OPENSSL_FUNCTIONS is the list of all functions from libcrypto that are used in this package.
+// Forgetting to add a function here results in build failure with message reporting the function
+// that needs to be added.
+//
+// The purpose of FOR_ALL_OPENSSL_FUNCTIONS is to define all libcrypto functions
+// without depending on the openssl headers so it is easier to use this package
+// with an openssl version different that the one used at build time.
+//
+// The following macros may not be defined at this point,
+// they are not resolved here but just accumulated in FOR_ALL_OPENSSL_FUNCTIONS.
+//
+// DEFINEFUNC defines and loads openssl functions that can be directly called from Go as their signatures match
+// the OpenSSL API and do not require special logic.
+// The process will be aborted if the function can't be loaded.
+//
+// DEFINEFUNC_LEGACY_1_1 acts like DEFINEFUNC but only aborts the process if the function can't be loaded
+// when using 1.1.x. This indicates the function is required when using 1.1.x, but is unused when using later versions.
+// It also might not exist in later versions.
+//
+// DEFINEFUNC_LEGACY_1_0 acts like DEFINEFUNC but only aborts the process if the function can't be loaded
+// when using 1.0.x. This indicates the function is required when using 1.0.x, but is unused when using later versions.
+// It also might not exist in later versions.
+//
+// DEFINEFUNC_LEGACY_1 acts like DEFINEFUNC but only aborts the process if the function can't be loaded
+// when using 1.x. This indicates the function is required when using 1.x, but is unused when using later versions.
+// It also might not exist in later versions.
+//
+// DEFINEFUNC_1_1 acts like DEFINEFUNC but only aborts the process if function can't be loaded
+// when using 1.1.0 or higher.
+//
+// DEFINEFUNC_1_1_1 acts like DEFINEFUNC but only aborts the process if function can't be loaded
+// when using 1.1.1 or higher.
+//
+// DEFINEFUNC_3_0 acts like DEFINEFUNC but only aborts the process if function can't be loaded
+// when using 3.0.0 or higher.
+//
+// DEFINEFUNC_RENAMED_1_1 acts like DEFINEFUNC but tries to load the function using the new name when using >= 1.1.x
+// and the old name when using 1.0.2. In both cases the function will have the new name.
+//
+// DEFINEFUNC_RENAMED_3_0 acts like DEFINEFUNC but tries to load the function using the new name when using >= 3.x
+// and the old name when using 1.x. In both cases the function will have the new name.
+//
+// #include <openssl/crypto.h>
+// #include <openssl/err.h>
+// #include <openssl/rsa.h>
+// #include <openssl/hmac.h>
+// #include <openssl/ec.h>
+// #include <openssl/rand.h>
+// #include <openssl/evp.h>
+// #if OPENSSL_VERSION_NUMBER >= 0x30000000L
+// #include <openssl/provider.h>
+// #include <openssl/param_build.h>
+// #endif
+// #if OPENSSL_VERSION_NUMBER < 0x10100000L
+// #include <openssl/bn.h>
+// #endif
+#define FOR_ALL_OPENSSL_FUNCTIONS \
+DEFINEFUNC(void, ERR_error_string_n, (unsigned long e, char *buf, size_t len), (e, buf, len)) \
+DEFINEFUNC_LEGACY_1(unsigned long, ERR_get_error_line, (const char **file, int *line), (file, line)) \
+DEFINEFUNC_3_0(unsigned long, ERR_get_error_all, (const char **file, int *line, const char **func, const char **data, int *flags), (file, line, func, data, flags)) \
+DEFINEFUNC_RENAMED_1_1(const char *, OpenSSL_version, SSLeay_version, (int type), (type)) \
+DEFINEFUNC(void, OPENSSL_init, (void), ()) \
+DEFINEFUNC_LEGACY_1_0(void, ERR_load_crypto_strings, (void), ()) \
+DEFINEFUNC_LEGACY_1_0(void, ERR_remove_thread_state, (const GO_CRYPTO_THREADID_PTR tid), (tid)) \
+DEFINEFUNC_LEGACY_1_0(int, CRYPTO_num_locks, (void), ()) \
+DEFINEFUNC_LEGACY_1_0(int, CRYPTO_THREADID_set_callback, (void (*threadid_func) (GO_CRYPTO_THREADID_PTR)), (threadid_func)) \
+DEFINEFUNC_LEGACY_1_0(void, CRYPTO_THREADID_set_numeric, (GO_CRYPTO_THREADID_PTR id, unsigned long val), (id, val)) \
+DEFINEFUNC_LEGACY_1_0(void, CRYPTO_set_locking_callback, (void (*locking_function)(int mode, int n, const char *file, int line)), (locking_function)) \
+/* CRYPTO_malloc argument num changes from int to size_t in OpenSSL 1.1.0, */ \
+/* and CRYPTO_free has file and line arguments added. */ \
+/* Exclude them from headercheck tool when using previous OpenSSL versions. */ \
+/*check:from=1.1.0*/ DEFINEFUNC(void *, CRYPTO_malloc, (size_t num, const char *file, int line), (num, file, line)) \
+/*check:from=1.1.0*/ DEFINEFUNC(void, CRYPTO_free, (void *str, const char *file, int line), (str, file, line)) \
+DEFINEFUNC_LEGACY_1_0(void, OPENSSL_add_all_algorithms_conf, (void), ()) \
+DEFINEFUNC_1_1(int, OPENSSL_init_crypto, (uint64_t ops, const GO_OPENSSL_INIT_SETTINGS_PTR settings), (ops, settings)) \
+DEFINEFUNC_LEGACY_1(int, FIPS_mode, (void), ()) \
+DEFINEFUNC_LEGACY_1(int, FIPS_mode_set, (int r), (r)) \
+DEFINEFUNC_3_0(int, EVP_default_properties_is_fips_enabled, (GO_OSSL_LIB_CTX_PTR libctx), (libctx)) \
+DEFINEFUNC_3_0(int, EVP_default_properties_enable_fips, (GO_OSSL_LIB_CTX_PTR libctx, int enable), (libctx, enable)) \
+DEFINEFUNC_3_0(int, OSSL_PROVIDER_available, (GO_OSSL_LIB_CTX_PTR libctx, const char *name), (libctx, name)) \
+DEFINEFUNC_3_0(GO_OSSL_PROVIDER_PTR, OSSL_PROVIDER_load, (GO_OSSL_LIB_CTX_PTR libctx, const char *name), (libctx, name)) \
+DEFINEFUNC_3_0(GO_EVP_MD_PTR, EVP_MD_fetch, (GO_OSSL_LIB_CTX_PTR ctx, const char *algorithm, const char *properties), (ctx, algorithm, properties)) \
+DEFINEFUNC_3_0(void, EVP_MD_free, (GO_EVP_MD_PTR md), (md)) \
+DEFINEFUNC_3_0(const char *, EVP_MD_get0_name, (const GO_EVP_MD_PTR md), (md)) \
+DEFINEFUNC(int, RAND_bytes, (unsigned char *arg0, int arg1), (arg0, arg1)) \
+DEFINEFUNC_RENAMED_1_1(GO_EVP_MD_CTX_PTR, EVP_MD_CTX_new, EVP_MD_CTX_create, (void), ()) \
+DEFINEFUNC_RENAMED_1_1(void, EVP_MD_CTX_free, EVP_MD_CTX_destroy, (GO_EVP_MD_CTX_PTR ctx), (ctx)) \
+DEFINEFUNC(int, EVP_MD_CTX_copy, (GO_EVP_MD_CTX_PTR out, const GO_EVP_MD_CTX_PTR in), (out, in)) \
+DEFINEFUNC(int, EVP_Digest, (const void *data, size_t count, unsigned char *md, unsigned int *size, const GO_EVP_MD_PTR type, GO_ENGINE_PTR impl), (data, count, md, size, type, impl)) \
+DEFINEFUNC(int, EVP_DigestInit_ex, (GO_EVP_MD_CTX_PTR ctx, const GO_EVP_MD_PTR type, GO_ENGINE_PTR impl), (ctx, type, impl)) \
+DEFINEFUNC(int, EVP_DigestInit, (GO_EVP_MD_CTX_PTR ctx, const GO_EVP_MD_PTR type), (ctx, type)) \
+DEFINEFUNC(int, EVP_DigestUpdate, (GO_EVP_MD_CTX_PTR ctx, const void *d, size_t cnt), (ctx, d, cnt)) \
+DEFINEFUNC(int, EVP_DigestFinal, (GO_EVP_MD_CTX_PTR ctx, unsigned char *md, unsigned int *s), (ctx, md, s)) \
+DEFINEFUNC_1_1_1(int, EVP_DigestSign, (GO_EVP_MD_CTX_PTR ctx, unsigned char *sigret, size_t *siglen, const unsigned char *tbs, size_t tbslen), (ctx, sigret, siglen, tbs, tbslen)) \
+DEFINEFUNC(int, EVP_DigestSignInit, (GO_EVP_MD_CTX_PTR ctx, GO_EVP_PKEY_CTX_PTR *pctx, const GO_EVP_MD_PTR type, GO_ENGINE_PTR e, GO_EVP_PKEY_PTR pkey), (ctx, pctx, type, e, pkey)) \
+DEFINEFUNC(int, EVP_DigestSignFinal, (GO_EVP_MD_CTX_PTR ctx, unsigned char *sig, size_t *siglen), (ctx, sig, siglen)) \
+DEFINEFUNC(int, EVP_DigestVerifyInit, (GO_EVP_MD_CTX_PTR ctx, GO_EVP_PKEY_CTX_PTR *pctx, const GO_EVP_MD_PTR type, GO_ENGINE_PTR e, GO_EVP_PKEY_PTR pkey), (ctx, pctx, type, e, pkey)) \
+DEFINEFUNC(int, EVP_DigestVerifyFinal, (GO_EVP_MD_CTX_PTR ctx, const unsigned char *sig, size_t siglen), (ctx, sig, siglen)) \
+DEFINEFUNC_1_1_1(int, EVP_DigestVerify, (GO_EVP_MD_CTX_PTR ctx, const unsigned char *sigret, size_t siglen, const unsigned char *tbs, size_t tbslen), (ctx, sigret, siglen, tbs, tbslen)) \
+DEFINEFUNC_LEGACY_1_0(int, MD5_Init, (GO_MD5_CTX_PTR c), (c)) \
+DEFINEFUNC_LEGACY_1_0(int, MD5_Update, (GO_MD5_CTX_PTR c, const void *data, size_t len), (c, data, len)) \
+DEFINEFUNC_LEGACY_1_0(int, MD5_Final, (unsigned char *md, GO_MD5_CTX_PTR c), (md, c)) \
+DEFINEFUNC_LEGACY_1_0(int, SHA1_Init, (GO_SHA_CTX_PTR c), (c)) \
+DEFINEFUNC_LEGACY_1_0(int, SHA1_Update, (GO_SHA_CTX_PTR c, const void *data, size_t len), (c, data, len)) \
+DEFINEFUNC_LEGACY_1_0(int, SHA1_Final, (unsigned char *md, GO_SHA_CTX_PTR c), (md, c)) \
+DEFINEFUNC_1_1(const GO_EVP_MD_PTR, EVP_md5_sha1, (void), ()) \
+DEFINEFUNC(const GO_EVP_MD_PTR, EVP_md4, (void), ()) \
+DEFINEFUNC(const GO_EVP_MD_PTR, EVP_md5, (void), ()) \
+DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha1, (void), ()) \
+DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha224, (void), ()) \
+DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha256, (void), ()) \
+DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha384, (void), ()) \
+DEFINEFUNC(const GO_EVP_MD_PTR, EVP_sha512, (void), ()) \
+DEFINEFUNC_1_1_1(const GO_EVP_MD_PTR, EVP_sha3_224, (void), ()) \
+DEFINEFUNC_1_1_1(const GO_EVP_MD_PTR, EVP_sha3_256, (void), ()) \
+DEFINEFUNC_1_1_1(const GO_EVP_MD_PTR, EVP_sha3_384, (void), ()) \
+DEFINEFUNC_1_1_1(const GO_EVP_MD_PTR, EVP_sha3_512, (void), ()) \
+DEFINEFUNC_LEGACY_1_0(void, HMAC_CTX_init, (GO_HMAC_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC_LEGACY_1_0(void, HMAC_CTX_cleanup, (GO_HMAC_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC_LEGACY_1(int, HMAC_Init_ex, (GO_HMAC_CTX_PTR arg0, const void *arg1, int arg2, const GO_EVP_MD_PTR arg3, GO_ENGINE_PTR arg4), (arg0, arg1, arg2, arg3, arg4)) \
+DEFINEFUNC_LEGACY_1(int, HMAC_Update, (GO_HMAC_CTX_PTR arg0, const unsigned char *arg1, size_t arg2), (arg0, arg1, arg2)) \
+DEFINEFUNC_LEGACY_1(int, HMAC_Final, (GO_HMAC_CTX_PTR arg0, unsigned char *arg1, unsigned int *arg2), (arg0, arg1, arg2)) \
+DEFINEFUNC_LEGACY_1(int, HMAC_CTX_copy, (GO_HMAC_CTX_PTR dest, GO_HMAC_CTX_PTR src), (dest, src)) \
+DEFINEFUNC_LEGACY_1_1(void, HMAC_CTX_free, (GO_HMAC_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC_LEGACY_1_1(GO_HMAC_CTX_PTR, HMAC_CTX_new, (void), ()) \
+DEFINEFUNC(GO_EVP_CIPHER_CTX_PTR, EVP_CIPHER_CTX_new, (void), ()) \
+DEFINEFUNC(int, EVP_CIPHER_CTX_set_padding, (GO_EVP_CIPHER_CTX_PTR x, int padding), (x, padding)) \
+DEFINEFUNC(int, EVP_CipherInit_ex, (GO_EVP_CIPHER_CTX_PTR ctx, const GO_EVP_CIPHER_PTR type, GO_ENGINE_PTR impl, const unsigned char *key, const unsigned char *iv, int enc), (ctx, type, impl, key, iv, enc)) \
+DEFINEFUNC(int, EVP_CipherUpdate, (GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *out, int *outl, const unsigned char *in, int inl), (ctx, out, outl, in, inl)) \
+DEFINEFUNC(int, EVP_EncryptInit_ex, (GO_EVP_CIPHER_CTX_PTR ctx, const GO_EVP_CIPHER_PTR type, GO_ENGINE_PTR impl, const unsigned char *key, const unsigned char *iv), (ctx, type, impl, key, iv)) \
+DEFINEFUNC(int, EVP_EncryptUpdate, (GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *out, int *outl, const unsigned char *in, int inl), (ctx, out, outl, in, inl)) \
+DEFINEFUNC(int, EVP_EncryptFinal_ex, (GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *out, int *outl), (ctx, out, outl)) \
+DEFINEFUNC(int, EVP_DecryptInit_ex, (GO_EVP_CIPHER_CTX_PTR ctx, const GO_EVP_CIPHER_PTR type, GO_ENGINE_PTR impl, const unsigned char *key, const unsigned char *iv), (ctx, type, impl, key, iv)) \
+DEFINEFUNC(int, EVP_DecryptUpdate, (GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *out, int *outl, const unsigned char *in, int inl),	(ctx, out, outl, in, inl)) \
+DEFINEFUNC(int, EVP_DecryptFinal_ex, (GO_EVP_CIPHER_CTX_PTR ctx, unsigned char *outm, int *outl),	(ctx, outm, outl)) \
+DEFINEFUNC_3_0(GO_EVP_CIPHER_PTR, EVP_CIPHER_fetch, (GO_OSSL_LIB_CTX_PTR ctx, const char *algorithm, const char *properties), (ctx, algorithm, properties)) \
+DEFINEFUNC_3_0(const char *, EVP_CIPHER_get0_name, (const GO_EVP_CIPHER_PTR cipher), (cipher)) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_128_gcm, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_128_cbc, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_128_ctr, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_128_ecb, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_192_gcm, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_192_cbc, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_192_ctr, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_192_ecb, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_256_cbc, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_256_ctr, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_256_ecb, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_aes_256_gcm, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_des_ecb, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_des_cbc, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_des_ede3_ecb, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_des_ede3_cbc, (void), ()) \
+DEFINEFUNC(const GO_EVP_CIPHER_PTR, EVP_rc4, (void), ()) \
+DEFINEFUNC_RENAMED_3_0(int, EVP_CIPHER_get_block_size, EVP_CIPHER_block_size, (const GO_EVP_CIPHER_PTR cipher), (cipher)) \
+DEFINEFUNC(int, EVP_CIPHER_CTX_set_key_length, (GO_EVP_CIPHER_CTX_PTR x, int keylen), (x, keylen)) \
+DEFINEFUNC(void, EVP_CIPHER_CTX_free, (GO_EVP_CIPHER_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EVP_CIPHER_CTX_ctrl, (GO_EVP_CIPHER_CTX_PTR ctx, int type, int arg, void *ptr), (ctx, type, arg, ptr)) \
+DEFINEFUNC(GO_EVP_PKEY_PTR, EVP_PKEY_new, (void), ()) \
+DEFINEFUNC_1_1_1(GO_EVP_PKEY_PTR, EVP_PKEY_new_raw_private_key, (int type, GO_ENGINE_PTR e, const unsigned char *key, size_t keylen), (type, e, key, keylen)) \
+DEFINEFUNC_1_1_1(GO_EVP_PKEY_PTR, EVP_PKEY_new_raw_public_key, (int type, GO_ENGINE_PTR e, const unsigned char *key, size_t keylen), (type, e, key, keylen)) \
+/* EVP_PKEY_size and EVP_PKEY_get_bits pkey parameter is const since OpenSSL 1.1.1. */ \
+/* Exclude it from headercheck tool when using previous OpenSSL versions. */ \
+/*check:from=1.1.1*/ DEFINEFUNC_RENAMED_3_0(int, EVP_PKEY_get_size, EVP_PKEY_size, (const GO_EVP_PKEY_PTR pkey), (pkey)) \
+/*check:from=1.1.1*/ DEFINEFUNC_RENAMED_3_0(int, EVP_PKEY_get_bits, EVP_PKEY_bits, (const GO_EVP_PKEY_PTR pkey), (pkey)) \
+DEFINEFUNC(void, EVP_PKEY_free, (GO_EVP_PKEY_PTR arg0), (arg0)) \
+DEFINEFUNC_LEGACY_1(GO_RSA_PTR, EVP_PKEY_get1_RSA, (GO_EVP_PKEY_PTR pkey), (pkey)) \
+DEFINEFUNC_LEGACY_1(int, EVP_PKEY_assign, (GO_EVP_PKEY_PTR pkey, int type, void *key), (pkey, type, key)) \
+DEFINEFUNC(int, EVP_PKEY_verify, (GO_EVP_PKEY_CTX_PTR ctx, const unsigned char *sig, size_t siglen, const unsigned char *tbs, size_t tbslen), (ctx, sig, siglen, tbs, tbslen)) \
+DEFINEFUNC(GO_EVP_PKEY_CTX_PTR, EVP_PKEY_CTX_new, (GO_EVP_PKEY_PTR arg0, GO_ENGINE_PTR arg1), (arg0, arg1)) \
+DEFINEFUNC(GO_EVP_PKEY_CTX_PTR, EVP_PKEY_CTX_new_id, (int id, GO_ENGINE_PTR e), (id, e)) \
+DEFINEFUNC(int, EVP_PKEY_keygen_init, (GO_EVP_PKEY_CTX_PTR ctx), (ctx)) \
+DEFINEFUNC(int, EVP_PKEY_keygen, (GO_EVP_PKEY_CTX_PTR ctx, GO_EVP_PKEY_PTR *ppkey), (ctx, ppkey)) \
+DEFINEFUNC(void, EVP_PKEY_CTX_free, (GO_EVP_PKEY_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EVP_PKEY_CTX_ctrl, (GO_EVP_PKEY_CTX_PTR ctx, int keytype, int optype, int cmd, int p1, void *p2), (ctx, keytype, optype, cmd, p1, p2)) \
+DEFINEFUNC(int, EVP_PKEY_decrypt, (GO_EVP_PKEY_CTX_PTR arg0, unsigned char *arg1, size_t *arg2, const unsigned char *arg3, size_t arg4), (arg0, arg1, arg2, arg3, arg4)) \
+DEFINEFUNC(int, EVP_PKEY_encrypt, (GO_EVP_PKEY_CTX_PTR arg0, unsigned char *arg1, size_t *arg2, const unsigned char *arg3, size_t arg4), (arg0, arg1, arg2, arg3, arg4)) \
+DEFINEFUNC(int, EVP_PKEY_decrypt_init, (GO_EVP_PKEY_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EVP_PKEY_encrypt_init, (GO_EVP_PKEY_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EVP_PKEY_sign_init, (GO_EVP_PKEY_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EVP_PKEY_verify_init, (GO_EVP_PKEY_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EVP_PKEY_sign, (GO_EVP_PKEY_CTX_PTR arg0, unsigned char *arg1, size_t *arg2, const unsigned char *arg3, size_t arg4), (arg0, arg1, arg2, arg3, arg4)) \
+DEFINEFUNC(int, EVP_PKEY_derive_init, (GO_EVP_PKEY_CTX_PTR ctx), (ctx)) \
+DEFINEFUNC(int, EVP_PKEY_derive_set_peer, (GO_EVP_PKEY_CTX_PTR ctx, GO_EVP_PKEY_PTR peer), (ctx, peer)) \
+DEFINEFUNC(int, EVP_PKEY_derive, (GO_EVP_PKEY_CTX_PTR ctx, unsigned char *key, size_t *keylen), (ctx, key, keylen)) \
+DEFINEFUNC_LEGACY_1_0(void*, EVP_PKEY_get0, (GO_EVP_PKEY_PTR pkey), (pkey)) \
+DEFINEFUNC_LEGACY_1_1(GO_EC_KEY_PTR, EVP_PKEY_get0_EC_KEY, (GO_EVP_PKEY_PTR pkey), (pkey)) \
+DEFINEFUNC_3_0(int, EVP_PKEY_fromdata_init, (GO_EVP_PKEY_CTX_PTR ctx), (ctx)) \
+DEFINEFUNC_3_0(int, EVP_PKEY_fromdata, (GO_EVP_PKEY_CTX_PTR ctx, GO_EVP_PKEY_PTR *pkey, int selection, GO_OSSL_PARAM_PTR params), (ctx, pkey, selection, params)) \
+DEFINEFUNC_3_0(int, EVP_PKEY_set1_encoded_public_key, (GO_EVP_PKEY_PTR pkey, const unsigned char *pub, size_t publen), (pkey, pub, publen)) \
+DEFINEFUNC_3_0(size_t, EVP_PKEY_get1_encoded_public_key, (GO_EVP_PKEY_PTR pkey, unsigned char **ppub), (pkey, ppub)) \
+DEFINEFUNC_3_0(int, EVP_PKEY_get_bn_param, (const GO_EVP_PKEY_PTR pkey, const char *key_name, GO_BIGNUM_PTR *bn), (pkey, key_name, bn)) \
+DEFINEFUNC_LEGACY_1(GO_RSA_PTR, RSA_new, (void), ()) \
+DEFINEFUNC_LEGACY_1(void, RSA_free, (GO_RSA_PTR arg0), (arg0)) \
+DEFINEFUNC_LEGACY_1_1(int, RSA_set0_factors, (GO_RSA_PTR rsa, GO_BIGNUM_PTR p, GO_BIGNUM_PTR q), (rsa, p, q)) \
+DEFINEFUNC_LEGACY_1_1(int, RSA_set0_crt_params, (GO_RSA_PTR rsa, GO_BIGNUM_PTR dmp1, GO_BIGNUM_PTR dmp2, GO_BIGNUM_PTR iqmp), (rsa, dmp1, dmp2, iqmp)) \
+DEFINEFUNC_LEGACY_1_1(void, RSA_get0_crt_params, (const GO_RSA_PTR r, const GO_BIGNUM_PTR *dmp1, const GO_BIGNUM_PTR *dmq1, const GO_BIGNUM_PTR *iqmp), (r, dmp1, dmq1, iqmp)) \
+DEFINEFUNC_LEGACY_1_1(int, RSA_set0_key, (GO_RSA_PTR r, GO_BIGNUM_PTR n, GO_BIGNUM_PTR e, GO_BIGNUM_PTR d), (r, n, e, d)) \
+DEFINEFUNC_LEGACY_1_1(void, RSA_get0_factors, (const GO_RSA_PTR rsa, const GO_BIGNUM_PTR *p, const GO_BIGNUM_PTR *q), (rsa, p, q)) \
+DEFINEFUNC_LEGACY_1_1(void, RSA_get0_key, (const GO_RSA_PTR rsa, const GO_BIGNUM_PTR *n, const GO_BIGNUM_PTR *e, const GO_BIGNUM_PTR *d), (rsa, n, e, d)) \
+DEFINEFUNC(GO_BIGNUM_PTR, BN_new, (void), ()) \
+DEFINEFUNC(void, BN_free, (GO_BIGNUM_PTR arg0), (arg0)) \
+DEFINEFUNC(void, BN_clear, (GO_BIGNUM_PTR arg0), (arg0)) \
+DEFINEFUNC(void, BN_clear_free, (GO_BIGNUM_PTR arg0), (arg0)) \
+DEFINEFUNC(int, BN_num_bits, (const GO_BIGNUM_PTR arg0), (arg0)) \
+DEFINEFUNC(GO_BIGNUM_PTR, BN_bin2bn, (const unsigned char *arg0, int arg1, GO_BIGNUM_PTR arg2), (arg0, arg1, arg2)) \
+DEFINEFUNC_LEGACY_1_0(int, BN_bn2bin, (const GO_BIGNUM_PTR a, unsigned char *to), (a, to)) \
+DEFINEFUNC_LEGACY_1_0(GO_BIGNUM_PTR, bn_expand2, (GO_BIGNUM_PTR a, int n), (a, n)) \
+DEFINEFUNC_1_1(GO_BIGNUM_PTR, BN_lebin2bn, (const unsigned char *s, int len, GO_BIGNUM_PTR ret), (s, len, ret)) \
+DEFINEFUNC_1_1(int, BN_bn2lebinpad, (const GO_BIGNUM_PTR a, unsigned char *to, int tolen), (a, to, tolen)) \
+DEFINEFUNC_1_1(int, BN_bn2binpad, (const GO_BIGNUM_PTR a, unsigned char *to, int tolen), (a, to, tolen)) \
+DEFINEFUNC_LEGACY_1(int, EC_KEY_set_public_key_affine_coordinates, (GO_EC_KEY_PTR key, GO_BIGNUM_PTR x, GO_BIGNUM_PTR y), (key, x, y)) \
+DEFINEFUNC_LEGACY_1(int, EC_KEY_set_public_key, (GO_EC_KEY_PTR key, const GO_EC_POINT_PTR pub), (key, pub)) \
+DEFINEFUNC_LEGACY_1(void, EC_KEY_free, (GO_EC_KEY_PTR arg0), (arg0)) \
+DEFINEFUNC_LEGACY_1(const GO_EC_GROUP_PTR, EC_KEY_get0_group, (const GO_EC_KEY_PTR arg0), (arg0)) \
+DEFINEFUNC_LEGACY_1(const GO_BIGNUM_PTR, EC_KEY_get0_private_key, (const GO_EC_KEY_PTR arg0), (arg0)) \
+DEFINEFUNC_LEGACY_1(const GO_EC_POINT_PTR, EC_KEY_get0_public_key, (const GO_EC_KEY_PTR arg0), (arg0)) \
+DEFINEFUNC_LEGACY_1(GO_EC_KEY_PTR, EC_KEY_new_by_curve_name, (int arg0), (arg0)) \
+DEFINEFUNC_LEGACY_1(int, EC_KEY_set_private_key, (GO_EC_KEY_PTR arg0, const GO_BIGNUM_PTR arg1), (arg0, arg1)) \
+DEFINEFUNC(GO_EC_POINT_PTR, EC_POINT_new, (const GO_EC_GROUP_PTR arg0), (arg0)) \
+DEFINEFUNC(void, EC_POINT_free, (GO_EC_POINT_PTR arg0), (arg0)) \
+DEFINEFUNC(int, EC_POINT_mul, (const GO_EC_GROUP_PTR group, GO_EC_POINT_PTR r, const GO_BIGNUM_PTR n, const GO_EC_POINT_PTR q, const GO_BIGNUM_PTR m, GO_BN_CTX_PTR ctx), (group, r, n, q, m, ctx)) \
+DEFINEFUNC_LEGACY_1(int, EC_POINT_get_affine_coordinates_GFp, (const GO_EC_GROUP_PTR arg0, const GO_EC_POINT_PTR arg1, GO_BIGNUM_PTR arg2, GO_BIGNUM_PTR arg3, GO_BN_CTX_PTR arg4), (arg0, arg1, arg2, arg3, arg4)) \
+DEFINEFUNC_3_0(int, EC_POINT_set_affine_coordinates, (const GO_EC_GROUP_PTR arg0, GO_EC_POINT_PTR arg1, const GO_BIGNUM_PTR arg2, const GO_BIGNUM_PTR arg3, GO_BN_CTX_PTR arg4), (arg0, arg1, arg2, arg3, arg4)) \
+DEFINEFUNC(size_t, EC_POINT_point2oct, (const GO_EC_GROUP_PTR group, const GO_EC_POINT_PTR p, point_conversion_form_t form, unsigned char *buf, size_t len, GO_BN_CTX_PTR ctx), (group, p, form, buf, len, ctx)) \
+DEFINEFUNC(int, EC_POINT_oct2point, (const GO_EC_GROUP_PTR group, GO_EC_POINT_PTR p, const unsigned char *buf, size_t len, GO_BN_CTX_PTR ctx), (group, p, buf, len, ctx)) \
+DEFINEFUNC(const char *, OBJ_nid2sn, (int n), (n)) \
+DEFINEFUNC(GO_EC_GROUP_PTR, EC_GROUP_new_by_curve_name, (int nid), (nid)) \
+DEFINEFUNC(void, EC_GROUP_free, (GO_EC_GROUP_PTR group), (group)) \
+DEFINEFUNC_3_0(GO_EVP_MAC_PTR, EVP_MAC_fetch, (GO_OSSL_LIB_CTX_PTR ctx, const char *algorithm, const char *properties), (ctx, algorithm, properties)) \
+DEFINEFUNC_3_0(GO_EVP_MAC_CTX_PTR, EVP_MAC_CTX_new, (GO_EVP_MAC_PTR arg0), (arg0)) \
+DEFINEFUNC_3_0(void, EVP_MAC_CTX_free, (GO_EVP_MAC_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC_3_0(GO_EVP_MAC_CTX_PTR, EVP_MAC_CTX_dup, (const GO_EVP_MAC_CTX_PTR arg0), (arg0)) \
+DEFINEFUNC_3_0(int, EVP_MAC_init, (GO_EVP_MAC_CTX_PTR ctx, const unsigned char *key, size_t keylen, const GO_OSSL_PARAM_PTR params), (ctx, key, keylen, params)) \
+DEFINEFUNC_3_0(int, EVP_MAC_update, (GO_EVP_MAC_CTX_PTR ctx, const unsigned char *data, size_t datalen), (ctx, data, datalen)) \
+DEFINEFUNC_3_0(int, EVP_MAC_final, (GO_EVP_MAC_CTX_PTR ctx, unsigned char *out, size_t *outl, size_t outsize), (ctx, out, outl, outsize)) \
+DEFINEFUNC_3_0(void, OSSL_PARAM_free, (GO_OSSL_PARAM_PTR p), (p)) \
+DEFINEFUNC_3_0(GO_OSSL_PARAM_BLD_PTR, OSSL_PARAM_BLD_new, (void), ()) \
+DEFINEFUNC_3_0(void, OSSL_PARAM_BLD_free, (GO_OSSL_PARAM_BLD_PTR bld), (bld)) \
+DEFINEFUNC_3_0(GO_OSSL_PARAM_PTR, OSSL_PARAM_BLD_to_param, (GO_OSSL_PARAM_BLD_PTR bld), (bld)) \
+DEFINEFUNC_3_0(int, OSSL_PARAM_BLD_push_utf8_string, (GO_OSSL_PARAM_BLD_PTR bld, const char *key, const char *buf, size_t bsize), (bld, key, buf, bsize)) \
+DEFINEFUNC_3_0(int, OSSL_PARAM_BLD_push_octet_string, (GO_OSSL_PARAM_BLD_PTR bld, const char *key, const void *buf, size_t bsize), (bld, key, buf, bsize)) \
+DEFINEFUNC_3_0(int, OSSL_PARAM_BLD_push_BN, (GO_OSSL_PARAM_BLD_PTR bld, const char *key, const GO_BIGNUM_PTR bn), (bld, key, bn)) \
+DEFINEFUNC_3_0(int, EVP_PKEY_CTX_set_hkdf_mode, (GO_EVP_PKEY_CTX_PTR arg0, int arg1), (arg0, arg1)) \
+DEFINEFUNC_3_0(int, EVP_PKEY_CTX_set_hkdf_md, (GO_EVP_PKEY_CTX_PTR arg0, const GO_EVP_MD_PTR arg1), (arg0, arg1)) \
+DEFINEFUNC_3_0(int, EVP_PKEY_CTX_set1_hkdf_salt, (GO_EVP_PKEY_CTX_PTR arg0, const unsigned char *arg1, int arg2), (arg0, arg1, arg2)) \
+DEFINEFUNC_3_0(int, EVP_PKEY_CTX_set1_hkdf_key, (GO_EVP_PKEY_CTX_PTR arg0, const unsigned char *arg1, int arg2), (arg0, arg1, arg2)) \
+DEFINEFUNC_3_0(int, EVP_PKEY_CTX_add1_hkdf_info, (GO_EVP_PKEY_CTX_PTR arg0, const unsigned char *arg1, int arg2), (arg0, arg1, arg2)) \
+DEFINEFUNC_3_0(int, EVP_PKEY_up_ref, (GO_EVP_PKEY_PTR key), (key)) \
+DEFINEFUNC_LEGACY_1(int, EVP_PKEY_set1_EC_KEY, (GO_EVP_PKEY_PTR pkey, GO_EC_KEY_PTR key), (pkey, key)) \
+DEFINEFUNC_3_0(int, EVP_PKEY_CTX_set0_rsa_oaep_label, (GO_EVP_PKEY_CTX_PTR ctx, void *label, int len), (ctx, label, len)) \
+DEFINEFUNC(int, PKCS5_PBKDF2_HMAC, (const char *pass, int passlen, const unsigned char *salt, int saltlen, int iter, const GO_EVP_MD_PTR digest, int keylen, unsigned char *out), (pass, passlen, salt, saltlen, iter, digest, keylen, out)) \
+DEFINEFUNC_3_0(int, EVP_PKEY_CTX_set_tls1_prf_md, (GO_EVP_PKEY_CTX_PTR arg0, const GO_EVP_MD_PTR arg1), (arg0, arg1)) \
+DEFINEFUNC_3_0(int, EVP_PKEY_CTX_set1_tls1_prf_secret, (GO_EVP_PKEY_CTX_PTR arg0, const unsigned char *arg1, int arg2), (arg0, arg1, arg2)) \
+DEFINEFUNC_3_0(int, EVP_PKEY_CTX_add1_tls1_prf_seed, (GO_EVP_PKEY_CTX_PTR arg0, const unsigned char *arg1, int arg2), (arg0, arg1, arg2)) \
+DEFINEFUNC_1_1_1(int, EVP_PKEY_get_raw_public_key, (const GO_EVP_PKEY_PTR pkey, unsigned char *pub, size_t *len), (pkey, pub, len)) \
+DEFINEFUNC_1_1_1(int, EVP_PKEY_get_raw_private_key, (const GO_EVP_PKEY_PTR pkey, unsigned char *priv, size_t *len), (pkey, priv, len)) \
+DEFINEFUNC_3_0(GO_EVP_SIGNATURE_PTR, EVP_SIGNATURE_fetch, (GO_OSSL_LIB_CTX_PTR ctx, const char *algorithm, const char *properties), (ctx, algorithm, properties)) \
+DEFINEFUNC_3_0(void, EVP_SIGNATURE_free, (GO_EVP_SIGNATURE_PTR signature), (signature)) \
+
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/thread_setup.go b/src/vendor/github.com/golang-fips/openssl/v2/thread_setup.go
new file mode 100644
index 0000000000..5e0da7e362
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/thread_setup.go
@@ -0,0 +1,14 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// Go wrappers for testing the thread setup code as _test.go files cannot import "C".
+
+// #include "thread_setup.h"
+import "C"
+
+// opensslThreadsCleanedUp returns the number of times the thread-local OpenSSL
+// state has been cleaned up since the process started.
+func opensslThreadsCleanedUp() uint {
+	return uint(C.go_openssl_threads_cleaned_up)
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/thread_setup.h b/src/vendor/github.com/golang-fips/openssl/v2/thread_setup.h
new file mode 100644
index 0000000000..98d12f82a2
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/thread_setup.h
@@ -0,0 +1,4 @@
+#define CRYPTO_LOCK 0x01
+
+/* Used by unit tests. */
+extern volatile unsigned int go_openssl_threads_cleaned_up;
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/thread_setup_unix.c b/src/vendor/github.com/golang-fips/openssl/v2/thread_setup_unix.c
new file mode 100644
index 0000000000..53ea9d03d7
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/thread_setup_unix.c
@@ -0,0 +1,61 @@
+//go:build unix
+
+#include "goopenssl.h"
+#include "thread_setup.h"
+#include <pthread.h>
+
+/* This array will store all of the mutexes available to OpenSSL. */ 
+static pthread_mutex_t *mutex_buf = NULL;
+
+static pthread_key_t destructor_key;
+
+/* Used by unit tests. */
+volatile unsigned int go_openssl_threads_cleaned_up = 0;
+
+static void locking_function(int mode, int n, const char *file, int line)
+{
+    if (mode & CRYPTO_LOCK)
+        pthread_mutex_lock(&mutex_buf[n]);
+    else
+        pthread_mutex_unlock(&mutex_buf[n]);
+}
+
+static void thread_id(GO_CRYPTO_THREADID_PTR tid)
+{
+    go_openssl_CRYPTO_THREADID_set_numeric(tid, (unsigned long)pthread_self());
+
+    // OpenSSL fetches the current thread ID whenever it does anything with the
+    // per-thread error state, so this function is guaranteed to be executed at
+    // least once on any thread with associated error state. The thread-local
+    // variable needs to be set to a non-NULL value so that the destructor will
+    // be called when the thread exits. The actual value does not matter.
+    (void) pthread_setspecific(destructor_key, (void*)1);
+}
+
+static void cleanup_thread_state(void *ignored)
+{
+    UNUSED(ignored);
+    go_openssl_ERR_remove_thread_state(NULL);
+    // ERR_remove_thread_state(NULL) in turn calls our registered thread_id
+    // callback via CRYPTO_THREADID_current(), which sets the thread-local
+    // variable associated with this destructor to a non-NULL value. We have to
+    // clear the variable ourselves to prevent pthreads from calling the
+    // destructor again for the same thread.
+    (void) pthread_setspecific(destructor_key, NULL);
+    go_openssl_threads_cleaned_up++;
+}
+
+int go_openssl_thread_setup(void)
+{
+    if (pthread_key_create(&destructor_key, cleanup_thread_state) != 0)
+        return 0;
+    mutex_buf = malloc(go_openssl_CRYPTO_num_locks()*sizeof(pthread_mutex_t));
+    if (!mutex_buf)
+        return 0;
+    int i;
+    for (i = 0; i < go_openssl_CRYPTO_num_locks(); i++)
+        pthread_mutex_init(&mutex_buf[i], NULL);
+    go_openssl_CRYPTO_THREADID_set_callback(thread_id);
+    go_openssl_CRYPTO_set_locking_callback(locking_function);
+    return 1;
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/thread_setup_windows.c b/src/vendor/github.com/golang-fips/openssl/v2/thread_setup_windows.c
new file mode 100644
index 0000000000..93281d6cff
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/thread_setup_windows.c
@@ -0,0 +1,64 @@
+//go:build windows
+
+#include "goopenssl.h"
+#include "thread_setup.h"
+
+#include <stdlib.h>
+#include <windows.h>
+
+/* This array will store all of the mutexes available to OpenSSL. */
+static HANDLE *mutex_buf = NULL;
+
+static DWORD fls_index = FLS_OUT_OF_INDEXES;
+
+/* Used by unit tests. */
+volatile unsigned int go_openssl_threads_cleaned_up = 0;
+
+static void locking_function(int mode, int n, const char *file, int line)
+{
+    if (mode & CRYPTO_LOCK)
+        WaitForSingleObject(mutex_buf[n], INFINITE);
+    else
+        ReleaseMutex(mutex_buf[n]);
+}
+
+static void thread_id(GO_CRYPTO_THREADID_PTR tid)
+{
+    go_openssl_CRYPTO_THREADID_set_numeric(tid, (unsigned long)GetCurrentThreadId());
+
+    // OpenSSL fetches the current thread ID whenever it does anything with the
+    // per-thread error state, so this function is guaranteed to be executed at
+    // least once on any thread with associated error state. As the Win32 API
+    // reference documentation is unclear on whether the fiber-local storage
+    // slot needs to be set to trigger the destructor on thread exit, set it to
+    // a non-NULL value just in case.
+    (void) FlsSetValue(fls_index, (void*)1);
+    go_openssl_threads_cleaned_up++;
+}
+
+static void cleanup_thread_state(void *ignored)
+{
+    UNUSED(ignored);
+    go_openssl_ERR_remove_thread_state(NULL);
+}
+
+int go_openssl_thread_setup(void)
+{
+    // Use the fiber-local storage API to hook a callback on thread exit.
+    // https://devblogs.microsoft.com/oldnewthing/20191011-00/?p=102989
+    fls_index = FlsAlloc(cleanup_thread_state);
+    if (fls_index == FLS_OUT_OF_INDEXES)
+        return 0;
+    mutex_buf = malloc(go_openssl_CRYPTO_num_locks()*sizeof(HANDLE));
+    if (!mutex_buf)
+        return 0;
+    int i;
+    for (i = 0; i < go_openssl_CRYPTO_num_locks(); i++)
+        mutex_buf[i] = CreateMutex(NULL, FALSE, NULL);
+    go_openssl_CRYPTO_set_locking_callback(locking_function);
+    // go_openssl_CRYPTO_set_id_callback is not strictly needed on Windows
+    // as OpenSSL uses GetCurrentThreadId() by default.
+    // But we need to piggyback off the callback for our own purposes.
+    go_openssl_CRYPTO_THREADID_set_callback(thread_id);
+    return 1;
+}
diff --git a/src/vendor/github.com/golang-fips/openssl/v2/tls1prf.go b/src/vendor/github.com/golang-fips/openssl/v2/tls1prf.go
new file mode 100644
index 0000000000..5de62f95a7
--- /dev/null
+++ b/src/vendor/github.com/golang-fips/openssl/v2/tls1prf.go
@@ -0,0 +1,104 @@
+//go:build !cmd_go_bootstrap
+
+package openssl
+
+// #include "goopenssl.h"
+import "C"
+import (
+	"crypto"
+	"errors"
+	"hash"
+	"unsafe"
+)
+
+func SupportsTLS1PRF() bool {
+	return vMajor > 1 ||
+		(vMajor >= 1 && vMinor >= 1)
+}
+
+// TLS1PRF implements the TLS 1.0/1.1 pseudo-random function if h is nil,
+// else it implements the TLS 1.2 pseudo-random function.
+// The pseudo-random number will be written to result and will be of length len(result).
+func TLS1PRF(result, secret, label, seed []byte, h func() hash.Hash) error {
+	var md C.GO_EVP_MD_PTR
+	if h == nil {
+		// TLS 1.0/1.1 PRF doesn't allow to specify the hash function,
+		// it always uses MD5SHA1. If h is nil, then assume
+		// that the caller wants to use TLS 1.0/1.1 PRF.
+		// OpenSSL detects this case by checking if the hash
+		// function is MD5SHA1.
+		md = cryptoHashToMD(crypto.MD5SHA1)
+	} else {
+		md = hashToMD(h())
+	}
+	if md == nil {
+		return errors.New("unsupported hash function")
+	}
+
+	ctx := C.go_openssl_EVP_PKEY_CTX_new_id(C.GO_EVP_PKEY_TLS1_PRF, nil)
+	if ctx == nil {
+		return newOpenSSLError("EVP_PKEY_CTX_new_id")
+	}
+	defer func() {
+		C.go_openssl_EVP_PKEY_CTX_free(ctx)
+	}()
+
+	if C.go_openssl_EVP_PKEY_derive_init(ctx) != 1 {
+		return newOpenSSLError("EVP_PKEY_derive_init")
+	}
+	switch vMajor {
+	case 3:
+		if C.go_openssl_EVP_PKEY_CTX_set_tls1_prf_md(ctx, md) != 1 {
+			return newOpenSSLError("EVP_PKEY_CTX_set_tls1_prf_md")
+		}
+		if C.go_openssl_EVP_PKEY_CTX_set1_tls1_prf_secret(ctx,
+			base(secret), C.int(len(secret))) != 1 {
+			return newOpenSSLError("EVP_PKEY_CTX_set1_tls1_prf_secret")
+		}
+		if C.go_openssl_EVP_PKEY_CTX_add1_tls1_prf_seed(ctx,
+			base(label), C.int(len(label))) != 1 {
+			return newOpenSSLError("EVP_PKEY_CTX_add1_tls1_prf_seed")
+		}
+		if C.go_openssl_EVP_PKEY_CTX_add1_tls1_prf_seed(ctx,
+			base(seed), C.int(len(seed))) != 1 {
+			return newOpenSSLError("EVP_PKEY_CTX_add1_tls1_prf_seed")
+		}
+	case 1:
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, -1,
+			C.GO1_EVP_PKEY_OP_DERIVE,
+			C.GO_EVP_PKEY_CTRL_TLS_MD,
+			0, unsafe.Pointer(md)) != 1 {
+			return newOpenSSLError("EVP_PKEY_CTX_set_tls1_prf_md")
+		}
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, -1,
+			C.GO1_EVP_PKEY_OP_DERIVE,
+			C.GO_EVP_PKEY_CTRL_TLS_SECRET,
+			C.int(len(secret)), unsafe.Pointer(base(secret))) != 1 {
+			return newOpenSSLError("EVP_PKEY_CTX_set1_tls1_prf_secret")
+		}
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, -1,
+			C.GO1_EVP_PKEY_OP_DERIVE,
+			C.GO_EVP_PKEY_CTRL_TLS_SEED,
+			C.int(len(label)), unsafe.Pointer(base(label))) != 1 {
+			return newOpenSSLError("EVP_PKEY_CTX_add1_tls1_prf_seed")
+		}
+		if C.go_openssl_EVP_PKEY_CTX_ctrl(ctx, -1,
+			C.GO1_EVP_PKEY_OP_DERIVE,
+			C.GO_EVP_PKEY_CTRL_TLS_SEED,
+			C.int(len(seed)), unsafe.Pointer(base(seed))) != 1 {
+			return newOpenSSLError("EVP_PKEY_CTX_add1_tls1_prf_seed")
+		}
+	}
+	outLen := C.size_t(len(result))
+	if C.go_openssl_EVP_PKEY_derive_wrapper(ctx, base(result), outLen).result != 1 {
+		return newOpenSSLError("EVP_PKEY_derive")
+	}
+	// The Go standard library expects TLS1PRF to return the requested number of bytes,
+	// fail if it doesn't. While there is no known situation where this will happen,
+	// EVP_PKEY_derive handles multiple algorithms and there could be a subtle mismatch
+	// after more code changes in the future.
+	if outLen != C.size_t(len(result)) {
+		return errors.New("tls1-prf: derived less bytes than requested")
+	}
+	return nil
+}
diff --git a/src/vendor/modules.txt b/src/vendor/modules.txt
index 9a234e59b1..a2dc68599f 100644
--- a/src/vendor/modules.txt
+++ b/src/vendor/modules.txt
@@ -1,3 +1,7 @@
+# github.com/golang-fips/openssl/v2 v2.0.3
+## explicit; go 1.20
+github.com/golang-fips/openssl/v2
+github.com/golang-fips/openssl/v2/bbig
 # golang.org/x/crypto v0.16.1-0.20231129163542-152cdb1503eb
 ## explicit; go 1.18
 golang.org/x/crypto/chacha20
