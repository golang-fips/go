diff --git a/src/cmd/go/testdata/script/gopath_std_vendor.txt b/src/cmd/go/testdata/script/gopath_std_vendor.txt
index a0a41a50de..208aa7008a 100644
--- a/src/cmd/go/testdata/script/gopath_std_vendor.txt
+++ b/src/cmd/go/testdata/script/gopath_std_vendor.txt
@@ -21,11 +21,11 @@ go build .
 
 go list -deps -f '{{.ImportPath}} {{.Dir}}' .
 stdout $GOPATH[/\\]src[/\\]vendor[/\\]golang.org[/\\]x[/\\]net[/\\]http2[/\\]hpack
-! stdout $GOROOT[/\\]src[/\\]vendor
+! stdout $GOROOT[/\\]src[/\\]vendor[/\\]golang.org[/\\]x[/\\]net[/\\]http2[/\\]hpack
 
 go list -test -deps -f '{{.ImportPath}} {{.Dir}}' .
 stdout $GOPATH[/\\]src[/\\]vendor[/\\]golang.org[/\\]x[/\\]net[/\\]http2[/\\]hpack
-! stdout $GOROOT[/\\]src[/\\]vendor
+! stdout $GOROOT[/\\]src[/\\]vendor[/\\]golang.org[/\\]x[/\\]net[/\\]http2[/\\]hpack
 
 -- issue16333/issue16333.go --
 package vendoring17
diff --git a/src/cmd/link/internal/ld/lib.go b/src/cmd/link/internal/ld/lib.go
index 0c277f5424..d5b6976f93 100644
--- a/src/cmd/link/internal/ld/lib.go
+++ b/src/cmd/link/internal/ld/lib.go
@@ -1013,7 +1013,7 @@ var hostobj []Hostobj
 // These packages can use internal linking mode.
 // Others trigger external mode.
 var internalpkg = []string{
-	"crypto/internal/boring",
+	"vendor/github.com/golang-fips/openssl-fips/openssl",
 	"crypto/x509",
 	"net",
 	"os/user",
diff --git a/src/crypto/aes/cipher.go b/src/crypto/aes/cipher.go
index 29d01796eb..0a973bd136 100644
--- a/src/crypto/aes/cipher.go
+++ b/src/crypto/aes/cipher.go
@@ -10,7 +10,7 @@ import (
 	"strconv"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // The AES block size in bytes.
 const BlockSize = 16
@@ -39,7 +39,7 @@ func NewCipher(key []byte) (cipher.Block, error) {
 	case 16, 24, 32:
 		break
 	}
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.NewAESCipher(key)
 	}
 	return newCipher(key)
diff --git a/src/crypto/aes/cipher_asm.go b/src/crypto/aes/cipher_asm.go
index 846f56ab56..e8666b40b6 100644
--- a/src/crypto/aes/cipher_asm.go
+++ b/src/crypto/aes/cipher_asm.go
@@ -13,7 +13,7 @@ import (
 	"internal/cpu"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // defined in asm_*.s
 
diff --git a/src/crypto/boring/boring.go b/src/crypto/boring/boring.go
index 19e2a0876f..658d416062 100644
--- a/src/crypto/boring/boring.go
+++ b/src/crypto/boring/boring.go
@@ -11,9 +11,9 @@
 // is satisfied, so that applications can tag files that use this package.
 package boring
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // Enabled reports whether BoringCrypto handles supported crypto operations.
 func Enabled() bool {
-	return boring.Enabled
+	return boring.Enabled()
 }
diff --git a/src/crypto/boring/boring_test.go b/src/crypto/boring/boring_test.go
deleted file mode 100644
index ace50de0c2..0000000000
--- a/src/crypto/boring/boring_test.go
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package boring_test
-
-import (
-	"crypto/boring"
-	"runtime"
-	"testing"
-)
-
-func TestEnabled(t *testing.T) {
-	supportedPlatform := runtime.GOOS == "linux" && runtime.GOARCH == "amd64"
-	if supportedPlatform && !boring.Enabled() {
-		t.Error("Enabled returned false on a supported platform")
-	} else if !supportedPlatform && boring.Enabled() {
-		t.Error("Enabled returned true on an unsupported platform")
-	}
-}
diff --git a/src/crypto/ecdsa/boring.go b/src/crypto/ecdsa/boring.go
index fa15ecb850..92c42e28d5 100644
--- a/src/crypto/ecdsa/boring.go
+++ b/src/crypto/ecdsa/boring.go
@@ -5,7 +5,7 @@
 package ecdsa
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"math/big"
 	"sync/atomic"
 	"unsafe"
diff --git a/src/crypto/ecdsa/ecdsa.go b/src/crypto/ecdsa/ecdsa.go
index 1a7635ec2b..04d447fde3 100644
--- a/src/crypto/ecdsa/ecdsa.go
+++ b/src/crypto/ecdsa/ecdsa.go
@@ -42,7 +42,7 @@ import (
 )
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"unsafe"
 )
 
@@ -122,12 +122,12 @@ func (priv *PrivateKey) Equal(x crypto.PrivateKey) bool {
 // where the private part is kept in, for example, a hardware module. Common
 // uses should use the Sign function in this package directly.
 func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error) {
-	if boring.Enabled && rand == boring.RandReader {
+	if boring.Enabled() && rand == boring.RandReader {
 		b, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
 		}
-		return boring.SignMarshalECDSA(b, digest)
+		return boring.SignMarshalECDSA(b, digest, crypto.Hash(0))
 	}
 	boring.UnreachableExceptTests()
 
@@ -165,7 +165,7 @@ func randFieldElement(c elliptic.Curve, rand io.Reader) (k *big.Int, err error)
 
 // GenerateKey generates a public and private key pair.
 func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error) {
-	if boring.Enabled && rand == boring.RandReader {
+	if boring.Enabled() && rand == boring.RandReader {
 		x, y, d, err := boring.GenerateKeyECDSA(c.Params().Name)
 		if err != nil {
 			return nil, err
@@ -227,12 +227,12 @@ var errZeroParam = errors.New("zero parameter")
 func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) {
 	randutil.MaybeReadByte(rand)
 
-	if boring.Enabled && rand == boring.RandReader {
+	if boring.Enabled() && rand == boring.RandReader {
 		b, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, nil, err
 		}
-		return boring.SignECDSA(b, hash)
+		return boring.SignECDSA(b, hash, crypto.Hash(0))
 	}
 	boring.UnreachableExceptTests()
 
@@ -325,12 +325,12 @@ func SignASN1(rand io.Reader, priv *PrivateKey, hash []byte) ([]byte, error) {
 // Verify verifies the signature in r, s of hash using the public key, pub. Its
 // return value records whether the signature is valid.
 func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {
-	if boring.Enabled {
+	if boring.Enabled() {
 		b, err := boringPublicKey(pub)
 		if err != nil {
 			return false
 		}
-		return boring.VerifyECDSA(b, hash, r, s)
+		return boring.VerifyECDSA(b, hash, r, s, crypto.Hash(0))
 	}
 	boring.UnreachableExceptTests()
 
diff --git a/src/crypto/hmac/hmac.go b/src/crypto/hmac/hmac.go
index 34805765d5..48a67f5724 100644
--- a/src/crypto/hmac/hmac.go
+++ b/src/crypto/hmac/hmac.go
@@ -26,7 +26,7 @@ import (
 	"hash"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // FIPS 198-1:
 // https://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf
@@ -128,7 +128,7 @@ func (h *hmac) Reset() {
 // the returned Hash does not implement encoding.BinaryMarshaler
 // or encoding.BinaryUnmarshaler.
 func New(h func() hash.Hash, key []byte) hash.Hash {
-	if boring.Enabled {
+	if boring.Enabled() {
 		hm := boring.NewHMAC(h, key)
 		if hm != nil {
 			return hm
diff --git a/src/crypto/hmac/hmac_test.go b/src/crypto/hmac/hmac_test.go
index 55415abf02..575e0025fe 100644
--- a/src/crypto/hmac/hmac_test.go
+++ b/src/crypto/hmac/hmac_test.go
@@ -6,7 +6,7 @@ package hmac
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/md5"
 	"crypto/sha1"
 	"crypto/sha256"
@@ -584,7 +584,7 @@ func TestHMAC(t *testing.T) {
 }
 
 func TestNonUniqueHash(t *testing.T) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		t.Skip("hash.Hash provided by boringcrypto are not comparable")
 	}
 	sha := sha256.New()
diff --git a/src/crypto/internal/boring/aes.go b/src/crypto/internal/boring/aes.go
deleted file mode 100644
index 504a841cd8..0000000000
--- a/src/crypto/internal/boring/aes.go
+++ /dev/null
@@ -1,391 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build linux,amd64
-// +build !android
-// +build !cmd_go_bootstrap
-// +build !msan
-
-package boring
-
-/*
-
-#include "goboringcrypto.h"
-
-// These wrappers allocate out_len on the C stack, and check that it matches the expected
-// value, to avoid having to pass a pointer from Go, which would escape to the heap.
-
-int EVP_AEAD_CTX_seal_wrapper(const GO_EVP_AEAD_CTX *ctx, uint8_t *out,
-							  size_t exp_out_len,
-							  const uint8_t *nonce, size_t nonce_len,
-							  const uint8_t *in, size_t in_len,
-							  const uint8_t *ad, size_t ad_len) {
-	size_t out_len;
-	int ok = _goboringcrypto_EVP_AEAD_CTX_seal(ctx, out, &out_len, exp_out_len,
-		nonce, nonce_len, in, in_len, ad, ad_len);
-	if (out_len != exp_out_len) {
-		return 0;
-	}
-	return ok;
-};
-
-int EVP_AEAD_CTX_open_wrapper(const GO_EVP_AEAD_CTX *ctx, uint8_t *out,
-							  size_t exp_out_len,
-							  const uint8_t *nonce, size_t nonce_len,
-							  const uint8_t *in, size_t in_len,
-							  const uint8_t *ad, size_t ad_len) {
-	size_t out_len;
-	int ok = _goboringcrypto_EVP_AEAD_CTX_open(ctx, out, &out_len, exp_out_len,
-		nonce, nonce_len, in, in_len, ad, ad_len);
-	if (out_len != exp_out_len) {
-		return 0;
-	}
-	return ok;
-};
-
-*/
-import "C"
-import (
-	"crypto/cipher"
-	"errors"
-	"runtime"
-	"strconv"
-	"unsafe"
-)
-
-type aesKeySizeError int
-
-func (k aesKeySizeError) Error() string {
-	return "crypto/aes: invalid key size " + strconv.Itoa(int(k))
-}
-
-const aesBlockSize = 16
-
-type aesCipher struct {
-	key []byte
-	enc C.GO_AES_KEY
-	dec C.GO_AES_KEY
-}
-
-type extraModes interface {
-	// Copied out of crypto/aes/modes.go.
-	NewCBCEncrypter(iv []byte) cipher.BlockMode
-	NewCBCDecrypter(iv []byte) cipher.BlockMode
-	NewCTR(iv []byte) cipher.Stream
-	NewGCM(nonceSize, tagSize int) (cipher.AEAD, error)
-
-	// Invented for BoringCrypto.
-	NewGCMTLS() (cipher.AEAD, error)
-}
-
-var _ extraModes = (*aesCipher)(nil)
-
-func NewAESCipher(key []byte) (cipher.Block, error) {
-	c := &aesCipher{key: make([]byte, len(key))}
-	copy(c.key, key)
-	// Note: 0 is success, contradicting the usual BoringCrypto convention.
-	if C._goboringcrypto_AES_set_decrypt_key((*C.uint8_t)(unsafe.Pointer(&c.key[0])), C.uint(8*len(c.key)), &c.dec) != 0 ||
-		C._goboringcrypto_AES_set_encrypt_key((*C.uint8_t)(unsafe.Pointer(&c.key[0])), C.uint(8*len(c.key)), &c.enc) != 0 {
-		return nil, aesKeySizeError(len(key))
-	}
-	return c, nil
-}
-
-func (c *aesCipher) BlockSize() int { return aesBlockSize }
-
-func (c *aesCipher) Encrypt(dst, src []byte) {
-	if inexactOverlap(dst, src) {
-		panic("crypto/cipher: invalid buffer overlap")
-	}
-	if len(src) < aesBlockSize {
-		panic("crypto/aes: input not full block")
-	}
-	if len(dst) < aesBlockSize {
-		panic("crypto/aes: output not full block")
-	}
-	C._goboringcrypto_AES_encrypt(
-		(*C.uint8_t)(unsafe.Pointer(&src[0])),
-		(*C.uint8_t)(unsafe.Pointer(&dst[0])),
-		&c.enc)
-}
-
-func (c *aesCipher) Decrypt(dst, src []byte) {
-	if inexactOverlap(dst, src) {
-		panic("crypto/cipher: invalid buffer overlap")
-	}
-	if len(src) < aesBlockSize {
-		panic("crypto/aes: input not full block")
-	}
-	if len(dst) < aesBlockSize {
-		panic("crypto/aes: output not full block")
-	}
-	C._goboringcrypto_AES_decrypt(
-		(*C.uint8_t)(unsafe.Pointer(&src[0])),
-		(*C.uint8_t)(unsafe.Pointer(&dst[0])),
-		&c.dec)
-}
-
-type aesCBC struct {
-	key  *C.GO_AES_KEY
-	mode C.int
-	iv   [aesBlockSize]byte
-}
-
-func (x *aesCBC) BlockSize() int { return aesBlockSize }
-
-func (x *aesCBC) CryptBlocks(dst, src []byte) {
-	if inexactOverlap(dst, src) {
-		panic("crypto/cipher: invalid buffer overlap")
-	}
-	if len(src)%aesBlockSize != 0 {
-		panic("crypto/cipher: input not full blocks")
-	}
-	if len(dst) < len(src) {
-		panic("crypto/cipher: output smaller than input")
-	}
-	if len(src) > 0 {
-		C._goboringcrypto_AES_cbc_encrypt(
-			(*C.uint8_t)(unsafe.Pointer(&src[0])),
-			(*C.uint8_t)(unsafe.Pointer(&dst[0])),
-			C.size_t(len(src)), x.key,
-			(*C.uint8_t)(unsafe.Pointer(&x.iv[0])), x.mode)
-	}
-}
-
-func (x *aesCBC) SetIV(iv []byte) {
-	if len(iv) != aesBlockSize {
-		panic("cipher: incorrect length IV")
-	}
-	copy(x.iv[:], iv)
-}
-
-func (c *aesCipher) NewCBCEncrypter(iv []byte) cipher.BlockMode {
-	x := &aesCBC{key: &c.enc, mode: C.GO_AES_ENCRYPT}
-	copy(x.iv[:], iv)
-	return x
-}
-
-func (c *aesCipher) NewCBCDecrypter(iv []byte) cipher.BlockMode {
-	x := &aesCBC{key: &c.dec, mode: C.GO_AES_DECRYPT}
-	copy(x.iv[:], iv)
-	return x
-}
-
-type aesCTR struct {
-	key        *C.GO_AES_KEY
-	iv         [aesBlockSize]byte
-	num        C.uint
-	ecount_buf [16]C.uint8_t
-}
-
-func (x *aesCTR) XORKeyStream(dst, src []byte) {
-	if inexactOverlap(dst, src) {
-		panic("crypto/cipher: invalid buffer overlap")
-	}
-	if len(dst) < len(src) {
-		panic("crypto/cipher: output smaller than input")
-	}
-	if len(src) == 0 {
-		return
-	}
-	C._goboringcrypto_AES_ctr128_encrypt(
-		(*C.uint8_t)(unsafe.Pointer(&src[0])),
-		(*C.uint8_t)(unsafe.Pointer(&dst[0])),
-		C.size_t(len(src)), x.key, (*C.uint8_t)(unsafe.Pointer(&x.iv[0])),
-		&x.ecount_buf[0], &x.num)
-}
-
-func (c *aesCipher) NewCTR(iv []byte) cipher.Stream {
-	x := &aesCTR{key: &c.enc}
-	copy(x.iv[:], iv)
-	return x
-}
-
-type aesGCM struct {
-	ctx  C.GO_EVP_AEAD_CTX
-	aead *C.GO_EVP_AEAD
-}
-
-const (
-	gcmBlockSize         = 16
-	gcmTagSize           = 16
-	gcmStandardNonceSize = 12
-)
-
-type aesNonceSizeError int
-
-func (n aesNonceSizeError) Error() string {
-	return "crypto/aes: invalid GCM nonce size " + strconv.Itoa(int(n))
-}
-
-type noGCM struct {
-	cipher.Block
-}
-
-func (c *aesCipher) NewGCM(nonceSize, tagSize int) (cipher.AEAD, error) {
-	if nonceSize != gcmStandardNonceSize && tagSize != gcmTagSize {
-		return nil, errors.New("crypto/aes: GCM tag and nonce sizes can't be non-standard at the same time")
-	}
-	// Fall back to standard library for GCM with non-standard nonce or tag size.
-	if nonceSize != gcmStandardNonceSize {
-		return cipher.NewGCMWithNonceSize(&noGCM{c}, nonceSize)
-	}
-	if tagSize != gcmTagSize {
-		return cipher.NewGCMWithTagSize(&noGCM{c}, tagSize)
-	}
-	return c.newGCM(false)
-}
-
-func (c *aesCipher) NewGCMTLS() (cipher.AEAD, error) {
-	return c.newGCM(true)
-}
-
-func (c *aesCipher) newGCM(tls bool) (cipher.AEAD, error) {
-	var aead *C.GO_EVP_AEAD
-	switch len(c.key) * 8 {
-	case 128:
-		if tls {
-			aead = C._goboringcrypto_EVP_aead_aes_128_gcm_tls12()
-		} else {
-			aead = C._goboringcrypto_EVP_aead_aes_128_gcm()
-		}
-	case 256:
-		if tls {
-			aead = C._goboringcrypto_EVP_aead_aes_256_gcm_tls12()
-		} else {
-			aead = C._goboringcrypto_EVP_aead_aes_256_gcm()
-		}
-	default:
-		// Fall back to standard library for GCM with non-standard key size.
-		return cipher.NewGCMWithNonceSize(&noGCM{c}, gcmStandardNonceSize)
-	}
-
-	g := &aesGCM{aead: aead}
-	if C._goboringcrypto_EVP_AEAD_CTX_init(&g.ctx, aead, (*C.uint8_t)(unsafe.Pointer(&c.key[0])), C.size_t(len(c.key)), C.GO_EVP_AEAD_DEFAULT_TAG_LENGTH, nil) == 0 {
-		return nil, fail("EVP_AEAD_CTX_init")
-	}
-	// Note: Because of the finalizer, any time g.ctx is passed to cgo,
-	// that call must be followed by a call to runtime.KeepAlive(g),
-	// to make sure g is not collected (and finalized) before the cgo
-	// call returns.
-	runtime.SetFinalizer(g, (*aesGCM).finalize)
-	if g.NonceSize() != gcmStandardNonceSize {
-		panic("boringcrypto: internal confusion about nonce size")
-	}
-	if g.Overhead() != gcmTagSize {
-		panic("boringcrypto: internal confusion about tag size")
-	}
-
-	return g, nil
-}
-
-func (g *aesGCM) finalize() {
-	C._goboringcrypto_EVP_AEAD_CTX_cleanup(&g.ctx)
-}
-
-func (g *aesGCM) NonceSize() int {
-	return int(C._goboringcrypto_EVP_AEAD_nonce_length(g.aead))
-}
-
-func (g *aesGCM) Overhead() int {
-	return int(C._goboringcrypto_EVP_AEAD_max_overhead(g.aead))
-}
-
-// base returns the address of the underlying array in b,
-// being careful not to panic when b has zero length.
-func base(b []byte) *C.uint8_t {
-	if len(b) == 0 {
-		return nil
-	}
-	return (*C.uint8_t)(unsafe.Pointer(&b[0]))
-}
-
-func (g *aesGCM) Seal(dst, nonce, plaintext, additionalData []byte) []byte {
-	if len(nonce) != gcmStandardNonceSize {
-		panic("cipher: incorrect nonce length given to GCM")
-	}
-	if uint64(len(plaintext)) > ((1<<32)-2)*aesBlockSize || len(plaintext)+gcmTagSize < len(plaintext) {
-		panic("cipher: message too large for GCM")
-	}
-	if len(dst)+len(plaintext)+gcmTagSize < len(dst) {
-		panic("cipher: message too large for buffer")
-	}
-
-	// Make room in dst to append plaintext+overhead.
-	n := len(dst)
-	for cap(dst) < n+len(plaintext)+gcmTagSize {
-		dst = append(dst[:cap(dst)], 0)
-	}
-	dst = dst[:n+len(plaintext)+gcmTagSize]
-
-	// Check delayed until now to make sure len(dst) is accurate.
-	if inexactOverlap(dst[n:], plaintext) {
-		panic("cipher: invalid buffer overlap")
-	}
-
-	outLen := C.size_t(len(plaintext) + gcmTagSize)
-	ok := C.EVP_AEAD_CTX_seal_wrapper(
-		&g.ctx,
-		(*C.uint8_t)(unsafe.Pointer(&dst[n])), outLen,
-		base(nonce), C.size_t(len(nonce)),
-		base(plaintext), C.size_t(len(plaintext)),
-		base(additionalData), C.size_t(len(additionalData)))
-	runtime.KeepAlive(g)
-	if ok == 0 {
-		panic(fail("EVP_AEAD_CTX_seal"))
-	}
-	return dst[:n+int(outLen)]
-}
-
-var errOpen = errors.New("cipher: message authentication failed")
-
-func (g *aesGCM) Open(dst, nonce, ciphertext, additionalData []byte) ([]byte, error) {
-	if len(nonce) != gcmStandardNonceSize {
-		panic("cipher: incorrect nonce length given to GCM")
-	}
-	if len(ciphertext) < gcmTagSize {
-		return nil, errOpen
-	}
-	if uint64(len(ciphertext)) > ((1<<32)-2)*aesBlockSize+gcmTagSize {
-		return nil, errOpen
-	}
-
-	// Make room in dst to append ciphertext without tag.
-	n := len(dst)
-	for cap(dst) < n+len(ciphertext)-gcmTagSize {
-		dst = append(dst[:cap(dst)], 0)
-	}
-	dst = dst[:n+len(ciphertext)-gcmTagSize]
-
-	// Check delayed until now to make sure len(dst) is accurate.
-	if inexactOverlap(dst[n:], ciphertext) {
-		panic("cipher: invalid buffer overlap")
-	}
-
-	outLen := C.size_t(len(ciphertext) - gcmTagSize)
-	ok := C.EVP_AEAD_CTX_open_wrapper(
-		&g.ctx,
-		base(dst[n:]), outLen,
-		base(nonce), C.size_t(len(nonce)),
-		base(ciphertext), C.size_t(len(ciphertext)),
-		base(additionalData), C.size_t(len(additionalData)))
-	runtime.KeepAlive(g)
-	if ok == 0 {
-		return nil, errOpen
-	}
-	return dst[:n+int(outLen)], nil
-}
-
-func anyOverlap(x, y []byte) bool {
-	return len(x) > 0 && len(y) > 0 &&
-		uintptr(unsafe.Pointer(&x[0])) <= uintptr(unsafe.Pointer(&y[len(y)-1])) &&
-		uintptr(unsafe.Pointer(&y[0])) <= uintptr(unsafe.Pointer(&x[len(x)-1]))
-}
-
-func inexactOverlap(x, y []byte) bool {
-	if len(x) == 0 || len(y) == 0 || &x[0] == &y[0] {
-		return false
-	}
-	return anyOverlap(x, y)
-}
diff --git a/src/crypto/internal/boring/boring.go b/src/crypto/internal/boring/boring.go
deleted file mode 100644
index 9ccad7eb5d..0000000000
--- a/src/crypto/internal/boring/boring.go
+++ /dev/null
@@ -1,83 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build linux,amd64
-// +build !android
-// +build !cmd_go_bootstrap
-// +build !msan
-
-package boring
-
-// #include "goboringcrypto.h"
-import "C"
-import (
-	"crypto/internal/boring/sig"
-	"math/big"
-)
-
-const available = true
-
-func init() {
-	C._goboringcrypto_BORINGSSL_bcm_power_on_self_test()
-	if C._goboringcrypto_FIPS_mode() != 1 {
-		panic("boringcrypto: not in FIPS mode")
-	}
-	sig.BoringCrypto()
-}
-
-// Unreachable marks code that should be unreachable
-// when BoringCrypto is in use. It panics.
-func Unreachable() {
-	panic("boringcrypto: invalid code execution")
-}
-
-// provided by runtime to avoid os import
-func runtime_arg0() string
-
-func hasSuffix(s, t string) bool {
-	return len(s) > len(t) && s[len(s)-len(t):] == t
-}
-
-// UnreachableExceptTests marks code that should be unreachable
-// when BoringCrypto is in use. It panics.
-func UnreachableExceptTests() {
-	name := runtime_arg0()
-	// If BoringCrypto ran on Windows we'd need to allow _test.exe and .test.exe as well.
-	if !hasSuffix(name, "_test") && !hasSuffix(name, ".test") {
-		println("boringcrypto: unexpected code execution in", name)
-		panic("boringcrypto: invalid code execution")
-	}
-}
-
-type fail string
-
-func (e fail) Error() string { return "boringcrypto: " + string(e) + " failed" }
-
-func bigToBN(x *big.Int) *C.GO_BIGNUM {
-	raw := x.Bytes()
-	return C._goboringcrypto_BN_bin2bn(base(raw), C.size_t(len(raw)), nil)
-}
-
-func bnToBig(bn *C.GO_BIGNUM) *big.Int {
-	raw := make([]byte, C._goboringcrypto_BN_num_bytes(bn))
-	n := C._goboringcrypto_BN_bn2bin(bn, base(raw))
-	return new(big.Int).SetBytes(raw[:n])
-}
-
-func bigToBn(bnp **C.GO_BIGNUM, b *big.Int) bool {
-	if *bnp != nil {
-		C._goboringcrypto_BN_free(*bnp)
-		*bnp = nil
-	}
-	if b == nil {
-		return true
-	}
-	raw := b.Bytes()
-	bn := C._goboringcrypto_BN_bin2bn(base(raw), C.size_t(len(raw)), nil)
-	if bn == nil {
-		return false
-	}
-	*bnp = bn
-	return true
-}
diff --git a/src/crypto/internal/boring/boring_test.go b/src/crypto/internal/boring/boring_test.go
deleted file mode 100644
index 83bbbd3404..0000000000
--- a/src/crypto/internal/boring/boring_test.go
+++ /dev/null
@@ -1,34 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Most functionality in this package is tested by replacing existing code
-// and inheriting that code's tests.
-
-package boring
-
-import "testing"
-
-// Test that func init does not panic.
-func TestInit(t *testing.T) {}
-
-// Test that Unreachable panics.
-func TestUnreachable(t *testing.T) {
-	defer func() {
-		if Enabled {
-			if err := recover(); err == nil {
-				t.Fatal("expected Unreachable to panic")
-			}
-		} else {
-			if err := recover(); err != nil {
-				t.Fatalf("expected Unreachable to be a no-op")
-			}
-		}
-	}()
-	Unreachable()
-}
-
-// Test that UnreachableExceptTests does not panic (this is a test).
-func TestUnreachableExceptTests(t *testing.T) {
-	UnreachableExceptTests()
-}
diff --git a/src/crypto/internal/boring/build.sh b/src/crypto/internal/boring/build.sh
deleted file mode 100755
index 31e98cb6ef..0000000000
--- a/src/crypto/internal/boring/build.sh
+++ /dev/null
@@ -1,196 +0,0 @@
-#!/bin/bash
-# Copyright 2020 The Go Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-set -e
-id
-date
-export LANG=C
-unset LANGUAGE
-
-# Build BoringCrypto libcrypto.a.
-# Following https://csrc.nist.gov/CSRC/media/projects/cryptographic-module-validation-program/documents/security-policies/140sp3678.pdf page 19.
-
-tar xJf boringssl-*z
-
-# Go requires -fPIC for linux/amd64 cgo builds.
-# Setting -fPIC only affects the compilation of the non-module code in libcrypto.a,
-# because the FIPS module itself is already built with -fPIC.
-echo '#!/bin/bash
-exec clang-7 -fPIC "$@"
-' >/usr/local/bin/clang
-echo '#!/bin/bash
-exec clang++-7 -fPIC "$@"
-' >/usr/local/bin/clang++
-chmod +x /usr/local/bin/clang /usr/local/bin/clang++
-
-# The BoringSSL tests use Go, and cgo would look for gcc.
-export CGO_ENABLED=0
-
-# Verbatim instructions from BoringCrypto build docs.
-printf "set(CMAKE_C_COMPILER \"clang\")\nset(CMAKE_CXX_COMPILER \"clang++\")\n" >${HOME}/toolchain
-cd boringssl
-mkdir build && cd build && cmake -GNinja -DCMAKE_TOOLCHAIN_FILE=${HOME}/toolchain -DFIPS=1 -DCMAKE_BUILD_TYPE=Release ..
-ninja
-ninja run_tests
-
-cd ../..
-
-if [ "$(./boringssl/build/tool/bssl isfips)" != 1 ]; then
-	echo "NOT FIPS"
-	exit 2
-fi
-
-# Build and run test C++ program to make sure goboringcrypto.h matches openssl/*.h.
-# Also collect list of checked symbols in syms.txt
-set -x
-set -e
-cd godriver
-cat >goboringcrypto.cc <<'EOF'
-#include <cassert>
-#include "goboringcrypto0.h"
-#include "goboringcrypto1.h"
-#define check_size(t) if(sizeof(t) != sizeof(GO_ ## t)) {printf("sizeof(" #t ")=%d, but sizeof(GO_" #t ")=%d\n", (int)sizeof(t), (int)sizeof(GO_ ## t)); ret=1;}
-#define check_func(f) { auto x = f; x = _goboringcrypto_ ## f ; }
-#define check_value(n, v) if(n != v) {printf(#n "=%d, but goboringcrypto.h defines it as %d\n", (int)n, (int)v); ret=1;}
-int main() {
-int ret = 0;
-#include "goboringcrypto.x"
-return ret;
-}
-EOF
-
-awk '
-BEGIN {
-	exitcode = 0
-}
-
-# Ignore comments, #includes, blank lines.
-/^\/\// || /^#/ || NF == 0 { next }
-
-# Ignore unchecked declarations.
-/\/\*unchecked/ { next }
-
-# Check enum values.
-!enum && $1 == "enum" && $NF == "{" {
-	enum = 1
-	next
-}
-enum && $1 == "};" {
-	enum = 0
-	next
-}
-enum && NF == 3 && $2 == "=" {
-	name = $1
-	sub(/^GO_/, "", name)
-	val = $3
-	sub(/,$/, "", val)
-	print "check_value(" name ", " val ")" > "goboringcrypto.x"
-	next
-}
-enum {
-	print FILENAME ":" NR ": unexpected line in enum: " $0 > "/dev/stderr"
-	exitcode = 1
-	next
-}
-
-# Check struct sizes.
-/^typedef struct / && $NF ~ /^GO_/ {
-	name = $NF
-	sub(/^GO_/, "", name)
-	sub(/;$/, "", name)
-	print "check_size(" name ")" > "goboringcrypto.x"
-	next
-}
-
-# Check function prototypes.
-/^(const )?[^ ]+ \**_goboringcrypto_.*\(/ {
-	name = $2
-	if($1 == "const")
-		name = $3
-	sub(/^\**_goboringcrypto_/, "", name)
-	sub(/\(.*/, "", name)
-	print "check_func(" name ")" > "goboringcrypto.x"
-	print name > "syms.txt"
-	next
-}
-
-{
-	print FILENAME ":" NR ": unexpected line: " $0 > "/dev/stderr"
-	exitcode = 1
-}
-
-END {
-	exit exitcode
-}
-' goboringcrypto.h
-
-cat goboringcrypto.h | awk '
-	/^\/\/ #include/ {sub(/\/\//, ""); print > "goboringcrypto0.h"; next}
-	/typedef struct|enum ([a-z_]+ )?{|^[ \t]/ {print;next}
-	{gsub(/GO_/, ""); gsub(/enum go_/, "enum "); print}
-' >goboringcrypto1.h
-clang++ -std=c++11 -fPIC -I../boringssl/include -O2 -o a.out  goboringcrypto.cc
-./a.out || exit 2
-
-# Prepare copy of libcrypto.a with only the checked functions renamed and exported.
-# All other symbols are left alone and hidden.
-echo BORINGSSL_bcm_power_on_self_test >>syms.txt
-awk '{print "_goboringcrypto_" $0 }' syms.txt >globals.txt
-awk '{print $0 " _goboringcrypto_" $0 }' syms.txt >renames.txt
-objcopy --globalize-symbol=BORINGSSL_bcm_power_on_self_test ../boringssl/build/crypto/libcrypto.a libcrypto.a
-
-# clang implements u128 % u128 -> u128 by calling __umodti3,
-# which is in libgcc. To make the result self-contained even if linking
-# against a different compiler version, link our own __umodti3 into the syso.
-# This one is specialized so it only expects divisors below 2^64,
-# which is all BoringCrypto uses. (Otherwise it will seg fault.)
-cat >umod.s <<'EOF'
-# tu_int __umodti3(tu_int x, tu_int y)
-# x is rsi:rdi, y is rcx:rdx, return result is rdx:rax.
-.globl __umodti3
-__umodti3:
-	# specialized to u128 % u64, so verify that
-	test %rcx,%rcx
-	jne 1f
-
-	# save divisor
-	movq %rdx, %r8
-
-	# reduce top 64 bits mod divisor
-	movq %rsi, %rax
-	xorl %edx, %edx
-	divq %r8
-
-	# reduce full 128-bit mod divisor
-	# quotient fits in 64 bits because top 64 bits have been reduced < divisor.
-	# (even though we only care about the remainder, divq also computes
-	# the quotient, and it will trap if the quotient is too large.)
-	movq %rdi, %rax
-	divq %r8
-
-	# expand remainder to 128 for return
-	movq %rdx, %rax
-	xorl %edx, %edx
-	ret
-
-1:
-	# crash - only want 64-bit divisor
-	xorl %ecx, %ecx
-	movl %ecx, 0(%ecx)
-	jmp 1b
-
-.section .note.GNU-stack,"",@progbits
-EOF
-clang -c -o umod.o umod.s
-
-ld -r -nostdlib --whole-archive -o goboringcrypto.o libcrypto.a umod.o
-echo __umodti3 _goboringcrypto___umodti3 >>renames.txt
-objcopy --remove-section=.llvm_addrsig goboringcrypto.o goboringcrypto1.o # b/179161016
-objcopy --redefine-syms=renames.txt goboringcrypto1.o goboringcrypto2.o
-objcopy --keep-global-symbols=globals.txt goboringcrypto2.o goboringcrypto_linux_amd64.syso
-
-# Done!
-ls -l goboringcrypto_linux_amd64.syso
-sha256sum goboringcrypto_linux_amd64.syso
diff --git a/src/crypto/internal/boring/doc.go b/src/crypto/internal/boring/doc.go
deleted file mode 100644
index 64f41e3c82..0000000000
--- a/src/crypto/internal/boring/doc.go
+++ /dev/null
@@ -1,14 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package boring provides access to BoringCrypto implementation functions.
-// Check the constant Enabled to find out whether BoringCrypto is available.
-// If BoringCrypto is not available, the functions in this package all panic.
-package boring
-
-// Enabled reports whether BoringCrypto is available.
-// When enabled is false, all functions in this package panic.
-//
-// BoringCrypto is only available on linux/amd64 systems.
-const Enabled = available
diff --git a/src/crypto/internal/boring/ecdsa.go b/src/crypto/internal/boring/ecdsa.go
deleted file mode 100644
index 4fcba4be72..0000000000
--- a/src/crypto/internal/boring/ecdsa.go
+++ /dev/null
@@ -1,201 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build linux,amd64
-// +build !android
-// +build !cmd_go_bootstrap
-// +build !msan
-
-package boring
-
-// #include "goboringcrypto.h"
-import "C"
-import (
-	"encoding/asn1"
-	"errors"
-	"math/big"
-	"runtime"
-	"unsafe"
-)
-
-type ecdsaSignature struct {
-	R, S *big.Int
-}
-
-type PrivateKeyECDSA struct {
-	key *C.GO_EC_KEY
-}
-
-func (k *PrivateKeyECDSA) finalize() {
-	C._goboringcrypto_EC_KEY_free(k.key)
-}
-
-type PublicKeyECDSA struct {
-	key *C.GO_EC_KEY
-}
-
-func (k *PublicKeyECDSA) finalize() {
-	C._goboringcrypto_EC_KEY_free(k.key)
-}
-
-var errUnknownCurve = errors.New("boringcrypto: unknown elliptic curve")
-
-func curveNID(curve string) (C.int, error) {
-	switch curve {
-	case "P-224":
-		return C.GO_NID_secp224r1, nil
-	case "P-256":
-		return C.GO_NID_X9_62_prime256v1, nil
-	case "P-384":
-		return C.GO_NID_secp384r1, nil
-	case "P-521":
-		return C.GO_NID_secp521r1, nil
-	}
-	return 0, errUnknownCurve
-}
-
-func NewPublicKeyECDSA(curve string, X, Y *big.Int) (*PublicKeyECDSA, error) {
-	key, err := newECKey(curve, X, Y)
-	if err != nil {
-		return nil, err
-	}
-	k := &PublicKeyECDSA{key}
-	// Note: Because of the finalizer, any time k.key is passed to cgo,
-	// that call must be followed by a call to runtime.KeepAlive(k),
-	// to make sure k is not collected (and finalized) before the cgo
-	// call returns.
-	runtime.SetFinalizer(k, (*PublicKeyECDSA).finalize)
-	return k, nil
-}
-
-func newECKey(curve string, X, Y *big.Int) (*C.GO_EC_KEY, error) {
-	nid, err := curveNID(curve)
-	if err != nil {
-		return nil, err
-	}
-	key := C._goboringcrypto_EC_KEY_new_by_curve_name(nid)
-	if key == nil {
-		return nil, fail("EC_KEY_new_by_curve_name")
-	}
-	group := C._goboringcrypto_EC_KEY_get0_group(key)
-	pt := C._goboringcrypto_EC_POINT_new(group)
-	if pt == nil {
-		C._goboringcrypto_EC_KEY_free(key)
-		return nil, fail("EC_POINT_new")
-	}
-	bx := bigToBN(X)
-	by := bigToBN(Y)
-	ok := bx != nil && by != nil && C._goboringcrypto_EC_POINT_set_affine_coordinates_GFp(group, pt, bx, by, nil) != 0 &&
-		C._goboringcrypto_EC_KEY_set_public_key(key, pt) != 0
-	if bx != nil {
-		C._goboringcrypto_BN_free(bx)
-	}
-	if by != nil {
-		C._goboringcrypto_BN_free(by)
-	}
-	C._goboringcrypto_EC_POINT_free(pt)
-	if !ok {
-		C._goboringcrypto_EC_KEY_free(key)
-		return nil, fail("EC_POINT_set_affine_coordinates_GFp")
-	}
-	return key, nil
-}
-
-func NewPrivateKeyECDSA(curve string, X, Y *big.Int, D *big.Int) (*PrivateKeyECDSA, error) {
-	key, err := newECKey(curve, X, Y)
-	if err != nil {
-		return nil, err
-	}
-	bd := bigToBN(D)
-	ok := bd != nil && C._goboringcrypto_EC_KEY_set_private_key(key, bd) != 0
-	if bd != nil {
-		C._goboringcrypto_BN_free(bd)
-	}
-	if !ok {
-		C._goboringcrypto_EC_KEY_free(key)
-		return nil, fail("EC_KEY_set_private_key")
-	}
-	k := &PrivateKeyECDSA{key}
-	// Note: Because of the finalizer, any time k.key is passed to cgo,
-	// that call must be followed by a call to runtime.KeepAlive(k),
-	// to make sure k is not collected (and finalized) before the cgo
-	// call returns.
-	runtime.SetFinalizer(k, (*PrivateKeyECDSA).finalize)
-	return k, nil
-}
-
-func SignECDSA(priv *PrivateKeyECDSA, hash []byte) (r, s *big.Int, err error) {
-	// We could use ECDSA_do_sign instead but would need to convert
-	// the resulting BIGNUMs to *big.Int form. If we're going to do a
-	// conversion, converting the ASN.1 form is more convenient and
-	// likely not much more expensive.
-	sig, err := SignMarshalECDSA(priv, hash)
-	if err != nil {
-		return nil, nil, err
-	}
-	var esig ecdsaSignature
-	if _, err := asn1.Unmarshal(sig, &esig); err != nil {
-		return nil, nil, err
-	}
-	return esig.R, esig.S, nil
-}
-
-func SignMarshalECDSA(priv *PrivateKeyECDSA, hash []byte) ([]byte, error) {
-	size := C._goboringcrypto_ECDSA_size(priv.key)
-	sig := make([]byte, size)
-	var sigLen C.uint
-	if C._goboringcrypto_ECDSA_sign(0, base(hash), C.size_t(len(hash)), (*C.uint8_t)(unsafe.Pointer(&sig[0])), &sigLen, priv.key) == 0 {
-		return nil, fail("ECDSA_sign")
-	}
-	runtime.KeepAlive(priv)
-	return sig[:sigLen], nil
-}
-
-func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, r, s *big.Int) bool {
-	// We could use ECDSA_do_verify instead but would need to convert
-	// r and s to BIGNUM form. If we're going to do a conversion, marshaling
-	// to ASN.1 is more convenient and likely not much more expensive.
-	sig, err := asn1.Marshal(ecdsaSignature{r, s})
-	if err != nil {
-		return false
-	}
-	ok := C._goboringcrypto_ECDSA_verify(0, base(hash), C.size_t(len(hash)), (*C.uint8_t)(unsafe.Pointer(&sig[0])), C.size_t(len(sig)), pub.key) != 0
-	runtime.KeepAlive(pub)
-	return ok
-}
-
-func GenerateKeyECDSA(curve string) (X, Y, D *big.Int, err error) {
-	nid, err := curveNID(curve)
-	if err != nil {
-		return nil, nil, nil, err
-	}
-	key := C._goboringcrypto_EC_KEY_new_by_curve_name(nid)
-	if key == nil {
-		return nil, nil, nil, fail("EC_KEY_new_by_curve_name")
-	}
-	defer C._goboringcrypto_EC_KEY_free(key)
-	if C._goboringcrypto_EC_KEY_generate_key_fips(key) == 0 {
-		return nil, nil, nil, fail("EC_KEY_generate_key_fips")
-	}
-	group := C._goboringcrypto_EC_KEY_get0_group(key)
-	pt := C._goboringcrypto_EC_KEY_get0_public_key(key)
-	bd := C._goboringcrypto_EC_KEY_get0_private_key(key)
-	if pt == nil || bd == nil {
-		return nil, nil, nil, fail("EC_KEY_get0_private_key")
-	}
-	bx := C._goboringcrypto_BN_new()
-	if bx == nil {
-		return nil, nil, nil, fail("BN_new")
-	}
-	defer C._goboringcrypto_BN_free(bx)
-	by := C._goboringcrypto_BN_new()
-	if by == nil {
-		return nil, nil, nil, fail("BN_new")
-	}
-	defer C._goboringcrypto_BN_free(by)
-	if C._goboringcrypto_EC_POINT_get_affine_coordinates_GFp(group, pt, bx, by, nil) == 0 {
-		return nil, nil, nil, fail("EC_POINT_get_affine_coordinates_GFp")
-	}
-	return bnToBig(bx), bnToBig(by), bnToBig(bd), nil
-}
diff --git a/src/crypto/internal/boring/goboringcrypto.h b/src/crypto/internal/boring/goboringcrypto.h
deleted file mode 100644
index 37b7917c04..0000000000
--- a/src/crypto/internal/boring/goboringcrypto.h
+++ /dev/null
@@ -1,237 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// This header file describes the BoringCrypto ABI as built for use in Go.
-// The BoringCrypto build for Go (which generates goboringcrypto_*.syso)
-// takes the standard libcrypto.a from BoringCrypto and adds the prefix
-// _goboringcrypto_ to every symbol, to avoid possible conflicts with
-// code wrapping a different BoringCrypto or OpenSSL.
-//
-// To make this header standalone (so that building Go does not require
-// having a full set of BoringCrypto headers), the struct details are not here.
-// Instead, while building the syso, we compile and run a C++ program
-// that checks that the sizes match. The program also checks (during compilation)
-// that all the function prototypes match the BoringCrypto equivalents.
-// The generation of the checking program depends on the declaration
-// forms used below (one line for most, multiline for enums).
-
-#include <stdlib.h> // size_t
-#include <stdint.h> // uint8_t
-
-// This symbol is hidden in BoringCrypto and marked as a constructor,
-// but cmd/link's internal linking mode doesn't handle constructors.
-// Until it does, we've exported the symbol and can call it explicitly.
-// (If using external linking mode, it will therefore be called twice,
-// once explicitly and once as a constructor, but that's OK.)
-/*unchecked*/ void _goboringcrypto_BORINGSSL_bcm_power_on_self_test(void);
-
-// #include <openssl/crypto.h>
-int _goboringcrypto_FIPS_mode(void);
-void* _goboringcrypto_OPENSSL_malloc(size_t);
-
-// #include <openssl/rand.h>
-int _goboringcrypto_RAND_bytes(uint8_t*, size_t);
-
-// #include <openssl/nid.h>
-enum {
-	GO_NID_md5_sha1 = 114,
-
-	GO_NID_secp224r1 = 713,
-	GO_NID_X9_62_prime256v1 = 415,
-	GO_NID_secp384r1 = 715,
-	GO_NID_secp521r1 = 716,
-
-	GO_NID_sha224 = 675,
-	GO_NID_sha256 = 672,
-	GO_NID_sha384 = 673,
-	GO_NID_sha512 = 674,
-};
-
-// #include <openssl/sha.h>
-typedef struct GO_SHA_CTX { char data[96]; } GO_SHA_CTX;
-int _goboringcrypto_SHA1_Init(GO_SHA_CTX*);
-int _goboringcrypto_SHA1_Update(GO_SHA_CTX*, const void*, size_t);
-int _goboringcrypto_SHA1_Final(uint8_t*, GO_SHA_CTX*);
-
-typedef struct GO_SHA256_CTX { char data[48+64]; } GO_SHA256_CTX;
-int _goboringcrypto_SHA224_Init(GO_SHA256_CTX*);
-int _goboringcrypto_SHA224_Update(GO_SHA256_CTX*, const void*, size_t);
-int _goboringcrypto_SHA224_Final(uint8_t*, GO_SHA256_CTX*);
-int _goboringcrypto_SHA256_Init(GO_SHA256_CTX*);
-int _goboringcrypto_SHA256_Update(GO_SHA256_CTX*, const void*, size_t);
-int _goboringcrypto_SHA256_Final(uint8_t*, GO_SHA256_CTX*);
-
-typedef struct GO_SHA512_CTX { char data[88+128]; } GO_SHA512_CTX;
-int _goboringcrypto_SHA384_Init(GO_SHA512_CTX*);
-int _goboringcrypto_SHA384_Update(GO_SHA512_CTX*, const void*, size_t);
-int _goboringcrypto_SHA384_Final(uint8_t*, GO_SHA512_CTX*);
-int _goboringcrypto_SHA512_Init(GO_SHA512_CTX*);
-int _goboringcrypto_SHA512_Update(GO_SHA512_CTX*, const void*, size_t);
-int _goboringcrypto_SHA512_Final(uint8_t*, GO_SHA512_CTX*);
-
-// #include <openssl/digest.h>
-/*unchecked (opaque)*/ typedef struct GO_EVP_MD { char data[1]; } GO_EVP_MD;
-const GO_EVP_MD* _goboringcrypto_EVP_md4(void);
-const GO_EVP_MD* _goboringcrypto_EVP_md5(void);
-const GO_EVP_MD* _goboringcrypto_EVP_md5_sha1(void);
-const GO_EVP_MD* _goboringcrypto_EVP_sha1(void);
-const GO_EVP_MD* _goboringcrypto_EVP_sha224(void);
-const GO_EVP_MD* _goboringcrypto_EVP_sha256(void);
-const GO_EVP_MD* _goboringcrypto_EVP_sha384(void);
-const GO_EVP_MD* _goboringcrypto_EVP_sha512(void);
-int _goboringcrypto_EVP_MD_type(const GO_EVP_MD*);
-size_t _goboringcrypto_EVP_MD_size(const GO_EVP_MD*);
-
-// #include <openssl/hmac.h>
-typedef struct GO_HMAC_CTX { char data[104]; } GO_HMAC_CTX;
-void _goboringcrypto_HMAC_CTX_init(GO_HMAC_CTX*);
-void _goboringcrypto_HMAC_CTX_cleanup(GO_HMAC_CTX*);
-int _goboringcrypto_HMAC_Init(GO_HMAC_CTX*, const void*, int, const GO_EVP_MD*);
-int _goboringcrypto_HMAC_Update(GO_HMAC_CTX*, const uint8_t*, size_t);
-int _goboringcrypto_HMAC_Final(GO_HMAC_CTX*, uint8_t*, unsigned int*);
-size_t _goboringcrypto_HMAC_size(const GO_HMAC_CTX*);
-int _goboringcrypto_HMAC_CTX_copy_ex(GO_HMAC_CTX *dest, const GO_HMAC_CTX *src);
-
-// #include <openssl/aes.h>
-typedef struct GO_AES_KEY { char data[244]; } GO_AES_KEY;
-int _goboringcrypto_AES_set_encrypt_key(const uint8_t*, unsigned int, GO_AES_KEY*);
-int _goboringcrypto_AES_set_decrypt_key(const uint8_t*, unsigned int, GO_AES_KEY*);
-void _goboringcrypto_AES_encrypt(const uint8_t*, uint8_t*, const GO_AES_KEY*);
-void _goboringcrypto_AES_decrypt(const uint8_t*, uint8_t*, const GO_AES_KEY*);
-void _goboringcrypto_AES_ctr128_encrypt(const uint8_t*, uint8_t*, size_t, const GO_AES_KEY*, uint8_t*, uint8_t*, unsigned int*);
-enum {
-	GO_AES_ENCRYPT = 1,
-	GO_AES_DECRYPT = 0
-};
-void _goboringcrypto_AES_cbc_encrypt(const uint8_t*, uint8_t*, size_t, const GO_AES_KEY*, uint8_t*, const int);
-
-// #include <openssl/aead.h>
-/*unchecked (opaque)*/ typedef struct GO_EVP_AEAD { char data[1]; } GO_EVP_AEAD;
-/*unchecked (opaque)*/ typedef struct GO_ENGINE { char data[1]; } GO_ENGINE;
-const GO_EVP_AEAD* _goboringcrypto_EVP_aead_aes_128_gcm(void);
-const GO_EVP_AEAD* _goboringcrypto_EVP_aead_aes_256_gcm(void);
-enum {
-	GO_EVP_AEAD_DEFAULT_TAG_LENGTH = 0
-};
-size_t _goboringcrypto_EVP_AEAD_key_length(const GO_EVP_AEAD*);
-size_t _goboringcrypto_EVP_AEAD_nonce_length(const GO_EVP_AEAD*);
-size_t _goboringcrypto_EVP_AEAD_max_overhead(const GO_EVP_AEAD*);
-size_t _goboringcrypto_EVP_AEAD_max_tag_len(const GO_EVP_AEAD*);
-typedef struct GO_EVP_AEAD_CTX { char data[600]; } GO_EVP_AEAD_CTX;
-void _goboringcrypto_EVP_AEAD_CTX_zero(GO_EVP_AEAD_CTX*);
-int _goboringcrypto_EVP_AEAD_CTX_init(GO_EVP_AEAD_CTX*, const GO_EVP_AEAD*, const uint8_t*, size_t, size_t, GO_ENGINE*);
-void _goboringcrypto_EVP_AEAD_CTX_cleanup(GO_EVP_AEAD_CTX*);
-int _goboringcrypto_EVP_AEAD_CTX_seal(const GO_EVP_AEAD_CTX*, uint8_t*, size_t*, size_t, const uint8_t*, size_t, const uint8_t*, size_t, const uint8_t*, size_t);
-int _goboringcrypto_EVP_AEAD_CTX_open(const GO_EVP_AEAD_CTX*, uint8_t*, size_t*, size_t, const uint8_t*, size_t, const uint8_t*, size_t, const uint8_t*, size_t);
-const GO_EVP_AEAD* _goboringcrypto_EVP_aead_aes_128_gcm_tls12(void);
-const GO_EVP_AEAD* _goboringcrypto_EVP_aead_aes_256_gcm_tls12(void);
-enum go_evp_aead_direction_t {
-	go_evp_aead_open = 0,
-	go_evp_aead_seal = 1
-};
-int _goboringcrypto_EVP_AEAD_CTX_init_with_direction(GO_EVP_AEAD_CTX*, const GO_EVP_AEAD*, const uint8_t*, size_t, size_t, enum go_evp_aead_direction_t);
-
-// #include <openssl/bn.h>
-/*unchecked (opaque)*/ typedef struct GO_BN_CTX { char data[1]; } GO_BN_CTX;
-typedef struct GO_BIGNUM { char data[24]; } GO_BIGNUM;
-GO_BIGNUM* _goboringcrypto_BN_new(void);
-void _goboringcrypto_BN_free(GO_BIGNUM*);
-unsigned _goboringcrypto_BN_num_bits(const GO_BIGNUM*);
-unsigned _goboringcrypto_BN_num_bytes(const GO_BIGNUM*);
-int _goboringcrypto_BN_is_negative(const GO_BIGNUM*);
-GO_BIGNUM* _goboringcrypto_BN_bin2bn(const uint8_t*, size_t, GO_BIGNUM*);
-size_t _goboringcrypto_BN_bn2bin(const GO_BIGNUM*, uint8_t*);
-
-// #include <openssl/ec.h>
-/*unchecked (opaque)*/ typedef struct GO_EC_GROUP { char data[1]; } GO_EC_GROUP;
-GO_EC_GROUP* _goboringcrypto_EC_GROUP_new_by_curve_name(int);
-void _goboringcrypto_EC_GROUP_free(GO_EC_GROUP*);
-
-/*unchecked (opaque)*/ typedef struct GO_EC_POINT { char data[1]; } GO_EC_POINT;
-GO_EC_POINT* _goboringcrypto_EC_POINT_new(const GO_EC_GROUP*);
-void _goboringcrypto_EC_POINT_free(GO_EC_POINT*);
-int _goboringcrypto_EC_POINT_get_affine_coordinates_GFp(const GO_EC_GROUP*, const GO_EC_POINT*, GO_BIGNUM*, GO_BIGNUM*, GO_BN_CTX*);
-int _goboringcrypto_EC_POINT_set_affine_coordinates_GFp(const GO_EC_GROUP*, GO_EC_POINT*, const GO_BIGNUM*, const GO_BIGNUM*, GO_BN_CTX*);
-
-// #include <openssl/ec_key.h>
-/*unchecked (opaque)*/ typedef struct GO_EC_KEY { char data[1]; } GO_EC_KEY;
-GO_EC_KEY* _goboringcrypto_EC_KEY_new(void);
-GO_EC_KEY* _goboringcrypto_EC_KEY_new_by_curve_name(int);
-void _goboringcrypto_EC_KEY_free(GO_EC_KEY*);
-const GO_EC_GROUP* _goboringcrypto_EC_KEY_get0_group(const GO_EC_KEY*);
-int _goboringcrypto_EC_KEY_generate_key_fips(GO_EC_KEY*);
-int _goboringcrypto_EC_KEY_set_private_key(GO_EC_KEY*, const GO_BIGNUM*);
-int _goboringcrypto_EC_KEY_set_public_key(GO_EC_KEY*, const GO_EC_POINT*);
-int _goboringcrypto_EC_KEY_is_opaque(const GO_EC_KEY*);
-const GO_BIGNUM* _goboringcrypto_EC_KEY_get0_private_key(const GO_EC_KEY*);
-const GO_EC_POINT* _goboringcrypto_EC_KEY_get0_public_key(const GO_EC_KEY*);
-// TODO: EC_KEY_check_fips?
-
-// #include <openssl/ecdsa.h>
-typedef struct GO_ECDSA_SIG { char data[16]; } GO_ECDSA_SIG;
-GO_ECDSA_SIG* _goboringcrypto_ECDSA_SIG_new(void);
-void _goboringcrypto_ECDSA_SIG_free(GO_ECDSA_SIG*);
-GO_ECDSA_SIG* _goboringcrypto_ECDSA_do_sign(const uint8_t*, size_t, const GO_EC_KEY*);
-int _goboringcrypto_ECDSA_do_verify(const uint8_t*, size_t, const GO_ECDSA_SIG*, const GO_EC_KEY*);
-int _goboringcrypto_ECDSA_sign(int, const uint8_t*, size_t, uint8_t*, unsigned int*, const GO_EC_KEY*);
-size_t _goboringcrypto_ECDSA_size(const GO_EC_KEY*);
-int _goboringcrypto_ECDSA_verify(int, const uint8_t*, size_t, const uint8_t*, size_t, const GO_EC_KEY*);
-
-// #include <openssl/rsa.h>
-
-// Note: order of struct fields here is unchecked.
-typedef struct GO_RSA { void *meth; GO_BIGNUM *n, *e, *d, *p, *q, *dmp1, *dmq1, *iqmp; char data[160]; } GO_RSA;
-/*unchecked (opaque)*/ typedef struct GO_BN_GENCB { char data[1]; } GO_BN_GENCB;
-GO_RSA* _goboringcrypto_RSA_new(void);
-void _goboringcrypto_RSA_free(GO_RSA*);
-void _goboringcrypto_RSA_get0_key(const GO_RSA*, const GO_BIGNUM **n, const GO_BIGNUM **e, const GO_BIGNUM **d);
-void _goboringcrypto_RSA_get0_factors(const GO_RSA*, const GO_BIGNUM **p, const GO_BIGNUM **q);
-void _goboringcrypto_RSA_get0_crt_params(const GO_RSA*, const GO_BIGNUM **dmp1, const GO_BIGNUM **dmp2, const GO_BIGNUM **iqmp);
-int _goboringcrypto_RSA_generate_key_ex(GO_RSA*, int, const GO_BIGNUM*, GO_BN_GENCB*);
-int _goboringcrypto_RSA_generate_key_fips(GO_RSA*, int, GO_BN_GENCB*);
-enum {
-	GO_RSA_PKCS1_PADDING = 1,
-	GO_RSA_NO_PADDING = 3,
-	GO_RSA_PKCS1_OAEP_PADDING = 4,
-	GO_RSA_PKCS1_PSS_PADDING = 6,
-};
-int _goboringcrypto_RSA_encrypt(GO_RSA*, size_t *out_len, uint8_t *out, size_t max_out, const uint8_t *in, size_t in_len, int padding);
-int _goboringcrypto_RSA_decrypt(GO_RSA*, size_t *out_len, uint8_t *out, size_t max_out, const uint8_t *in, size_t in_len, int padding);
-int _goboringcrypto_RSA_sign(int hash_nid, const uint8_t* in, unsigned int in_len, uint8_t *out, unsigned int *out_len, GO_RSA*);
-int _goboringcrypto_RSA_sign_pss_mgf1(GO_RSA*, size_t *out_len, uint8_t *out, size_t max_out, const uint8_t *in, size_t in_len, const GO_EVP_MD *md, const GO_EVP_MD *mgf1_md, int salt_len);
-int _goboringcrypto_RSA_sign_raw(GO_RSA*, size_t *out_len, uint8_t *out, size_t max_out, const uint8_t *in, size_t in_len, int padding);
-int _goboringcrypto_RSA_verify(int hash_nid, const uint8_t *msg, size_t msg_len, const uint8_t *sig, size_t sig_len, GO_RSA*);
-int _goboringcrypto_RSA_verify_pss_mgf1(GO_RSA*, const uint8_t *msg, size_t msg_len, const GO_EVP_MD *md, const GO_EVP_MD *mgf1_md, int salt_len, const uint8_t *sig, size_t sig_len);
-int _goboringcrypto_RSA_verify_raw(GO_RSA*, size_t *out_len, uint8_t *out, size_t max_out, const uint8_t *in, size_t in_len, int padding);
-unsigned _goboringcrypto_RSA_size(const GO_RSA*);
-int _goboringcrypto_RSA_is_opaque(const GO_RSA*);
-int _goboringcrypto_RSA_check_key(const GO_RSA*);
-int _goboringcrypto_RSA_check_fips(GO_RSA*);
-GO_RSA* _goboringcrypto_RSA_public_key_from_bytes(const uint8_t*, size_t);
-GO_RSA* _goboringcrypto_RSA_private_key_from_bytes(const uint8_t*, size_t);
-int _goboringcrypto_RSA_public_key_to_bytes(uint8_t**, size_t*, const GO_RSA*);
-int _goboringcrypto_RSA_private_key_to_bytes(uint8_t**, size_t*, const GO_RSA*);
-
-// #include <openssl/evp.h>
-/*unchecked (opaque)*/ typedef struct GO_EVP_PKEY { char data[1]; } GO_EVP_PKEY;
-GO_EVP_PKEY* _goboringcrypto_EVP_PKEY_new(void);
-void _goboringcrypto_EVP_PKEY_free(GO_EVP_PKEY*);
-int _goboringcrypto_EVP_PKEY_set1_RSA(GO_EVP_PKEY*, GO_RSA*);
-
-/*unchecked (opaque)*/ typedef struct GO_EVP_PKEY_CTX { char data[1]; } GO_EVP_PKEY_CTX;
-
-GO_EVP_PKEY_CTX* _goboringcrypto_EVP_PKEY_CTX_new(GO_EVP_PKEY*, GO_ENGINE*);
-void _goboringcrypto_EVP_PKEY_CTX_free(GO_EVP_PKEY_CTX*);
-int _goboringcrypto_EVP_PKEY_CTX_set0_rsa_oaep_label(GO_EVP_PKEY_CTX*, uint8_t*, size_t);
-int _goboringcrypto_EVP_PKEY_CTX_set_rsa_oaep_md(GO_EVP_PKEY_CTX*, const GO_EVP_MD*);
-int _goboringcrypto_EVP_PKEY_CTX_set_rsa_padding(GO_EVP_PKEY_CTX*, int padding);
-int _goboringcrypto_EVP_PKEY_decrypt(GO_EVP_PKEY_CTX*, uint8_t*, size_t*, const uint8_t*, size_t);
-int _goboringcrypto_EVP_PKEY_encrypt(GO_EVP_PKEY_CTX*, uint8_t*, size_t*, const uint8_t*, size_t);
-int _goboringcrypto_EVP_PKEY_decrypt_init(GO_EVP_PKEY_CTX*);
-int _goboringcrypto_EVP_PKEY_encrypt_init(GO_EVP_PKEY_CTX*);
-int _goboringcrypto_EVP_PKEY_CTX_set_rsa_mgf1_md(GO_EVP_PKEY_CTX*, const GO_EVP_MD*);
-int _goboringcrypto_EVP_PKEY_CTX_set_rsa_pss_saltlen(GO_EVP_PKEY_CTX*, int);
-int _goboringcrypto_EVP_PKEY_sign_init(GO_EVP_PKEY_CTX*);
-int _goboringcrypto_EVP_PKEY_verify_init(GO_EVP_PKEY_CTX*);
-int _goboringcrypto_EVP_PKEY_sign(GO_EVP_PKEY_CTX*, uint8_t*, size_t*, const uint8_t*, size_t);
diff --git a/src/crypto/internal/boring/goboringcrypto_linux_amd64.syso b/src/crypto/internal/boring/goboringcrypto_linux_amd64.syso
deleted file mode 100644
index 2459dd7804..0000000000
Binary files a/src/crypto/internal/boring/goboringcrypto_linux_amd64.syso and /dev/null differ
diff --git a/src/crypto/internal/boring/hmac.go b/src/crypto/internal/boring/hmac.go
deleted file mode 100644
index 01b5844e5f..0000000000
--- a/src/crypto/internal/boring/hmac.go
+++ /dev/null
@@ -1,156 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build linux,amd64
-// +build !android
-// +build !cmd_go_bootstrap
-// +build !msan
-
-package boring
-
-// #include "goboringcrypto.h"
-import "C"
-import (
-	"crypto"
-	"hash"
-	"runtime"
-	"unsafe"
-)
-
-// hashToMD converts a hash.Hash implementation from this package
-// to a BoringCrypto *C.GO_EVP_MD.
-func hashToMD(h hash.Hash) *C.GO_EVP_MD {
-	switch h.(type) {
-	case *sha1Hash:
-		return C._goboringcrypto_EVP_sha1()
-	case *sha224Hash:
-		return C._goboringcrypto_EVP_sha224()
-	case *sha256Hash:
-		return C._goboringcrypto_EVP_sha256()
-	case *sha384Hash:
-		return C._goboringcrypto_EVP_sha384()
-	case *sha512Hash:
-		return C._goboringcrypto_EVP_sha512()
-	}
-	return nil
-}
-
-// cryptoHashToMD converts a crypto.Hash
-// to a BoringCrypto *C.GO_EVP_MD.
-func cryptoHashToMD(ch crypto.Hash) *C.GO_EVP_MD {
-	switch ch {
-	case crypto.MD5:
-		return C._goboringcrypto_EVP_md5()
-	case crypto.MD5SHA1:
-		return C._goboringcrypto_EVP_md5_sha1()
-	case crypto.SHA1:
-		return C._goboringcrypto_EVP_sha1()
-	case crypto.SHA224:
-		return C._goboringcrypto_EVP_sha224()
-	case crypto.SHA256:
-		return C._goboringcrypto_EVP_sha256()
-	case crypto.SHA384:
-		return C._goboringcrypto_EVP_sha384()
-	case crypto.SHA512:
-		return C._goboringcrypto_EVP_sha512()
-	}
-	return nil
-}
-
-// NewHMAC returns a new HMAC using BoringCrypto.
-// The function h must return a hash implemented by
-// BoringCrypto (for example, h could be boring.NewSHA256).
-// If h is not recognized, NewHMAC returns nil.
-func NewHMAC(h func() hash.Hash, key []byte) hash.Hash {
-	ch := h()
-	md := hashToMD(ch)
-	if md == nil {
-		return nil
-	}
-
-	// Note: Could hash down long keys here using EVP_Digest.
-	hkey := make([]byte, len(key))
-	copy(hkey, key)
-	hmac := &boringHMAC{
-		md:        md,
-		size:      ch.Size(),
-		blockSize: ch.BlockSize(),
-		key:       hkey,
-	}
-	hmac.Reset()
-	return hmac
-}
-
-type boringHMAC struct {
-	md          *C.GO_EVP_MD
-	ctx         C.GO_HMAC_CTX
-	ctx2        C.GO_HMAC_CTX
-	size        int
-	blockSize   int
-	key         []byte
-	sum         []byte
-	needCleanup bool
-}
-
-func (h *boringHMAC) Reset() {
-	if h.needCleanup {
-		C._goboringcrypto_HMAC_CTX_cleanup(&h.ctx)
-	} else {
-		h.needCleanup = true
-		// Note: Because of the finalizer, any time h.ctx is passed to cgo,
-		// that call must be followed by a call to runtime.KeepAlive(h),
-		// to make sure h is not collected (and finalized) before the cgo
-		// call returns.
-		runtime.SetFinalizer(h, (*boringHMAC).finalize)
-	}
-	C._goboringcrypto_HMAC_CTX_init(&h.ctx)
-
-	if C._goboringcrypto_HMAC_Init(&h.ctx, unsafe.Pointer(base(h.key)), C.int(len(h.key)), h.md) == 0 {
-		panic("boringcrypto: HMAC_Init failed")
-	}
-	if int(C._goboringcrypto_HMAC_size(&h.ctx)) != h.size {
-		println("boringcrypto: HMAC size:", C._goboringcrypto_HMAC_size(&h.ctx), "!=", h.size)
-		panic("boringcrypto: HMAC size mismatch")
-	}
-	runtime.KeepAlive(h) // Next line will keep h alive too; just making doubly sure.
-	h.sum = nil
-}
-
-func (h *boringHMAC) finalize() {
-	C._goboringcrypto_HMAC_CTX_cleanup(&h.ctx)
-}
-
-func (h *boringHMAC) Write(p []byte) (int, error) {
-	if len(p) > 0 {
-		C._goboringcrypto_HMAC_Update(&h.ctx, (*C.uint8_t)(unsafe.Pointer(&p[0])), C.size_t(len(p)))
-	}
-	runtime.KeepAlive(h)
-	return len(p), nil
-}
-
-func (h *boringHMAC) Size() int {
-	return h.size
-}
-
-func (h *boringHMAC) BlockSize() int {
-	return h.blockSize
-}
-
-func (h *boringHMAC) Sum(in []byte) []byte {
-	if h.sum == nil {
-		size := h.Size()
-		h.sum = make([]byte, size)
-	}
-	// Make copy of context because Go hash.Hash mandates
-	// that Sum has no effect on the underlying stream.
-	// In particular it is OK to Sum, then Write more, then Sum again,
-	// and the second Sum acts as if the first didn't happen.
-	C._goboringcrypto_HMAC_CTX_init(&h.ctx2)
-	if C._goboringcrypto_HMAC_CTX_copy_ex(&h.ctx2, &h.ctx) == 0 {
-		panic("boringcrypto: HMAC_CTX_copy_ex failed")
-	}
-	C._goboringcrypto_HMAC_Final(&h.ctx2, (*C.uint8_t)(unsafe.Pointer(&h.sum[0])), nil)
-	C._goboringcrypto_HMAC_CTX_cleanup(&h.ctx2)
-	return append(in, h.sum...)
-}
diff --git a/src/crypto/internal/boring/notboring.go b/src/crypto/internal/boring/notboring.go
deleted file mode 100644
index c21cb3cd55..0000000000
--- a/src/crypto/internal/boring/notboring.go
+++ /dev/null
@@ -1,109 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build !linux !amd64 !cgo android cmd_go_bootstrap msan
-
-package boring
-
-import (
-	"crypto"
-	"crypto/cipher"
-	"crypto/internal/boring/sig"
-	"hash"
-	"math/big"
-)
-
-const available = false
-
-// Unreachable marks code that should be unreachable
-// when BoringCrypto is in use. It is a no-op without BoringCrypto.
-func Unreachable() {
-	// Code that's unreachable when using BoringCrypto
-	// is exactly the code we want to detect for reporting
-	// standard Go crypto.
-	sig.StandardCrypto()
-}
-
-// UnreachableExceptTests marks code that should be unreachable
-// when BoringCrypto is in use. It is a no-op without BoringCrypto.
-func UnreachableExceptTests() {}
-
-type randReader int
-
-func (randReader) Read(b []byte) (int, error) { panic("boringcrypto: not available") }
-
-const RandReader = randReader(0)
-
-func NewSHA1() hash.Hash   { panic("boringcrypto: not available") }
-func NewSHA224() hash.Hash { panic("boringcrypto: not available") }
-func NewSHA256() hash.Hash { panic("boringcrypto: not available") }
-func NewSHA384() hash.Hash { panic("boringcrypto: not available") }
-func NewSHA512() hash.Hash { panic("boringcrypto: not available") }
-
-func NewHMAC(h func() hash.Hash, key []byte) hash.Hash { panic("boringcrypto: not available") }
-
-func NewAESCipher(key []byte) (cipher.Block, error) { panic("boringcrypto: not available") }
-
-type PublicKeyECDSA struct{ _ int }
-type PrivateKeyECDSA struct{ _ int }
-
-func GenerateKeyECDSA(curve string) (X, Y, D *big.Int, err error) {
-	panic("boringcrypto: not available")
-}
-func NewPrivateKeyECDSA(curve string, X, Y, D *big.Int) (*PrivateKeyECDSA, error) {
-	panic("boringcrypto: not available")
-}
-func NewPublicKeyECDSA(curve string, X, Y *big.Int) (*PublicKeyECDSA, error) {
-	panic("boringcrypto: not available")
-}
-func SignECDSA(priv *PrivateKeyECDSA, hash []byte) (r, s *big.Int, err error) {
-	panic("boringcrypto: not available")
-}
-func SignMarshalECDSA(priv *PrivateKeyECDSA, hash []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, r, s *big.Int) bool {
-	panic("boringcrypto: not available")
-}
-
-type PublicKeyRSA struct{ _ int }
-type PrivateKeyRSA struct{ _ int }
-
-func DecryptRSAOAEP(h hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func EncryptRSAOAEP(h hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv *big.Int, err error) {
-	panic("boringcrypto: not available")
-}
-func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv *big.Int) (*PrivateKeyRSA, error) {
-	panic("boringcrypto: not available")
-}
-func NewPublicKeyRSA(N, E *big.Int) (*PublicKeyRSA, error) { panic("boringcrypto: not available") }
-func SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
-	panic("boringcrypto: not available")
-}
-func VerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
-	panic("boringcrypto: not available")
-}
-func VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
-	panic("boringcrypto: not available")
-}
diff --git a/src/crypto/internal/boring/rand.go b/src/crypto/internal/boring/rand.go
deleted file mode 100644
index c3fc27cc08..0000000000
--- a/src/crypto/internal/boring/rand.go
+++ /dev/null
@@ -1,27 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build linux,amd64
-// +build !android
-// +build !cmd_go_bootstrap
-// +build !msan
-
-package boring
-
-// #include "goboringcrypto.h"
-import "C"
-import "unsafe"
-
-type randReader int
-
-func (randReader) Read(b []byte) (int, error) {
-	// Note: RAND_bytes should never fail; the return value exists only for historical reasons.
-	// We check it even so.
-	if len(b) > 0 && C._goboringcrypto_RAND_bytes((*C.uint8_t)(unsafe.Pointer(&b[0])), C.size_t(len(b))) == 0 {
-		return 0, fail("RAND_bytes")
-	}
-	return len(b), nil
-}
-
-const RandReader = randReader(0)
diff --git a/src/crypto/internal/boring/rsa.go b/src/crypto/internal/boring/rsa.go
deleted file mode 100644
index a10831dd00..0000000000
--- a/src/crypto/internal/boring/rsa.go
+++ /dev/null
@@ -1,350 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build linux,amd64
-// +build !android
-// +build !cmd_go_bootstrap
-// +build !msan
-
-package boring
-
-// #include "goboringcrypto.h"
-import "C"
-import (
-	"crypto"
-	"crypto/subtle"
-	"errors"
-	"hash"
-	"math/big"
-	"runtime"
-	"strconv"
-	"unsafe"
-)
-
-func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv *big.Int, err error) {
-	bad := func(e error) (N, E, D, P, Q, Dp, Dq, Qinv *big.Int, err error) {
-		return nil, nil, nil, nil, nil, nil, nil, nil, e
-	}
-
-	key := C._goboringcrypto_RSA_new()
-	if key == nil {
-		return bad(fail("RSA_new"))
-	}
-	defer C._goboringcrypto_RSA_free(key)
-
-	if C._goboringcrypto_RSA_generate_key_fips(key, C.int(bits), nil) == 0 {
-		return bad(fail("RSA_generate_key_fips"))
-	}
-
-	var n, e, d, p, q, dp, dq, qinv *C.GO_BIGNUM
-	C._goboringcrypto_RSA_get0_key(key, &n, &e, &d)
-	C._goboringcrypto_RSA_get0_factors(key, &p, &q)
-	C._goboringcrypto_RSA_get0_crt_params(key, &dp, &dq, &qinv)
-	return bnToBig(n), bnToBig(e), bnToBig(d), bnToBig(p), bnToBig(q), bnToBig(dp), bnToBig(dq), bnToBig(qinv), nil
-}
-
-type PublicKeyRSA struct {
-	// _key MUST NOT be accessed directly. Instead, use the withKey method.
-	_key *C.GO_RSA
-}
-
-func NewPublicKeyRSA(N, E *big.Int) (*PublicKeyRSA, error) {
-	key := C._goboringcrypto_RSA_new()
-	if key == nil {
-		return nil, fail("RSA_new")
-	}
-	if !bigToBn(&key.n, N) ||
-		!bigToBn(&key.e, E) {
-		return nil, fail("BN_bin2bn")
-	}
-	k := &PublicKeyRSA{_key: key}
-	runtime.SetFinalizer(k, (*PublicKeyRSA).finalize)
-	return k, nil
-}
-
-func (k *PublicKeyRSA) finalize() {
-	C._goboringcrypto_RSA_free(k._key)
-}
-
-func (k *PublicKeyRSA) withKey(f func(*C.GO_RSA) C.int) C.int {
-	// Because of the finalizer, any time _key is passed to cgo, that call must
-	// be followed by a call to runtime.KeepAlive, to make sure k is not
-	// collected (and finalized) before the cgo call returns.
-	defer runtime.KeepAlive(k)
-	return f(k._key)
-}
-
-type PrivateKeyRSA struct {
-	// _key MUST NOT be accessed directly. Instead, use the withKey method.
-	_key *C.GO_RSA
-}
-
-func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv *big.Int) (*PrivateKeyRSA, error) {
-	key := C._goboringcrypto_RSA_new()
-	if key == nil {
-		return nil, fail("RSA_new")
-	}
-	if !bigToBn(&key.n, N) ||
-		!bigToBn(&key.e, E) ||
-		!bigToBn(&key.d, D) ||
-		!bigToBn(&key.p, P) ||
-		!bigToBn(&key.q, Q) ||
-		!bigToBn(&key.dmp1, Dp) ||
-		!bigToBn(&key.dmq1, Dq) ||
-		!bigToBn(&key.iqmp, Qinv) {
-		return nil, fail("BN_bin2bn")
-	}
-	k := &PrivateKeyRSA{_key: key}
-	runtime.SetFinalizer(k, (*PrivateKeyRSA).finalize)
-	return k, nil
-}
-
-func (k *PrivateKeyRSA) finalize() {
-	C._goboringcrypto_RSA_free(k._key)
-}
-
-func (k *PrivateKeyRSA) withKey(f func(*C.GO_RSA) C.int) C.int {
-	// Because of the finalizer, any time _key is passed to cgo, that call must
-	// be followed by a call to runtime.KeepAlive, to make sure k is not
-	// collected (and finalized) before the cgo call returns.
-	defer runtime.KeepAlive(k)
-	return f(k._key)
-}
-
-func setupRSA(withKey func(func(*C.GO_RSA) C.int) C.int,
-	padding C.int, h hash.Hash, label []byte, saltLen int, ch crypto.Hash,
-	init func(*C.GO_EVP_PKEY_CTX) C.int) (pkey *C.GO_EVP_PKEY, ctx *C.GO_EVP_PKEY_CTX, err error) {
-	defer func() {
-		if err != nil {
-			if pkey != nil {
-				C._goboringcrypto_EVP_PKEY_free(pkey)
-				pkey = nil
-			}
-			if ctx != nil {
-				C._goboringcrypto_EVP_PKEY_CTX_free(ctx)
-				ctx = nil
-			}
-		}
-	}()
-
-	pkey = C._goboringcrypto_EVP_PKEY_new()
-	if pkey == nil {
-		return nil, nil, fail("EVP_PKEY_new")
-	}
-	if withKey(func(key *C.GO_RSA) C.int {
-		return C._goboringcrypto_EVP_PKEY_set1_RSA(pkey, key)
-	}) == 0 {
-		return nil, nil, fail("EVP_PKEY_set1_RSA")
-	}
-	ctx = C._goboringcrypto_EVP_PKEY_CTX_new(pkey, nil)
-	if ctx == nil {
-		return nil, nil, fail("EVP_PKEY_CTX_new")
-	}
-	if init(ctx) == 0 {
-		return nil, nil, fail("EVP_PKEY_operation_init")
-	}
-	if C._goboringcrypto_EVP_PKEY_CTX_set_rsa_padding(ctx, padding) == 0 {
-		return nil, nil, fail("EVP_PKEY_CTX_set_rsa_padding")
-	}
-	if padding == C.GO_RSA_PKCS1_OAEP_PADDING {
-		md := hashToMD(h)
-		if md == nil {
-			return nil, nil, errors.New("crypto/rsa: unsupported hash function")
-		}
-		if C._goboringcrypto_EVP_PKEY_CTX_set_rsa_oaep_md(ctx, md) == 0 {
-			return nil, nil, fail("EVP_PKEY_set_rsa_oaep_md")
-		}
-		// ctx takes ownership of label, so malloc a copy for BoringCrypto to free.
-		clabel := (*C.uint8_t)(C._goboringcrypto_OPENSSL_malloc(C.size_t(len(label))))
-		if clabel == nil {
-			return nil, nil, fail("OPENSSL_malloc")
-		}
-		copy((*[1 << 30]byte)(unsafe.Pointer(clabel))[:len(label)], label)
-		if C._goboringcrypto_EVP_PKEY_CTX_set0_rsa_oaep_label(ctx, clabel, C.size_t(len(label))) == 0 {
-			return nil, nil, fail("EVP_PKEY_CTX_set0_rsa_oaep_label")
-		}
-	}
-	if padding == C.GO_RSA_PKCS1_PSS_PADDING {
-		if saltLen != 0 {
-			if C._goboringcrypto_EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, C.int(saltLen)) == 0 {
-				return nil, nil, fail("EVP_PKEY_set_rsa_pss_saltlen")
-			}
-		}
-		md := cryptoHashToMD(ch)
-		if md == nil {
-			return nil, nil, errors.New("crypto/rsa: unsupported hash function")
-		}
-		if C._goboringcrypto_EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, md) == 0 {
-			return nil, nil, fail("EVP_PKEY_set_rsa_mgf1_md")
-		}
-	}
-
-	return pkey, ctx, nil
-}
-
-func cryptRSA(withKey func(func(*C.GO_RSA) C.int) C.int,
-	padding C.int, h hash.Hash, label []byte, saltLen int, ch crypto.Hash,
-	init func(*C.GO_EVP_PKEY_CTX) C.int,
-	crypt func(*C.GO_EVP_PKEY_CTX, *C.uint8_t, *C.size_t, *C.uint8_t, C.size_t) C.int,
-	in []byte) ([]byte, error) {
-
-	pkey, ctx, err := setupRSA(withKey, padding, h, label, saltLen, ch, init)
-	if err != nil {
-		return nil, err
-	}
-	defer C._goboringcrypto_EVP_PKEY_free(pkey)
-	defer C._goboringcrypto_EVP_PKEY_CTX_free(ctx)
-
-	var outLen C.size_t
-	if crypt(ctx, nil, &outLen, base(in), C.size_t(len(in))) == 0 {
-		return nil, fail("EVP_PKEY_decrypt/encrypt")
-	}
-	out := make([]byte, outLen)
-	if crypt(ctx, base(out), &outLen, base(in), C.size_t(len(in))) == 0 {
-		return nil, fail("EVP_PKEY_decrypt/encrypt")
-	}
-	return out[:outLen], nil
-}
-
-func DecryptRSAOAEP(h hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
-	return cryptRSA(priv.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, label, 0, 0, decryptInit, decrypt, ciphertext)
-}
-
-func EncryptRSAOAEP(h hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
-	return cryptRSA(pub.withKey, C.GO_RSA_PKCS1_OAEP_PADDING, h, label, 0, 0, encryptInit, encrypt, msg)
-}
-
-func DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
-	return cryptRSA(priv.withKey, C.GO_RSA_PKCS1_PADDING, nil, nil, 0, 0, decryptInit, decrypt, ciphertext)
-}
-
-func EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
-	return cryptRSA(pub.withKey, C.GO_RSA_PKCS1_PADDING, nil, nil, 0, 0, encryptInit, encrypt, msg)
-}
-
-func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
-	return cryptRSA(priv.withKey, C.GO_RSA_NO_PADDING, nil, nil, 0, 0, decryptInit, decrypt, ciphertext)
-}
-
-func EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
-	return cryptRSA(pub.withKey, C.GO_RSA_NO_PADDING, nil, nil, 0, 0, encryptInit, encrypt, msg)
-}
-
-// These dumb wrappers work around the fact that cgo functions cannot be used as values directly.
-
-func decryptInit(ctx *C.GO_EVP_PKEY_CTX) C.int {
-	return C._goboringcrypto_EVP_PKEY_decrypt_init(ctx)
-}
-
-func decrypt(ctx *C.GO_EVP_PKEY_CTX, out *C.uint8_t, outLen *C.size_t, in *C.uint8_t, inLen C.size_t) C.int {
-	return C._goboringcrypto_EVP_PKEY_decrypt(ctx, out, outLen, in, inLen)
-}
-
-func encryptInit(ctx *C.GO_EVP_PKEY_CTX) C.int {
-	return C._goboringcrypto_EVP_PKEY_encrypt_init(ctx)
-}
-
-func encrypt(ctx *C.GO_EVP_PKEY_CTX, out *C.uint8_t, outLen *C.size_t, in *C.uint8_t, inLen C.size_t) C.int {
-	return C._goboringcrypto_EVP_PKEY_encrypt(ctx, out, outLen, in, inLen)
-}
-
-func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
-	md := cryptoHashToMD(h)
-	if md == nil {
-		return nil, errors.New("crypto/rsa: unsupported hash function")
-	}
-	if saltLen == 0 {
-		saltLen = -1
-	}
-	var out []byte
-	var outLen C.size_t
-	if priv.withKey(func(key *C.GO_RSA) C.int {
-		out = make([]byte, C._goboringcrypto_RSA_size(key))
-		return C._goboringcrypto_RSA_sign_pss_mgf1(key, &outLen, base(out), C.size_t(len(out)),
-			base(hashed), C.size_t(len(hashed)), md, nil, C.int(saltLen))
-	}) == 0 {
-		return nil, fail("RSA_sign_pss_mgf1")
-	}
-
-	return out[:outLen], nil
-}
-
-func VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
-	md := cryptoHashToMD(h)
-	if md == nil {
-		return errors.New("crypto/rsa: unsupported hash function")
-	}
-	if saltLen == 0 {
-		saltLen = -2 // auto-recover
-	}
-	if pub.withKey(func(key *C.GO_RSA) C.int {
-		return C._goboringcrypto_RSA_verify_pss_mgf1(key, base(hashed), C.size_t(len(hashed)),
-			md, nil, C.int(saltLen), base(sig), C.size_t(len(sig)))
-	}) == 0 {
-		return fail("RSA_verify_pss_mgf1")
-	}
-	return nil
-}
-
-func SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
-	if h == 0 {
-		// No hashing.
-		var out []byte
-		var outLen C.size_t
-		if priv.withKey(func(key *C.GO_RSA) C.int {
-			out = make([]byte, C._goboringcrypto_RSA_size(key))
-			return C._goboringcrypto_RSA_sign_raw(key, &outLen, base(out), C.size_t(len(out)),
-				base(hashed), C.size_t(len(hashed)), C.GO_RSA_PKCS1_PADDING)
-		}) == 0 {
-			return nil, fail("RSA_sign_raw")
-		}
-		return out[:outLen], nil
-	}
-
-	md := cryptoHashToMD(h)
-	if md == nil {
-		return nil, errors.New("crypto/rsa: unsupported hash function: " + strconv.Itoa(int(h)))
-	}
-	nid := C._goboringcrypto_EVP_MD_type(md)
-	var out []byte
-	var outLen C.uint
-	if priv.withKey(func(key *C.GO_RSA) C.int {
-		out = make([]byte, C._goboringcrypto_RSA_size(key))
-		return C._goboringcrypto_RSA_sign(nid, base(hashed), C.uint(len(hashed)),
-			base(out), &outLen, key)
-	}) == 0 {
-		return nil, fail("RSA_sign")
-	}
-	return out[:outLen], nil
-}
-
-func VerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
-	if h == 0 {
-		var out []byte
-		var outLen C.size_t
-		if pub.withKey(func(key *C.GO_RSA) C.int {
-			out = make([]byte, C._goboringcrypto_RSA_size(key))
-			return C._goboringcrypto_RSA_verify_raw(key, &outLen, base(out),
-				C.size_t(len(out)), base(sig), C.size_t(len(sig)), C.GO_RSA_PKCS1_PADDING)
-		}) == 0 {
-			return fail("RSA_verify")
-		}
-		if subtle.ConstantTimeCompare(hashed, out[:outLen]) != 1 {
-			return fail("RSA_verify")
-		}
-		return nil
-	}
-	md := cryptoHashToMD(h)
-	if md == nil {
-		return errors.New("crypto/rsa: unsupported hash function")
-	}
-	nid := C._goboringcrypto_EVP_MD_type(md)
-	if pub.withKey(func(key *C.GO_RSA) C.int {
-		return C._goboringcrypto_RSA_verify(nid, base(hashed), C.size_t(len(hashed)),
-			base(sig), C.size_t(len(sig)), key)
-	}) == 0 {
-		return fail("RSA_verify")
-	}
-	return nil
-}
diff --git a/src/crypto/internal/boring/sha.go b/src/crypto/internal/boring/sha.go
deleted file mode 100644
index 5ca158ca32..0000000000
--- a/src/crypto/internal/boring/sha.go
+++ /dev/null
@@ -1,480 +0,0 @@
-// Copyright 2017 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build linux,amd64
-// +build !android
-// +build !cmd_go_bootstrap
-// +build !msan
-
-package boring
-
-// #include "goboringcrypto.h"
-import "C"
-import (
-	"errors"
-	"hash"
-	"unsafe"
-)
-
-// NewSHA1 returns a new SHA1 hash.
-func NewSHA1() hash.Hash {
-	h := new(sha1Hash)
-	h.Reset()
-	return h
-}
-
-type sha1Hash struct {
-	ctx C.GO_SHA_CTX
-	out [20]byte
-}
-
-type sha1Ctx struct {
-	h      [5]uint32
-	nl, nh uint32
-	x      [64]byte
-	nx     uint32
-}
-
-func (h *sha1Hash) Reset()               { C._goboringcrypto_SHA1_Init(&h.ctx) }
-func (h *sha1Hash) Size() int            { return 20 }
-func (h *sha1Hash) BlockSize() int       { return 64 }
-func (h *sha1Hash) Sum(in []byte) []byte { return append(in, h.sum()...) }
-
-func (h *sha1Hash) Write(p []byte) (int, error) {
-	if len(p) > 0 && C._goboringcrypto_SHA1_Update(&h.ctx, unsafe.Pointer(&p[0]), C.size_t(len(p))) == 0 {
-		panic("boringcrypto: SHA1_Update failed")
-	}
-	return len(p), nil
-}
-
-func (h0 *sha1Hash) sum() []byte {
-	h := *h0 // make copy so future Write+Sum is valid
-	if C._goboringcrypto_SHA1_Final((*C.uint8_t)(unsafe.Pointer(&h.out[0])), &h.ctx) == 0 {
-		panic("boringcrypto: SHA1_Final failed")
-	}
-	return h.out[:]
-}
-
-const (
-	sha1Magic         = "sha\x01"
-	sha1MarshaledSize = len(sha1Magic) + 5*4 + 64 + 8
-)
-
-func (h *sha1Hash) MarshalBinary() ([]byte, error) {
-	d := (*sha1Ctx)(unsafe.Pointer(&h.ctx))
-	b := make([]byte, 0, sha1MarshaledSize)
-	b = append(b, sha1Magic...)
-	b = appendUint32(b, d.h[0])
-	b = appendUint32(b, d.h[1])
-	b = appendUint32(b, d.h[2])
-	b = appendUint32(b, d.h[3])
-	b = appendUint32(b, d.h[4])
-	b = append(b, d.x[:d.nx]...)
-	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
-	b = appendUint64(b, uint64(d.nl)>>3|uint64(d.nh)<<29)
-	return b, nil
-}
-
-func (h *sha1Hash) UnmarshalBinary(b []byte) error {
-	if len(b) < len(sha1Magic) || string(b[:len(sha1Magic)]) != sha1Magic {
-		return errors.New("crypto/sha1: invalid hash state identifier")
-	}
-	if len(b) != sha1MarshaledSize {
-		return errors.New("crypto/sha1: invalid hash state size")
-	}
-	d := (*sha1Ctx)(unsafe.Pointer(&h.ctx))
-	b = b[len(sha1Magic):]
-	b, d.h[0] = consumeUint32(b)
-	b, d.h[1] = consumeUint32(b)
-	b, d.h[2] = consumeUint32(b)
-	b, d.h[3] = consumeUint32(b)
-	b, d.h[4] = consumeUint32(b)
-	b = b[copy(d.x[:], b):]
-	b, n := consumeUint64(b)
-	d.nl = uint32(n << 3)
-	d.nh = uint32(n >> 29)
-	d.nx = uint32(n) % 64
-	return nil
-}
-
-// NewSHA224 returns a new SHA224 hash.
-func NewSHA224() hash.Hash {
-	h := new(sha224Hash)
-	h.Reset()
-	return h
-}
-
-type sha224Hash struct {
-	ctx C.GO_SHA256_CTX
-	out [224 / 8]byte
-}
-
-func (h *sha224Hash) Reset()               { C._goboringcrypto_SHA224_Init(&h.ctx) }
-func (h *sha224Hash) Size() int            { return 224 / 8 }
-func (h *sha224Hash) BlockSize() int       { return 64 }
-func (h *sha224Hash) Sum(in []byte) []byte { return append(in, h.sum()...) }
-
-func (h *sha224Hash) Write(p []byte) (int, error) {
-	if len(p) > 0 && C._goboringcrypto_SHA224_Update(&h.ctx, unsafe.Pointer(&p[0]), C.size_t(len(p))) == 0 {
-		panic("boringcrypto: SHA224_Update failed")
-	}
-	return len(p), nil
-}
-
-func (h0 *sha224Hash) sum() []byte {
-	h := *h0 // make copy so future Write+Sum is valid
-	if C._goboringcrypto_SHA224_Final((*C.uint8_t)(unsafe.Pointer(&h.out[0])), &h.ctx) == 0 {
-		panic("boringcrypto: SHA224_Final failed")
-	}
-	return h.out[:]
-}
-
-// NewSHA256 returns a new SHA256 hash.
-func NewSHA256() hash.Hash {
-	h := new(sha256Hash)
-	h.Reset()
-	return h
-}
-
-type sha256Hash struct {
-	ctx C.GO_SHA256_CTX
-	out [256 / 8]byte
-}
-
-func (h *sha256Hash) Reset()               { C._goboringcrypto_SHA256_Init(&h.ctx) }
-func (h *sha256Hash) Size() int            { return 256 / 8 }
-func (h *sha256Hash) BlockSize() int       { return 64 }
-func (h *sha256Hash) Sum(in []byte) []byte { return append(in, h.sum()...) }
-
-func (h *sha256Hash) Write(p []byte) (int, error) {
-	if len(p) > 0 && C._goboringcrypto_SHA256_Update(&h.ctx, unsafe.Pointer(&p[0]), C.size_t(len(p))) == 0 {
-		panic("boringcrypto: SHA256_Update failed")
-	}
-	return len(p), nil
-}
-
-func (h0 *sha256Hash) sum() []byte {
-	h := *h0 // make copy so future Write+Sum is valid
-	if C._goboringcrypto_SHA256_Final((*C.uint8_t)(unsafe.Pointer(&h.out[0])), &h.ctx) == 0 {
-		panic("boringcrypto: SHA256_Final failed")
-	}
-	return h.out[:]
-}
-
-const (
-	magic224         = "sha\x02"
-	magic256         = "sha\x03"
-	marshaledSize256 = len(magic256) + 8*4 + 64 + 8
-)
-
-type sha256Ctx struct {
-	h      [8]uint32
-	nl, nh uint32
-	x      [64]byte
-	nx     uint32
-}
-
-func (h *sha224Hash) MarshalBinary() ([]byte, error) {
-	d := (*sha256Ctx)(unsafe.Pointer(&h.ctx))
-	b := make([]byte, 0, marshaledSize256)
-	b = append(b, magic224...)
-	b = appendUint32(b, d.h[0])
-	b = appendUint32(b, d.h[1])
-	b = appendUint32(b, d.h[2])
-	b = appendUint32(b, d.h[3])
-	b = appendUint32(b, d.h[4])
-	b = appendUint32(b, d.h[5])
-	b = appendUint32(b, d.h[6])
-	b = appendUint32(b, d.h[7])
-	b = append(b, d.x[:d.nx]...)
-	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
-	b = appendUint64(b, uint64(d.nl)>>3|uint64(d.nh)<<29)
-	return b, nil
-}
-
-func (h *sha256Hash) MarshalBinary() ([]byte, error) {
-	d := (*sha256Ctx)(unsafe.Pointer(&h.ctx))
-	b := make([]byte, 0, marshaledSize256)
-	b = append(b, magic256...)
-	b = appendUint32(b, d.h[0])
-	b = appendUint32(b, d.h[1])
-	b = appendUint32(b, d.h[2])
-	b = appendUint32(b, d.h[3])
-	b = appendUint32(b, d.h[4])
-	b = appendUint32(b, d.h[5])
-	b = appendUint32(b, d.h[6])
-	b = appendUint32(b, d.h[7])
-	b = append(b, d.x[:d.nx]...)
-	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
-	b = appendUint64(b, uint64(d.nl)>>3|uint64(d.nh)<<29)
-	return b, nil
-}
-
-func (h *sha224Hash) UnmarshalBinary(b []byte) error {
-	if len(b) < len(magic224) || string(b[:len(magic224)]) != magic224 {
-		return errors.New("crypto/sha256: invalid hash state identifier")
-	}
-	if len(b) != marshaledSize256 {
-		return errors.New("crypto/sha256: invalid hash state size")
-	}
-	d := (*sha256Ctx)(unsafe.Pointer(&h.ctx))
-	b = b[len(magic224):]
-	b, d.h[0] = consumeUint32(b)
-	b, d.h[1] = consumeUint32(b)
-	b, d.h[2] = consumeUint32(b)
-	b, d.h[3] = consumeUint32(b)
-	b, d.h[4] = consumeUint32(b)
-	b, d.h[5] = consumeUint32(b)
-	b, d.h[6] = consumeUint32(b)
-	b, d.h[7] = consumeUint32(b)
-	b = b[copy(d.x[:], b):]
-	b, n := consumeUint64(b)
-	d.nl = uint32(n << 3)
-	d.nh = uint32(n >> 29)
-	d.nx = uint32(n) % 64
-	return nil
-}
-
-func (h *sha256Hash) UnmarshalBinary(b []byte) error {
-	if len(b) < len(magic256) || string(b[:len(magic256)]) != magic256 {
-		return errors.New("crypto/sha256: invalid hash state identifier")
-	}
-	if len(b) != marshaledSize256 {
-		return errors.New("crypto/sha256: invalid hash state size")
-	}
-	d := (*sha256Ctx)(unsafe.Pointer(&h.ctx))
-	b = b[len(magic256):]
-	b, d.h[0] = consumeUint32(b)
-	b, d.h[1] = consumeUint32(b)
-	b, d.h[2] = consumeUint32(b)
-	b, d.h[3] = consumeUint32(b)
-	b, d.h[4] = consumeUint32(b)
-	b, d.h[5] = consumeUint32(b)
-	b, d.h[6] = consumeUint32(b)
-	b, d.h[7] = consumeUint32(b)
-	b = b[copy(d.x[:], b):]
-	b, n := consumeUint64(b)
-	d.nl = uint32(n << 3)
-	d.nh = uint32(n >> 29)
-	d.nx = uint32(n) % 64
-	return nil
-}
-
-// NewSHA384 returns a new SHA384 hash.
-func NewSHA384() hash.Hash {
-	h := new(sha384Hash)
-	h.Reset()
-	return h
-}
-
-type sha384Hash struct {
-	ctx C.GO_SHA512_CTX
-	out [384 / 8]byte
-}
-
-func (h *sha384Hash) Reset()               { C._goboringcrypto_SHA384_Init(&h.ctx) }
-func (h *sha384Hash) Size() int            { return 384 / 8 }
-func (h *sha384Hash) BlockSize() int       { return 128 }
-func (h *sha384Hash) Sum(in []byte) []byte { return append(in, h.sum()...) }
-
-func (h *sha384Hash) Write(p []byte) (int, error) {
-	if len(p) > 0 && C._goboringcrypto_SHA384_Update(&h.ctx, unsafe.Pointer(&p[0]), C.size_t(len(p))) == 0 {
-		panic("boringcrypto: SHA384_Update failed")
-	}
-	return len(p), nil
-}
-
-func (h0 *sha384Hash) sum() []byte {
-	h := *h0 // make copy so future Write+Sum is valid
-	if C._goboringcrypto_SHA384_Final((*C.uint8_t)(unsafe.Pointer(&h.out[0])), &h.ctx) == 0 {
-		panic("boringcrypto: SHA384_Final failed")
-	}
-	return h.out[:]
-}
-
-// NewSHA512 returns a new SHA512 hash.
-func NewSHA512() hash.Hash {
-	h := new(sha512Hash)
-	h.Reset()
-	return h
-}
-
-type sha512Hash struct {
-	ctx C.GO_SHA512_CTX
-	out [512 / 8]byte
-}
-
-func (h *sha512Hash) Reset()               { C._goboringcrypto_SHA512_Init(&h.ctx) }
-func (h *sha512Hash) Size() int            { return 512 / 8 }
-func (h *sha512Hash) BlockSize() int       { return 128 }
-func (h *sha512Hash) Sum(in []byte) []byte { return append(in, h.sum()...) }
-
-func (h *sha512Hash) Write(p []byte) (int, error) {
-	if len(p) > 0 && C._goboringcrypto_SHA512_Update(&h.ctx, unsafe.Pointer(&p[0]), C.size_t(len(p))) == 0 {
-		panic("boringcrypto: SHA512_Update failed")
-	}
-	return len(p), nil
-}
-
-func (h0 *sha512Hash) sum() []byte {
-	h := *h0 // make copy so future Write+Sum is valid
-	if C._goboringcrypto_SHA512_Final((*C.uint8_t)(unsafe.Pointer(&h.out[0])), &h.ctx) == 0 {
-		panic("boringcrypto: SHA512_Final failed")
-	}
-	return h.out[:]
-}
-
-type sha512Ctx struct {
-	h      [8]uint64
-	nl, nh uint64
-	x      [128]byte
-	nx     uint32
-}
-
-const (
-	magic384         = "sha\x04"
-	magic512_224     = "sha\x05"
-	magic512_256     = "sha\x06"
-	magic512         = "sha\x07"
-	marshaledSize512 = len(magic512) + 8*8 + 128 + 8
-)
-
-var zero [128]byte
-
-func (h *sha384Hash) MarshalBinary() ([]byte, error) {
-	d := (*sha512Ctx)(unsafe.Pointer(&h.ctx))
-	b := make([]byte, 0, marshaledSize512)
-	b = append(b, magic384...)
-	b = appendUint64(b, d.h[0])
-	b = appendUint64(b, d.h[1])
-	b = appendUint64(b, d.h[2])
-	b = appendUint64(b, d.h[3])
-	b = appendUint64(b, d.h[4])
-	b = appendUint64(b, d.h[5])
-	b = appendUint64(b, d.h[6])
-	b = appendUint64(b, d.h[7])
-	b = append(b, d.x[:d.nx]...)
-	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
-	b = appendUint64(b, d.nl>>3|d.nh<<61)
-	return b, nil
-}
-
-func (h *sha512Hash) MarshalBinary() ([]byte, error) {
-	d := (*sha512Ctx)(unsafe.Pointer(&h.ctx))
-	b := make([]byte, 0, marshaledSize512)
-	b = append(b, magic512...)
-	b = appendUint64(b, d.h[0])
-	b = appendUint64(b, d.h[1])
-	b = appendUint64(b, d.h[2])
-	b = appendUint64(b, d.h[3])
-	b = appendUint64(b, d.h[4])
-	b = appendUint64(b, d.h[5])
-	b = appendUint64(b, d.h[6])
-	b = appendUint64(b, d.h[7])
-	b = append(b, d.x[:d.nx]...)
-	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
-	b = appendUint64(b, d.nl>>3|d.nh<<61)
-	return b, nil
-}
-
-func (h *sha384Hash) UnmarshalBinary(b []byte) error {
-	if len(b) < len(magic512) {
-		return errors.New("crypto/sha512: invalid hash state identifier")
-	}
-	if string(b[:len(magic384)]) != magic384 {
-		return errors.New("crypto/sha512: invalid hash state identifier")
-	}
-	if len(b) != marshaledSize512 {
-		return errors.New("crypto/sha512: invalid hash state size")
-	}
-	d := (*sha512Ctx)(unsafe.Pointer(&h.ctx))
-	b = b[len(magic512):]
-	b, d.h[0] = consumeUint64(b)
-	b, d.h[1] = consumeUint64(b)
-	b, d.h[2] = consumeUint64(b)
-	b, d.h[3] = consumeUint64(b)
-	b, d.h[4] = consumeUint64(b)
-	b, d.h[5] = consumeUint64(b)
-	b, d.h[6] = consumeUint64(b)
-	b, d.h[7] = consumeUint64(b)
-	b = b[copy(d.x[:], b):]
-	b, n := consumeUint64(b)
-	d.nl = n << 3
-	d.nh = n >> 61
-	d.nx = uint32(n) % 128
-	return nil
-}
-
-func (h *sha512Hash) UnmarshalBinary(b []byte) error {
-	if len(b) < len(magic512) {
-		return errors.New("crypto/sha512: invalid hash state identifier")
-	}
-	if string(b[:len(magic512)]) != magic512 {
-		return errors.New("crypto/sha512: invalid hash state identifier")
-	}
-	if len(b) != marshaledSize512 {
-		return errors.New("crypto/sha512: invalid hash state size")
-	}
-	d := (*sha512Ctx)(unsafe.Pointer(&h.ctx))
-	b = b[len(magic512):]
-	b, d.h[0] = consumeUint64(b)
-	b, d.h[1] = consumeUint64(b)
-	b, d.h[2] = consumeUint64(b)
-	b, d.h[3] = consumeUint64(b)
-	b, d.h[4] = consumeUint64(b)
-	b, d.h[5] = consumeUint64(b)
-	b, d.h[6] = consumeUint64(b)
-	b, d.h[7] = consumeUint64(b)
-	b = b[copy(d.x[:], b):]
-	b, n := consumeUint64(b)
-	d.nl = n << 3
-	d.nh = n >> 61
-	d.nx = uint32(n) % 128
-	return nil
-}
-
-func appendUint64(b []byte, x uint64) []byte {
-	var a [8]byte
-	putUint64(a[:], x)
-	return append(b, a[:]...)
-}
-
-func appendUint32(b []byte, x uint32) []byte {
-	var a [4]byte
-	putUint32(a[:], x)
-	return append(b, a[:]...)
-}
-
-func consumeUint64(b []byte) ([]byte, uint64) {
-	_ = b[7]
-	x := uint64(b[7]) | uint64(b[6])<<8 | uint64(b[5])<<16 | uint64(b[4])<<24 |
-		uint64(b[3])<<32 | uint64(b[2])<<40 | uint64(b[1])<<48 | uint64(b[0])<<56
-	return b[8:], x
-}
-
-func consumeUint32(b []byte) ([]byte, uint32) {
-	_ = b[3]
-	x := uint32(b[3]) | uint32(b[2])<<8 | uint32(b[1])<<16 | uint32(b[0])<<24
-	return b[4:], x
-}
-
-func putUint64(x []byte, s uint64) {
-	_ = x[7]
-	x[0] = byte(s >> 56)
-	x[1] = byte(s >> 48)
-	x[2] = byte(s >> 40)
-	x[3] = byte(s >> 32)
-	x[4] = byte(s >> 24)
-	x[5] = byte(s >> 16)
-	x[6] = byte(s >> 8)
-	x[7] = byte(s)
-}
-
-func putUint32(x []byte, s uint32) {
-	_ = x[3]
-	x[0] = byte(s >> 24)
-	x[1] = byte(s >> 16)
-	x[2] = byte(s >> 8)
-	x[3] = byte(s)
-}
diff --git a/src/crypto/rand/rand_unix.go b/src/crypto/rand/rand_unix.go
index 526e54a5c9..cc6d83f533 100644
--- a/src/crypto/rand/rand_unix.go
+++ b/src/crypto/rand/rand_unix.go
@@ -23,7 +23,7 @@ import (
 	"time"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 const urandomDevice = "/dev/urandom"
 
@@ -31,7 +31,7 @@ const urandomDevice = "/dev/urandom"
 // This is sufficient on Linux, OS X, and FreeBSD.
 
 func init() {
-	if boring.Enabled {
+	if boring.Enabled() {
 		Reader = boring.RandReader
 		return
 	}
diff --git a/src/crypto/rsa/boring.go b/src/crypto/rsa/boring.go
index 0f362a2f16..856bc26aea 100644
--- a/src/crypto/rsa/boring.go
+++ b/src/crypto/rsa/boring.go
@@ -5,7 +5,7 @@
 package rsa
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"math/big"
 	"sync/atomic"
 	"unsafe"
diff --git a/src/crypto/rsa/pkcs1v15.go b/src/crypto/rsa/pkcs1v15.go
index 213ddb4add..0b5f093d52 100644
--- a/src/crypto/rsa/pkcs1v15.go
+++ b/src/crypto/rsa/pkcs1v15.go
@@ -14,7 +14,7 @@ import (
 	"crypto/internal/randutil"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // This file implements encryption and decryption using PKCS #1 v1.5 padding.
 
@@ -49,7 +49,7 @@ func EncryptPKCS1v15(random io.Reader, pub *PublicKey, msg []byte) ([]byte, erro
 		return nil, ErrMessageTooLong
 	}
 
-	if boring.Enabled && random == boring.RandReader {
+	if boring.Enabled() && random == boring.RandReader {
 		bkey, err := boringPublicKey(pub)
 		if err != nil {
 			return nil, err
@@ -69,7 +69,7 @@ func EncryptPKCS1v15(random io.Reader, pub *PublicKey, msg []byte) ([]byte, erro
 	em[len(em)-len(msg)-1] = 0
 	copy(mm, msg)
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		var bkey *boring.PublicKeyRSA
 		bkey, err = boringPublicKey(pub)
 		if err != nil {
@@ -96,7 +96,7 @@ func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) ([]byt
 		return nil, err
 	}
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -175,7 +175,7 @@ func decryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (valid
 		return
 	}
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		var bkey *boring.PrivateKeyRSA
 		bkey, err = boringPrivateKey(priv)
 		if err != nil {
@@ -285,12 +285,12 @@ func SignPKCS1v15(random io.Reader, priv *PrivateKey, hash crypto.Hash, hashed [
 		return nil, ErrMessageTooLong
 	}
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
 		}
-		return boring.SignRSAPKCS1v15(bkey, hash, hashed)
+		return boring.SignRSAPKCS1v15(bkey, hash, hashed, true)
 	}
 
 	// EM = 0x00 || 0x01 || PS || 0x00 || T
@@ -317,12 +317,12 @@ func SignPKCS1v15(random io.Reader, priv *PrivateKey, hash crypto.Hash, hashed [
 // returning a nil error. If hash is zero then hashed is used directly. This
 // isn't advisable except for interoperability.
 func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error {
-	if boring.Enabled {
+	if boring.Enabled() {
 		bkey, err := boringPublicKey(pub)
 		if err != nil {
 			return err
 		}
-		if err := boring.VerifyRSAPKCS1v15(bkey, hash, hashed, sig); err != nil {
+		if err := boring.VerifyRSAPKCS1v15(bkey, hash, hashed, sig, hash != crypto.Hash(0)); err != nil {
 			return ErrVerification
 		}
 		return nil
diff --git a/src/crypto/rsa/pss.go b/src/crypto/rsa/pss.go
index 16ebc0e6a7..f99f296570 100644
--- a/src/crypto/rsa/pss.go
+++ b/src/crypto/rsa/pss.go
@@ -15,7 +15,7 @@ import (
 	"math/big"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // Per RFC 8017, Section 9.1
 //
@@ -216,7 +216,7 @@ func signPSSWithSalt(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed,
 		return nil, err
 	}
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -291,7 +291,7 @@ func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, digest []byte,
 		saltLength = hash.Size()
 	}
 
-	if boring.Enabled && rand == boring.RandReader {
+	if boring.Enabled() && rand == boring.RandReader {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -313,7 +313,7 @@ func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, digest []byte,
 // argument may be nil, in which case sensible defaults are used. opts.Hash is
 // ignored.
 func VerifyPSS(pub *PublicKey, hash crypto.Hash, digest []byte, sig []byte, opts *PSSOptions) error {
-	if boring.Enabled {
+	if boring.Enabled() {
 		bkey, err := boringPublicKey(pub)
 		if err != nil {
 			return err
diff --git a/src/crypto/rsa/rsa.go b/src/crypto/rsa/rsa.go
index eef967f826..f9b641cff5 100644
--- a/src/crypto/rsa/rsa.go
+++ b/src/crypto/rsa/rsa.go
@@ -36,7 +36,7 @@ import (
 )
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"unsafe"
 )
 
@@ -265,7 +265,7 @@ func GenerateKey(random io.Reader, bits int) (*PrivateKey, error) {
 func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*PrivateKey, error) {
 	randutil.MaybeReadByte(random)
 
-	if boring.Enabled && random == boring.RandReader && nprimes == 2 && (bits == 2048 || bits == 3072) {
+	if boring.Enabled() && random == boring.RandReader && nprimes == 2 && (bits == 2048 || bits == 3072) {
 		N, E, D, P, Q, Dp, Dq, Qinv, err := boring.GenerateKeyRSA(bits)
 		if err != nil {
 			return nil, err
@@ -453,7 +453,7 @@ func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, l
 		return nil, ErrMessageTooLong
 	}
 
-	if boring.Enabled && random == boring.RandReader {
+	if boring.Enabled() && random == boring.RandReader {
 		bkey, err := boringPublicKey(pub)
 		if err != nil {
 			return nil, err
@@ -482,7 +482,7 @@ func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, l
 	mgf1XOR(db, hash, seed)
 	mgf1XOR(seed, hash, db)
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		var bkey *boring.PublicKeyRSA
 		bkey, err = boringPublicKey(pub)
 		if err != nil {
@@ -660,7 +660,7 @@ func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext
 		return nil, ErrDecryption
 	}
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
diff --git a/src/crypto/rsa/rsa_test.go b/src/crypto/rsa/rsa_test.go
index 766d9a954f..608110dafe 100644
--- a/src/crypto/rsa/rsa_test.go
+++ b/src/crypto/rsa/rsa_test.go
@@ -15,7 +15,7 @@ import (
 	"testing"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 func TestKeyGeneration(t *testing.T) {
 	for _, size := range []int{128, 1024, 2048, 3072} {
@@ -114,7 +114,7 @@ func testKeyBasics(t *testing.T, priv *PrivateKey) {
 		t.Errorf("private exponent too large")
 	}
 
-	if boring.Enabled {
+	if boring.Enabled() {
 		// Cannot call encrypt/decrypt directly. Test via PKCS1v15.
 		msg := []byte("hi!")
 		enc, err := EncryptPKCS1v15(rand.Reader, &priv.PublicKey, msg)
@@ -181,7 +181,7 @@ func init() {
 }
 
 func BenchmarkRSA2048Decrypt(b *testing.B) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		b.Skip("no raw decrypt in BoringCrypto")
 	}
 
@@ -207,7 +207,7 @@ func BenchmarkRSA2048Sign(b *testing.B) {
 }
 
 func Benchmark3PrimeRSA2048Decrypt(b *testing.B) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		b.Skip("no raw decrypt in BoringCrypto")
 	}
 
diff --git a/src/crypto/sha1/boring.go b/src/crypto/sha1/boring.go
index 44c26092ee..491134a894 100644
--- a/src/crypto/sha1/boring.go
+++ b/src/crypto/sha1/boring.go
@@ -11,11 +11,11 @@
 package sha1
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"hash"
 )
 
-const boringEnabled = boring.Enabled
+var boringEnabled = boring.Enabled()
 
 func boringNewSHA1() hash.Hash { return boring.NewSHA1() }
 
diff --git a/src/crypto/sha1/notboring.go b/src/crypto/sha1/notboring.go
index 9726fcd268..ff7cb02060 100644
--- a/src/crypto/sha1/notboring.go
+++ b/src/crypto/sha1/notboring.go
@@ -10,7 +10,7 @@ import (
 	"hash"
 )
 
-const boringEnabled = false
+var boringEnabled = false
 
 func boringNewSHA1() hash.Hash { panic("boringcrypto: not available") }
 
diff --git a/src/crypto/sha1/sha1_test.go b/src/crypto/sha1/sha1_test.go
index e369c3b7f4..2c73184fda 100644
--- a/src/crypto/sha1/sha1_test.go
+++ b/src/crypto/sha1/sha1_test.go
@@ -16,7 +16,7 @@ import (
 	"testing"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 type sha1Test struct {
 	out       string
@@ -79,7 +79,7 @@ func TestGolden(t *testing.T) {
 				io.WriteString(c, g.in[len(g.in)/2:])
 				sum = c.Sum(nil)
 			case 3:
-				if boring.Enabled {
+				if boring.Enabled() {
 					continue
 				}
 				io.WriteString(c, g.in[0:len(g.in)/2])
@@ -146,7 +146,7 @@ func TestBlockSize(t *testing.T) {
 
 // Tests that blockGeneric (pure Go) and block (in assembly for some architectures) match.
 func TestBlockGeneric(t *testing.T) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		t.Skip("BoringCrypto doesn't expose digest")
 	}
 	for i := 1; i < 30; i++ { // arbitrary factor
diff --git a/src/crypto/sha256/sha256.go b/src/crypto/sha256/sha256.go
index 8b54a427d7..6bfbe5dcf7 100644
--- a/src/crypto/sha256/sha256.go
+++ b/src/crypto/sha256/sha256.go
@@ -13,7 +13,7 @@ import (
 	"hash"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 func init() {
 	crypto.RegisterHash(crypto.SHA224, New224)
@@ -161,7 +161,7 @@ func (d *digest) Reset() {
 // encoding.BinaryUnmarshaler to marshal and unmarshal the internal
 // state of the hash.
 func New() hash.Hash {
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.NewSHA256()
 	}
 	d := new(digest)
@@ -171,7 +171,7 @@ func New() hash.Hash {
 
 // New224 returns a new hash.Hash computing the SHA224 checksum.
 func New224() hash.Hash {
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.NewSHA224()
 	}
 	d := new(digest)
@@ -262,7 +262,7 @@ func (d *digest) checkSum() [Size]byte {
 
 // Sum256 returns the SHA256 checksum of the data.
 func Sum256(data []byte) [Size]byte {
-	if boring.Enabled {
+	if boring.Enabled() {
 		h := New()
 		h.Write(data)
 		var ret [Size]byte
@@ -277,7 +277,7 @@ func Sum256(data []byte) [Size]byte {
 
 // Sum224 returns the SHA224 checksum of the data.
 func Sum224(data []byte) (sum224 [Size224]byte) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		h := New224()
 		h.Write(data)
 		var ret [Size224]byte
diff --git a/src/crypto/sha256/sha256_test.go b/src/crypto/sha256/sha256_test.go
index 91a4edde04..035daf1c05 100644
--- a/src/crypto/sha256/sha256_test.go
+++ b/src/crypto/sha256/sha256_test.go
@@ -16,7 +16,7 @@ import (
 	"testing"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 type sha256Test struct {
 	out       string
@@ -218,7 +218,7 @@ func TestBlockSize(t *testing.T) {
 
 // Tests that blockGeneric (pure Go) and block (in assembly for some architectures) match.
 func TestBlockGeneric(t *testing.T) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		t.Skip("BoringCrypto doesn't expose digest")
 	}
 	gen, asm := New().(*digest), New().(*digest)
diff --git a/src/crypto/sha512/sha512.go b/src/crypto/sha512/sha512.go
index 1a2cef317c..69974e17f8 100644
--- a/src/crypto/sha512/sha512.go
+++ b/src/crypto/sha512/sha512.go
@@ -17,7 +17,7 @@ import (
 	"hash"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 func init() {
 	crypto.RegisterHash(crypto.SHA384, New384)
@@ -213,7 +213,7 @@ func consumeUint64(b []byte) ([]byte, uint64) {
 
 // New returns a new hash.Hash computing the SHA-512 checksum.
 func New() hash.Hash {
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.NewSHA512()
 	}
 	d := &digest{function: crypto.SHA512}
@@ -237,7 +237,7 @@ func New512_256() hash.Hash {
 
 // New384 returns a new hash.Hash computing the SHA-384 checksum.
 func New384() hash.Hash {
-	if boring.Enabled {
+	if boring.Enabled() {
 		return boring.NewSHA384()
 	}
 	d := &digest{function: crypto.SHA384}
@@ -344,7 +344,7 @@ func (d *digest) checkSum() [Size]byte {
 
 // Sum512 returns the SHA512 checksum of the data.
 func Sum512(data []byte) [Size]byte {
-	if boring.Enabled {
+	if boring.Enabled() {
 		h := New()
 		h.Write(data)
 		var ret [Size]byte
@@ -359,7 +359,7 @@ func Sum512(data []byte) [Size]byte {
 
 // Sum384 returns the SHA384 checksum of the data.
 func Sum384(data []byte) (sum384 [Size384]byte) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		h := New384()
 		h.Write(data)
 		var ret [Size384]byte
diff --git a/src/crypto/sha512/sha512_test.go b/src/crypto/sha512/sha512_test.go
index 966cd51d15..9f39a556ac 100644
--- a/src/crypto/sha512/sha512_test.go
+++ b/src/crypto/sha512/sha512_test.go
@@ -17,7 +17,7 @@ import (
 	"testing"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 type sha512Test struct {
 	out       string
@@ -824,7 +824,7 @@ func TestBlockSize(t *testing.T) {
 
 // Tests that blockGeneric (pure Go) and block (in assembly for some architectures) match.
 func TestBlockGeneric(t *testing.T) {
-	if boring.Enabled {
+	if boring.Enabled() {
 		t.Skip("BoringCrypto doesn't expose digest")
 	}
 	gen, asm := New().(*digest), New().(*digest)
diff --git a/src/crypto/tls/boring.go b/src/crypto/tls/boring.go
index 09f71c1691..7940cee010 100644
--- a/src/crypto/tls/boring.go
+++ b/src/crypto/tls/boring.go
@@ -11,6 +11,14 @@ import (
 	"crypto/x509"
 )
 
+import boring "crypto/internal/backend"
+
+func init() {
+	if boring.Enabled()() {
+		fipstls.Force()
+	}
+}
+
 // needFIPS returns fipstls.Required(); it avoids a new import in common.go.
 func needFIPS() bool {
 	return fipstls.Required()
@@ -90,7 +98,7 @@ func isBoringCertificate(c *x509.Certificate) bool {
 	default:
 		return false
 	case *rsa.PublicKey:
-		if size := k.N.BitLen(); size != 2048 && size != 3072 {
+		if size := k.N.BitLen(); size < 2048 || (size%512) != 0 {
 			return false
 		}
 	case *ecdsa.PublicKey:
diff --git a/src/crypto/tls/cipher_suites.go b/src/crypto/tls/cipher_suites.go
index e07d742bd3..b45ec04b04 100644
--- a/src/crypto/tls/cipher_suites.go
+++ b/src/crypto/tls/cipher_suites.go
@@ -4,7 +4,7 @@
 
 package tls
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 import (
 	"crypto"
@@ -427,7 +427,7 @@ func macSHA1(key []byte) hash.Hash {
 	h := sha1.New
 	// The BoringCrypto SHA1 does not have a constant-time
 	// checksum function, so don't try to use it.
-	if !boring.Enabled {
+	if !boring.Enabled() {
 		h = newConstantTimeHash(h)
 	}
 	return hmac.New(h, key)
diff --git a/src/go.mod b/src/go.mod
index af435fa335..9b9434c689 100644
--- a/src/go.mod
+++ b/src/go.mod
@@ -11,3 +11,5 @@ require (
 	golang.org/x/sys v0.0.0-20210511113859-b0526f3d8744 // indirect
 	golang.org/x/text v0.3.7-0.20210503195748-5c7c50ebbd4f // indirect
 )
+
+require github.com/golang-fips/openssl-fips v0.0.0-20220505153334-362f46022010
diff --git a/src/go.sum b/src/go.sum
index 3e3fa7989f..49152fb74a 100644
--- a/src/go.sum
+++ b/src/go.sum
@@ -1,3 +1,5 @@
+github.com/golang-fips/openssl-fips v0.0.0-20220505153334-362f46022010 h1:df6Fm3lRHuvH+OdR2wB8Wz7zzJ6+K5lxYqMUrK9za3Q=
+github.com/golang-fips/openssl-fips v0.0.0-20220505153334-362f46022010/go.mod h1:V2IU8imz/VkScnIbTOrdYsZ5R88ZFypCE0LzhRJ3HsI=
 golang.org/x/crypto v0.0.0-20211215165025-cf75a172585e h1:1SzTfNOXwIS2oWiMF+6qu0OUDKb0dauo6MoDUQyu+yU=
 golang.org/x/crypto v0.0.0-20211215165025-cf75a172585e/go.mod h1:P+XmwS30IXTQdn5tA2iutPOUgjI07+tq3H3K9MVA1s8=
 golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
diff --git a/src/go/build/deps_test.go b/src/go/build/deps_test.go
index c399946435..a40270f4cc 100644
--- a/src/go/build/deps_test.go
+++ b/src/go/build/deps_test.go
@@ -31,7 +31,7 @@ import (
 //
 // The general syntax of a rule is:
 //
-//		a, b < c, d;
+//	a, b < c, d;
 //
 // which means c and d come after a and b in the partial order
 // (that is, c and d can import a and b),
@@ -39,12 +39,12 @@ import (
 //
 // The rules can chain together, as in:
 //
-//		e < f, g < h;
+//	e < f, g < h;
 //
 // which is equivalent to
 //
-//		e < f, g;
-//		f, g < h;
+//	e < f, g;
+//	f, g < h;
 //
 // Except for the special bottom element "NONE", each name
 // must appear exactly once on the right-hand side of a rule.
@@ -56,7 +56,7 @@ import (
 //
 // Negative assertions double-check the partial order:
 //
-//		i !< j
+//	i !< j
 //
 // means that it must NOT be the case that i < j.
 // Negative assertions may appear anywhere in the rules,
@@ -66,7 +66,6 @@ import (
 //
 // All-caps names are pseudo-names for specific points
 // in the dependency lattice.
-//
 var depsRules = `
 	# No dependencies allowed for any of these packages.
 	NONE
@@ -400,7 +399,13 @@ var depsRules = `
 	< crypto/ed25519/internal/edwards25519
 	< crypto/cipher
 	< encoding/asn1
-	< crypto/internal/boring
+	< CRYPTO;
+	
+	CRYPTO < crypto/internal/boring;
+	
+	CRYPTO
+	< github.com/golang-fips/openssl-fips/openssl
+	< crypto/internal/backend
 	< crypto/aes, crypto/des, crypto/hmac, crypto/md5, crypto/rc4,
 	  crypto/sha1, crypto/sha256, crypto/sha512
 	< crypto/rand
@@ -430,7 +435,7 @@ var depsRules = `
 	crypto/internal/boring/sig, crypto/internal/boring/fipstls
 	< crypto/tls/fipsonly;
 
-	crypto/internal/boring
+	crypto/internal/backend
 	< crypto/boring;
 
 	# crypto-aware packages
@@ -623,7 +628,7 @@ var buildIgnore = []byte("\n// +build ignore")
 
 func findImports(pkg string) ([]string, error) {
 	vpkg := pkg
-	if strings.HasPrefix(pkg, "golang.org") {
+	if strings.HasPrefix(pkg, "golang.org") || strings.HasPrefix(pkg, "github.com") {
 		vpkg = "vendor/" + pkg
 	}
 	dir := filepath.Join(Default.GOROOT, "src", vpkg)
diff --git a/src/runtime/runtime_boring.go b/src/runtime/runtime_boring.go
index 5a98b20253..dc25cdcfd5 100644
--- a/src/runtime/runtime_boring.go
+++ b/src/runtime/runtime_boring.go
@@ -17,3 +17,8 @@ func boring_runtime_arg0() string {
 
 //go:linkname fipstls_runtime_arg0 crypto/internal/boring/fipstls.runtime_arg0
 func fipstls_runtime_arg0() string { return boring_runtime_arg0() }
+
+//go:linkname crypto_backend_runtime_arg0 crypto/internal/backend.runtime_arg0
+func crypto_backend_runtime_arg0() string {
+	return boring_runtime_arg0()
+}
\ No newline at end of file
diff --git a/src/vendor/modules.txt b/src/vendor/modules.txt
index a1b16d7b84..dec7a5bb88 100644
--- a/src/vendor/modules.txt
+++ b/src/vendor/modules.txt
@@ -1,3 +1,6 @@
+# github.com/golang-fips/openssl-fips v0.0.0-20220505153334-362f46022010
+## explicit; go 1.18
+github.com/golang-fips/openssl-fips/openssl
 # golang.org/x/crypto v0.0.0-20211215165025-cf75a172585e
 ## explicit; go 1.17
 golang.org/x/crypto/chacha20
