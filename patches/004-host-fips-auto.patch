diff --git i/src/cmd/go/internal/fips140/fips140.go w/src/cmd/go/internal/fips140/fips140.go
index 09e4141f99..7103c1a23e 100644
--- i/src/cmd/go/internal/fips140/fips140.go
+++ w/src/cmd/go/internal/fips140/fips140.go
@@ -166,10 +166,15 @@ var version string
 func initVersion() {
 	// For off and latest, use the local source tree.
 	v := cfg.GOFIPS140
-	if v == "off" || v == "" {
+	if v == "off" {
 		version = "off"
 		return
 	}
+	// When GOFIPS140 is not set, default to v1.0.0 certified snapshot.
+	// Runtime FIPS activation is controlled by GODEBUG=fips140=auto.
+	if v == "" {
+		v = "v1.0.0"
+	}
 	if v == "latest" {
 		version = "latest"
 		return
diff --git i/src/crypto/internal/backend/hostfips.go w/src/crypto/internal/backend/hostfips.go
index aa21cd4db9..e671cc1547 100644
--- i/src/crypto/internal/backend/hostfips.go
+++ w/src/crypto/internal/backend/hostfips.go
@@ -5,21 +5,9 @@
 package backend
 
 import (
-	"fmt"
-	"os"
+	"crypto/internal/fips140deps/hostfips"
 )
 
-func hostFIPSModeEnabled() bool {
-	// Look at /proc/sys/crypto/fips_enabled to see if FIPS mode is enabled.
-	// If it is, log an error and exit.
-	// If we run into an error reading that file because it doesn't exist, assume FIPS mode is not enabled.
-	data, err := os.ReadFile("/proc/sys/crypto/fips_enabled")
-	if err != nil {
-		if os.IsNotExist(err) {
-			return false
-		}
-		fmt.Fprintf(os.Stderr, "error reading /proc/sys/crypto/fips_enabled: %v\n", err)
-		os.Exit(1)
-	}
-	return len(data) > 0 && data[0] == '1'
+func HostFIPSModeEnabled() bool {
+	return hostfips.Enabled()
 }
diff --git i/src/crypto/internal/backend/openssl.go w/src/crypto/internal/backend/openssl.go
index 0cb9ad7c7e..6ec4453328 100644
--- i/src/crypto/internal/backend/openssl.go
+++ w/src/crypto/internal/backend/openssl.go
@@ -31,7 +31,7 @@ func init() {
 	var fips string
 	if v, ok := syscall.Getenv("GOLANG_FIPS"); ok {
 		fips = v
-	} else if hostFIPSModeEnabled() {
+	} else if HostFIPSModeEnabled() {
 		// System configuration can only force FIPS mode.
 		fips = "1"
 	}
diff --git i/src/crypto/internal/backend/strict_fips.go w/src/crypto/internal/backend/strict_fips.go
index cd5bd34b33..dd2888c78c 100644
--- i/src/crypto/internal/backend/strict_fips.go
+++ w/src/crypto/internal/backend/strict_fips.go
@@ -15,14 +15,14 @@ import (
 var isStrictFIPS bool = true
 
 func strictFIPSOpenSSLRuntimeCheck() {
-	if hostFIPSModeEnabled() && !Enabled() {
+	if HostFIPSModeEnabled() && !Enabled() {
 		fmt.Fprintln(os.Stderr, "FIPS mode is enabled, but the required OpenSSL backend is unavailable")
 		os.Exit(1)
 	}
 }
 
 func strictFIPSNonCompliantBinaryCheck() {
-	if hostFIPSModeEnabled() {
+	if HostFIPSModeEnabled() {
 		fmt.Fprintln(os.Stderr, "FIPS mode is enabled, but this binary is not compiled with FIPS compliant mode enabled")
 		os.Exit(1)
 	}
diff --git i/src/crypto/internal/fips140deps/godebug/godebug.go w/src/crypto/internal/fips140deps/godebug/godebug.go
index de50d61208..22bda7ad4b 100644
--- i/src/crypto/internal/fips140deps/godebug/godebug.go
+++ w/src/crypto/internal/fips140deps/godebug/godebug.go
@@ -5,6 +5,7 @@
 package godebug
 
 import (
+	"crypto/internal/fips140deps/hostfips"
 	"internal/godebug"
 )
 
@@ -19,5 +20,14 @@ func (s *Setting) Value() string {
 }
 
 func Value(name string) string {
-	return godebug.New(name).Value()
+	v := godebug.New(name).Value()
+	// When fips140=auto is set, check host FIPS mode and resolve to
+	// "on" if enabled, or "" (off) if not.
+	if name == "#fips140" && v == "auto" {
+		if hostfips.Enabled() {
+			return "on"
+		}
+		return ""
+	}
+	return v
 }
diff --git c/src/crypto/internal/fips140deps/hostfips/hostfips.go i/src/crypto/internal/fips140deps/hostfips/hostfips.go
new file mode 100644
index 0000000000..96d1c05709
--- /dev/null
+++ i/src/crypto/internal/fips140deps/hostfips/hostfips.go
@@ -0,0 +1,45 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package hostfips
+
+import (
+	"fmt"
+	"os"
+	"sync"
+)
+
+var (
+	enabled     bool
+	enabledOnce sync.Once
+)
+
+// Enabled returns true if the host system has FIPS mode enabled.
+// It checks /proc/sys/crypto/fips_enabled on Linux.
+// The result is cached after the first call.
+func Enabled() bool {
+	enabledOnce.Do(func() {
+		enabled = checkHostFIPS()
+	})
+	return enabled
+}
+
+func checkHostFIPS() bool {
+	// Test override for verifying code paths without a real FIPS-enabled host
+	if os.Getenv("GOLANG_NATIVE_HOSTFIPS_OVERRIDE") == "1" {
+		return true
+	}
+
+	// Look at /proc/sys/crypto/fips_enabled to see if FIPS mode is enabled.
+	// If we run into an error reading that file because it doesn't exist, assume FIPS mode is not enabled.
+	data, err := os.ReadFile("/proc/sys/crypto/fips_enabled")
+	if err != nil {
+		if os.IsNotExist(err) {
+			return false
+		}
+		fmt.Fprintf(os.Stderr, "error reading /proc/sys/crypto/fips_enabled: %v\n", err)
+		os.Exit(1)
+	}
+	return len(data) > 0 && data[0] == '1'
+}
diff --git c/src/crypto/internal/backend/hostfips.go i/src/crypto/internal/backend/hostfips.go
index e671cc1547..297a16ad5a 100644
--- c/src/crypto/internal/backend/hostfips.go
+++ i/src/crypto/internal/backend/hostfips.go
@@ -8,6 +8,9 @@ import (
 	"crypto/internal/fips140deps/hostfips"
 )
 
+// HostFIPSModeEnabled checks if the host system has FIPS mode enabled.
+// Uses hostfips.HostEnabled() which does NOT respect GOLANG_NATIVE_HOSTFIPS_OVERRIDE,
+// because that env var is specifically for testing native FIPS, not the OpenSSL backend.
 func HostFIPSModeEnabled() bool {
-	return hostfips.Enabled()
+	return hostfips.HostEnabled()
 }
diff --git c/src/crypto/internal/backend/openssl.go i/src/crypto/internal/backend/openssl.go
index 6ec4453328..8d0230762f 100644
--- c/src/crypto/internal/backend/openssl.go
+++ i/src/crypto/internal/backend/openssl.go
@@ -12,6 +12,7 @@ package backend
 
 import (
 	"crypto/internal/boring/sig"
+	"crypto/internal/fips140deps/godebug"
 	"fmt"
 	"os"
 	"syscall"
@@ -40,6 +41,14 @@ func init() {
 		return
 	}
 
+	// Check mutual exclusivity: GOLANG_FIPS and GODEBUG=fips140 cannot both be set.
+	// When fips == "1", we're about to enable OpenSSL backend. If native FIPS is also
+	// requested via GODEBUG, that's a conflict - user must choose one FIPS implementation.
+	if v := godebug.Value("#fips140"); v != "" {
+		panic("opensslcrypto: GOLANG_FIPS and GODEBUG=fips140 are mutually exclusive; " +
+			"use GOLANG_FIPS=1 for OpenSSL FIPS or GODEBUG=fips140=auto with -tags=no_openssl for native FIPS")
+	}
+
 	version, _ := syscall.Getenv("GO_OPENSSL_VERSION_OVERRIDE")
 	if version == "" {
 		var fallbackVersion string
diff --git c/src/crypto/internal/fips140deps/hostfips/hostfips.go i/src/crypto/internal/fips140deps/hostfips/hostfips.go
index 96d1c05709..12d90a4742 100644
--- c/src/crypto/internal/fips140deps/hostfips/hostfips.go
+++ i/src/crypto/internal/fips140deps/hostfips/hostfips.go
@@ -13,24 +13,39 @@ import (
 var (
 	enabled     bool
 	enabledOnce sync.Once
+
+	hostEnabled     bool
+	hostEnabledOnce sync.Once
 )
 
-// Enabled returns true if the host system has FIPS mode enabled.
+// Enabled returns true if the host system has FIPS mode enabled,
+// or if GOLANG_NATIVE_HOSTFIPS_OVERRIDE=1 is set for testing.
 // It checks /proc/sys/crypto/fips_enabled on Linux.
 // The result is cached after the first call.
 func Enabled() bool {
 	enabledOnce.Do(func() {
-		enabled = checkHostFIPS()
+		// Test override for verifying code paths without a real FIPS-enabled host
+		if os.Getenv("GOLANG_NATIVE_HOSTFIPS_OVERRIDE") == "1" {
+			enabled = true
+			return
+		}
+		enabled = HostEnabled()
 	})
 	return enabled
 }
 
-func checkHostFIPS() bool {
-	// Test override for verifying code paths without a real FIPS-enabled host
-	if os.Getenv("GOLANG_NATIVE_HOSTFIPS_OVERRIDE") == "1" {
-		return true
-	}
+// HostEnabled returns true if the host system has FIPS mode enabled.
+// Unlike Enabled(), this does NOT respect GOLANG_NATIVE_HOSTFIPS_OVERRIDE.
+// Use this when you need to check actual host FIPS status without test overrides.
+// The result is cached after the first call.
+func HostEnabled() bool {
+	hostEnabledOnce.Do(func() {
+		hostEnabled = checkHostFIPS()
+	})
+	return hostEnabled
+}
 
+func checkHostFIPS() bool {
 	// Look at /proc/sys/crypto/fips_enabled to see if FIPS mode is enabled.
 	// If we run into an error reading that file because it doesn't exist, assume FIPS mode is not enabled.
 	data, err := os.ReadFile("/proc/sys/crypto/fips_enabled")
